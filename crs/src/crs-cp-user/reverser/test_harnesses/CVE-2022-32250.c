#define _GNU_SOURCE
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <err.h>
#include <stdbool.h>
#include <sys/stat.h>

#include <arpa/inet.h>
#include <sched.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>

void bye(char *info)
{
  puts(info);
  exit(-2);
}

void do_error_exit(char *info)
{
  puts(info);
  exit(-1);
}

void bye2(char *info, char *arg)
{
  printf(info, arg);
}


void unshare_setup(uid_t uid, gid_t gid)
{
  int temp;
  char edit[0x100];

  unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);

  temp = open("/proc/self/setgroups", O_WRONLY);
  write(temp, "deny", strlen("deny"));
  close(temp);

  temp = open("/proc/self/uid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", uid);
  write(temp, edit, strlen(edit));
  close(temp);

  temp = open("/proc/self/gid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", gid);
  write(temp, edit, strlen(edit));
  close(temp);

  return;
}


void set_table_and_set(struct mnl_socket* nl, const char *name)
{
  const char * table_name = name;
  char * set_name = NULL;
  uint8_t family = NFPROTO_IPV4;
  uint32_t set_id = 1;

  // a table for the sets to be associated with
  struct nftnl_table * table = nftnl_table_alloc();
  nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
  nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

  struct nftnl_set * set_stable =  nftnl_set_alloc();
  set_name = "set0";
  nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);
  nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);
  nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, 1);
  nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);
  nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);

  // expressions
  struct nftnl_expr * exprs[128];
  int exprid = 0;

  // serialize
  char buf[MNL_SOCKET_BUFFER_SIZE*2];

  struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  int seq = 0;

  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  struct nlmsghdr * nlh;
  int table_seq = seq;

  nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);
  nftnl_table_nlmsg_build_payload(nlh, table);
  mnl_nlmsg_batch_next(batch);

  // add set_stable
  nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWSET, family,
      NLM_F_CREATE|NLM_F_ACK, seq++);
  nftnl_set_nlmsg_build_payload(nlh, set_stable);
  nftnl_set_free(set_stable);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  if (nl == NULL) {
    err(1, "mnl_socket_open");
  }

  printf("[+] setting stable %s and set\n", table_name);
  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch)) < 0) {
    err(1, "mnl_socket_send");
  }
}

void set_expr_lookup(struct mnl_socket* nl, const char *name, const char *set_name)
{
  const char * table_name = name;
  uint8_t family = NFPROTO_IPV4;
  uint32_t set_id = 1;
  struct nftnl_expr * exprs[128];
  int exprid = 0;
  struct nlmsghdr * nlh;

  struct nftnl_set * new_set = nftnl_set_alloc();

  nftnl_set_set_str(new_set, NFTNL_SET_TABLE, table_name);
  nftnl_set_set_str(new_set, NFTNL_SET_NAME, set_name);
  nftnl_set_set_u32(new_set, NFTNL_SET_FLAGS, NFT_SET_EXPR);
  nftnl_set_set_u32(new_set, NFTNL_SET_KEY_LEN, 1);
  nftnl_set_set_u32(new_set, NFTNL_SET_FAMILY, family);
  nftnl_set_set_u32(new_set, NFTNL_SET_ID, set_id);
  exprs[exprid] = nftnl_expr_alloc("lookup");
  nftnl_expr_set_str(exprs[exprid], NFTNL_EXPR_LOOKUP_SET, "set0");
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
  nftnl_set_add_expr(new_set, exprs[exprid]);
  exprid++;

  char buf[MNL_SOCKET_BUFFER_SIZE*2];

  struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  int seq = 0;

  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWSET, family,
      NLM_F_CREATE|NLM_F_ACK, seq++);
  nftnl_set_nlmsg_build_payload(nlh, new_set);
  nftnl_set_free(new_set);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  if (nl == NULL) {
    err(1, "mnl_socket_open");
  }

  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch)) < 0) {
    err(1, "mnl_socket_send");
  }
}

/***
 * Blob begins with a 4 byte command count
 * [4-bytes command count]
 * Currently there are two commands:
 *  0     - setup netfilter table and set
 *          [4-bytes table_size][table_size-bytes tablename data]
 *  1     - lookup expression from netfilter table
 *          [4-bytes table_size][table_size-bytes tablename data][4-bytes set_size][set_size-bytes setname data]
 *
 * blob_size MUST be a trusted value
 */
int harness( uint8_t *blob, uint32_t blob_size)
{
  int index = 0;
  uint32_t command, command_count = 0;
  uint32_t size = 0;
  uint8_t* ptr = NULL;

  const char* command_string[2] = {"set_table_and_set", "set_expr_lookup"};
  struct mnl_socket* nl = NULL;

  printf("[INFO] harness blob_size %u \n", blob_size);

  if ( blob == NULL ) {
    return -1;
  }

  if ( blob_size < 4 ) {
    return -1;
  }

  memcpy(&command_count, blob, 4);
  index += 4;

  printf("[INFO] Executing %d commands\n", command_count);
  
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stderr, 0, 2, 0);

  unshare_setup(getuid(), getgid());

  nl = mnl_socket_open(NETLINK_NETFILTER);

  for ( uint32_t i = 0; i < command_count; i++) {
    if ( blob_size - index < 4 ) {
      printf("[ERROR] ran out of commands\n");
      return -1;
    }

    memcpy(&command, blob + index, 4);
    index += 4;

    switch ( command ) {
      case 0:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] %s error. table name size data missing\n", command_string[command]);
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] %s error. table name data missing\n", command_string[command]);
          return -1;
        }
        set_table_and_set(nl, blob + index);
        index += size;
        break;
      case 1:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] %s error. table name size data missing\n", command_string[command]);
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] %s error. table name data missing\n", command_string[command]);
          return -1;
        }
        ptr = blob + index;
        index += size;
        if ( blob_size - index < 4 ) {
          printf("[ERROR] %s error. set name size data missing\n", command_string[command]);
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] %s error. set name data missing\n", command_string[command]);
          return -1;
        }
        set_expr_lookup(nl, ptr, blob + index);
        index += size;
        break;
      default:
        printf("[ERROR] Unknown command: %x\n", command);
        return -1;
    }
  }

  return 0;
}

int main(int argc, char *argv[])
{
  char *blob = NULL;
  struct stat st;
  int fd;

  printf("[INFO] main start! \n");

  if (argc < 2) {
    printf("Need file\n");
    return -1;
  }

  if ( stat(argv[1], &st) != 0) {
    printf("Failed to stat file\n");
    return -1;
  }

  fd = open(argv[1], O_RDONLY);

  if ( fd < 0 ) {
    printf("[ERROR] Failed to open file\n");
    return -1;
  }

  blob = malloc(st.st_size);

  if ( blob == NULL ) {
    printf("[ERROR] malloc failed! \n");
    return 0;
  }

  read(fd, blob, st.st_size);

  close(fd);

  harness(blob, st.st_size);

  return 0;
}
