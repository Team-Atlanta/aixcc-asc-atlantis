#define _GNU_SOURCE

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <err.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <sys/ioctl.h>
#include <sys/mount.h>
#include <attr/xattr.h>
#include <linux/loop.h>

#define MAX_CMD 0x100

#define IMG_SIZE (2*1024*1024) // 2MB

int g_loop_fd = -1;

int make_directory(char* directory){
  if(mkdir(directory, 0755) < 0){
    printf("[Error] make directory : %s \n", directory);
    return -1;
  }
  return 0;
}

int setup(){
  FILE *file = fopen("/tmp/ext4.img", "wb");

  if (!file) {
    printf("[Error] fopen \n");
    return -1;
  }

  if (ftruncate(fileno(file), IMG_SIZE) == -1) {
    printf("[Error] ftruncate \n");
    fclose(file);
    return -1;
  }

  fclose(file);

  system("mkfs.ext4 /tmp/ext4.img");

  int fd = open("/tmp/ext4.img", O_RDWR);
  if (fd < 0) {
    printf("[Error] open image file \n");
    return -1;
  }

  g_loop_fd = open("/dev/loop1", O_RDWR);
  if (g_loop_fd < 0) {
    printf("[Error] open loop device \n");
    close(fd);
    return -1;
  }

  struct loop_info64 loopinfo;
  memset(&loopinfo, 0, sizeof(loopinfo));
  strncpy((char*)loopinfo.lo_file_name, "/tmp/ext4.img", LO_NAME_SIZE);
  loopinfo.lo_flags = LO_FLAGS_AUTOCLEAR;

  if (ioctl(g_loop_fd, LOOP_SET_FD, fd) < 0) {
    printf("[Error] ioctl LOOP_SET_FD \n");
    close(fd);
    close(g_loop_fd);
    return -1;
  }

  if (ioctl(g_loop_fd, LOOP_SET_STATUS64, &loopinfo) < 0) {
    printf("[Error] ioctl LOOP_SET_STATUS64 \n");
    ioctl(g_loop_fd, LOOP_CLR_FD, 0);
    close(fd);
    close(g_loop_fd);
    return -1;
  }

  close(fd);

  return make_directory("/tmp/ext4");
}

int mount_ext4(unsigned long mountflags, char* data){
  return mount("/dev/loop1", "/tmp/ext4", "ext4", mountflags, data);
}

int umount_ext4(){
  return umount("/tmp/ext4");
}

int create_empty_file(char* filepath){
  int fd = open(filepath, O_CREAT | O_WRONLY, 0666);
  if (fd < 0) {
    printf("[Error] error opening file: %s \n", filepath);
    return -1;
  }
  close(fd);

  return 0;
}

int set_xattr(char* filepath, char* name, uint8_t* value, size_t size, int flag){
  return setxattr(filepath, name, value, size, 0);
}


/***
 * Blob begins with a 4 byte command count
 * [4-bytes command count]
 * Currently there are eight commands:
 *  0   - make directory
 *        [4-bytes size][size-bytes directory_path data]
 *  1   - mounts /dev/loop1 to /tmp/ext4 with flags and data(option)
 *        [4-bytes flags][4-bytes size][size-bytes data data]
 *  2   - umounts /tmp/ext4
 *        [None]
 *  3   - create empty file
 *        [4-bytes size][size-bytes file_path data]
 *  4   - set xattr to a file
 *        [4-bytes filepath_size][filepath_size-bytes filepath data][4-bytes name_size][name_size-bytes name data]
 *        [4-bytes value_size][value_size-bytes value data][4-bytes flags]
 *
 * blob_size MUST be a trusted value
 */
int harness( uint8_t *blob, uint32_t blob_size)
{
  int index = 0;
  uint32_t command, command_count = 0;
  uint32_t size = 0;
  unsigned long flag = 0;
  //Variables for this test
  uint8_t* filepath = NULL;
  uint8_t* name = NULL;
  uint8_t* value = NULL;
  size_t value_size = 0;
  int attr_flag = 0;

  printf("[INFO] harness blob_size %u \n", blob_size);

  if ( blob == NULL ) {
    return -1;
  }

  setup();

  if ( blob_size < 4 ) {
    close(g_loop_fd);
    return -1;
  }

  memcpy(&command_count, blob, 4);
  index += 4;

  printf("[INFO] Executing %d commands\n", command_count);
  for ( uint32_t i = 0; i < command_count; i++) {
    if ( blob_size - index < 4 ) {
      printf("[ERROR] ran out of commands\n");
      close(g_loop_fd);
      return -1;
    }

    memcpy(&command, blob + index, 4);
    index += 4;

    switch ( command ) {
      case 0:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] make_directory error\n");
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] make_directory error. Not enough remaining data. \n");
          return -1;
        }
        if (make_directory(blob + index) < 0) {
          printf("[ERROR] make_directory error. returned -1 \n");
          return -1;
        }
        index += size;
        break;
      case 1:
        if ( blob_size - index < 8 ) {
          printf("[ERROR] mount error\n");
          return -1;
        }
        memcpy(&flag, blob + index, 4);
        memcpy(&size, blob + index + 4, 4);
        index += 8;
        if ( blob_size - index < size ) {
          printf("[ERROR] mount error. Not enough remaining data. \n");
          return -1;
        }
        if (mount_ext4(flag, blob + index) < 0) {
          printf("[ERROR] mount error. returned -1 \n");
          return -1;
        }
        index += size;
        break;
      case 2:
        if ( umount_ext4() < 0) {
          printf("[ERROR] umount error. returned -1 \n");
          return -1;
        }
        break;
      case 3:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] create_empty_file error\n");
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] create_empty_file error. Not enough remaining data. \n");
          return -1;
        }
        if (create_empty_file(blob + index) < 0) {
          printf("[ERROR] create_empty_file error. returned -1 \n");
          return -1;
        }
        index += size;
        break;
      case 4:
        //filepath
        if ( blob_size - index < 4 ) {
          printf("[ERROR] set_xattr error(1).\n");
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] set_xattr error. Not enough remaining data(1). \n");
          return -1;
        }
        filepath = blob + index;
        index += size;
        //name
        if ( blob_size - index < 4 ) {
          printf("[ERROR] set_xattr error(2).\n");
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] set_xattr error. Not enough remaining data(2). \n");
          return -1;
        }
        name = blob + index;
        index += size;
        //value
        if ( blob_size - index < 4 ) {
          printf("[ERROR] set_xattr error(3).\n");
          return -1;
        }
        memcpy(&value_size, blob + index, 4);
        index += 4;
        if ( blob_size - index < value_size ) {
          printf("[ERROR] set_xattr error. Not enough remaining data(3). \n");
          return -1;
        }
        value = blob + index;
        index += value_size;
        //flag
        if ( blob_size - index < 4 ) {
          printf("[ERROR] set_xattr error(4).\n");
          return -1;
        }
        memcpy(&attr_flag, blob + index, 4);
        index += 4;
        if (set_xattr(filepath, name, value, value_size, attr_flag) < 0) {
          printf("[ERROR] set_xattr error. returned -1 \n");
          return -1;
        }
        break;
      default:
        printf("[ERROR] Unknown command: %x\n", command);
        return -1;
    }
  }

  close(g_loop_fd);
  return 0;
}

int main(int argc, char *argv[])
{
  char *blob = NULL;
  struct stat st;
  int fd;

  printf("[INFO] main start! \n");

  if (argc < 2) {
    printf("Need file\n");
    return -1;
  }

  if ( stat(argv[1], &st) != 0) {
    printf("Failed to stat file\n");
    return -1;
  }

  fd = open(argv[1], O_RDONLY);

  if ( fd < 0 ) {
    printf("[ERROR] Failed to open file\n");
    return -1;
  }

  blob = malloc(st.st_size);

  if ( blob == NULL ) {
    printf("[ERROR] malloc failed! \n");
    return 0;
  }

  read(fd, blob, st.st_size);

  close(fd);

  harness(blob, st.st_size);

  return 0;
}
