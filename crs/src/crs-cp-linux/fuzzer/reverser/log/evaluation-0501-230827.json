[
  {
    "strategy": "basic_wrapped_reverse",
    "result": {
      "CVE-2022-32250-2": {
        "total_runs": 10,
        "success_count": 0,
        "first_success": -1,
        "unique_count": 4,
        "popular_count": 1,
        "syntactically_correct": 5,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [TABLE_NAME_SIZE (4byte) ][TABLE_NAME (TABLE_NAME_SIZE bytes)][SET_NAME_SIZE (4byte) ][SET_NAME (SET_NAME_SIZE bytes)] repeated three times\nINPUT ::= TABLE_AND_SET\n          TABLE_AND_SET\n          TABLE_AND_SET\n\n// TABLE_AND_SET represents the naming structure for a table and its associated set. \n// It comprises the size of the table name, the table name itself, the size of the set name, and the set name.\nTABLE_AND_SET  ::= TABLE_NAME_SIZE { size: 4 }\n                   TABLE_NAME { size: TABLE_NAME_SIZE }\n                   SET_NAME_SIZE { size: 4 }\n                   SET_NAME { size: SET_NAME_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [SIZE1 (4byte) ][ TABLE_NAME1 (SIZE1 byte) ][SIZE2 (4byte) ][ TABLE_NAME2 (SIZE2 byte) ][SIZE3 (4byte) ][ SET_NAME1 (SIZE3 byte) ][SIZE4 (4byte) ][ TABLE_NAME3 (SIZE4 byte) ][SIZE5 (4byte) ][ SET_NAME2 (SIZE5 byte) ]   \nINPUT ::= SIZE1 { size: 4 }\n          TABLE_NAME1 { size: SIZE1 }\n          SIZE2 { size: 4 }\n          TABLE_NAME2 { size: SIZE2 }\n          SIZE3 { size: 4 }\n          SET_NAME1 { size: SIZE3 }\n          SIZE4 { size: 4 }\n          TABLE_NAME3 { size: SIZE4 }\n          SIZE5 { size: 4 }\n          SET_NAME2 { size: SIZE5 }",
          "// INPUT is the start of the input format\n// INPUT will be [TABLE_1_NAME_SIZE (4byte) ][TABLE_1_NAME(TABLE_1_NAME_SIZE)]\n// [SET_1_NAME_SIZE (4byte)][SET_1_NAME(SET_1_NAME_SIZE)]\n// [TABLE_2_NAME_SIZE (4byte) ][TABLE_2_NAME(TABLE_2_NAME_SIZE)]\n// [SET_2_NAME_SIZE (4byte)][SET_2_NAME(SET_2_NAME_SIZE)]\nINPUT ::= TABLE_NAME_SIZE { size: 4 }   \n          TABLE_NAME[TABLE_NAME_SIZE]  \n          SET_NAME_SIZE { size: 4 }\n          SET_NAME[SET_NAME_SIZE]\n          TABLE_NAME_SIZE { size: 4 }   \n          TABLE_NAME[TABLE_NAME_SIZE]  \n          SET_NAME_SIZE { size: 4 }\n          SET_NAME[SET_NAME_SIZE]\n\n// TABLE_NAME_SIZE declares the length of the next TABLE_NAME field.\n// TABLE_NAME is a string of any printable characters except newline ('\\n').\nTABLE_NAME_SIZE ::= <unsigned integer from 1...MaxInt> \nTABLE_NAME ::= <string>\n\n// SET_NAME_SIZE declares the length of the next SET_NAME field.\n// SET_NAME is a string of any printable characters except newline ('\\n').\nSET_NAME_SIZE ::= <unsigned integer from 1...MaxInt> \nSET_NAME ::= <string>",
          "// INPUT is the start of the input format.\n// INPUT will be [TABLE_NAME_SIZE (4byte) ][TABLE_NAME [SET_NAME_SIZE (4byte)][SET_NAME]]\nINPUT ::= TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME[TABLE_NAME_SIZE]\n          SET_TABLE\n          SET_NAME\n          SET_TABLE\n          SET_NAME\n\nSET_TABLE  ::= TABLE_NAME_SIZE { size: 4 }\n              TABLE_NAME[TABLE_NAME_SIZE]\n\nSET_NAME ::= SET_NAME_SIZE { size: 4 }\n             SET_NAME_NAME[SET_NAME_SIZE]",
          "// INPUT is the start of the input format.\n// INPUT will be [SIZE (4byte)][TABLE_NAME][SIZE(4byte)][SET_NAME][SIZE(4byte\"][SET_NAME]\nINPUT ::= FIRSTCMD SECOND_CMD THIRD_CMD\n\nFIRSTCMD ::= SIZE1 { size: 4 }\n            TABLE_NAME { size: SIZE1 }\n\nSECOND_CMD ::= SIZE2 { size: 4 }\n               TABLE_NAME2 { size: SIZE2 }\n               SIZE3 { size: 4 }\n               SET_NAME { size: SIZE3 }\n\nTHIRD_CMD ::= SIZE4 { size: 4 }\n              TABLE_NAME3 { size: SIZE4 }\n              SIZE5 { size: 4 }\n              SET_NAME2 { SIZE5 }",
          "INPUT ::= TABLE CMD[2]\n\nTABLE ::= TABLE_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_SIZE }\n\nCMD   ::= SET_OVERWRITE\n\nSET_OVERWRITE ::= TABLE \n                  SET\n\nSET   ::= SET_SIZE { size: 4 }\n          SET_NAME { size: SET_SIZE }",
          "INPUT   ::= TABLE { size: 4 }\n            NAME[TABLE]\n\nSET     ::= TABLE_1 { size: 4 }\n            NAME_1[TABLE_1]\n            TABLE_2 { size: 4 }\n            NAME_2[TABLE_2]\n\nNAME    ::= NAME_SIZE { size: 4 }\n            NAME { size: NAME_SIZE }\n\n// The structure INPUT and SET will repeat based on the payload size.\n",
          "// INPUT is the start of the input format.\n// INPUT will be [TABLE_1_SIZE (4 bytes)][TABLE_1_DATA][SET_1_SIZE (4 bytes)][SET_1_DATA][TABLE_2_SIZE (4 bytes)][TABLE_2_DATA][SET_2_SIZE (4 bytes)][SET_2_DATA]\n\nINPUT  ::= TABLE_1_SIZE { size: 4 } \n            TABLE_1_DATA { size: TABLE_1_SIZE } \n            SET_1_SIZE { size: 4 } \n            SET_1_DATA { size: SET_1_SIZE }\n            TABLE_2_SIZE { size: 4 }\n            TABLE_2_DATA { size: TABLE_2_SIZE } \n            SET_2_SIZE { size: 4 } \n            SET_2_DATA { size: SET_2_SIZE } \n\n/* Size of the table name - 4 bytes */\nTABLE_1_SIZE   ::= uint32_t \n/* Data for the table name - TABLE_1_SIZE bytes */\nTABLE_1_DATA   ::= char[TABLE_1_SIZE] \n\n/* Size of the set name - 4 bytes */\nSET_1_SIZE    ::= uint32_t \n/* Data for the set name - SET_1_SIZE bytes */\nSET_1_DATA   ::= char[SET_1_SIZE]\n\n/* Size of the second table name - 4 bytes */\nTABLE_2_SIZE   ::= uint32_t\n/* Data for the second table name - TABLE_2_SIZE bytes */\nTABLE_2_DATA   ::= char[TABLE_2_SIZE] \n\n/* Size of the second set name - 4 bytes */\nSET_2_SIZE    ::= uint32_t \n/* Data for the second set name - SET_2_SIZE bytes */\nSET_2_DATA   ::= char[SET_2_SIZE]",
          "// INPUT is the start of the input format.\n// INPUT will be [TABLE_NAME_SIZE (4 bytes) ][ TABLE_NAME ][2 Iterations of (TABLE_NAME_SIZE (4 bytes) ][ TABLE_NAME][SET_NAME_SIZE (4 bytes) ][ SET_NAME]]\nINPUT ::= TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n          ITERATION[2]\n\n// ITERATION is the structure for the details iterated over twice.\nITERATION ::= TABLE_NAME_SIZE { size: 4 }\n              TABLE_NAME { size: TABLE_NAME_SIZE }\n              SET_NAME_SIZE { size: 4 }\n              SET_NAME { size: SET_NAME_SIZE }",
          "INPUT ::= TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n          TABLE_AND_SET [2]\n\nTABLE_AND_SET ::= TABLE_NAME_SIZE { size: 4 }\n                  TABLE_NAME { size: TABLE_NAME_SIZE }\n                  SET_NAME_SIZE { size: 4 }\n                  SET_NAME { size: SET_NAME_SIZE }  "
        ]
      },
      "linux_test_harness": {
        "total_runs": 10,
        "success_count": 4,
        "first_success": 1,
        "unique_count": 3,
        "popular_count": 3,
        "syntactically_correct": 7,
        "generated": [
          "// The INPUT format is defined as an array of BLOBs\n// blob_file = [COMMAND_COUNT (4byte)][CMD1...CMDn...CMD_COMMAND_COUNT]\n\nINPUT ::= COMMAND_COUNT { size: 4 }\n          CMD[COMMAND_COUNT]\n\nCMD :: =   CMD1 \n        | CMD2\n\nCMD1 ::= COMMAND_TYPE { size: 4, value: 0 }\n          PACKET_SIZE { size: 4 }\n          FLAGS { size: 4 }\n          PACKET_DATA { size: PACKET_SIZE } // the size of PACKET_DATA is PACKET_SIZE\n\nCMD2 ::= COMMAND_TYPE { size: 4, value: 1}\n          MESSAGE_TYPE { size: 4 }\n          FLAGS { size: 4 }\n          NETLINK_PROTOCOL { size: 4 }\n          SIZE { size: 4 }\n          DATA { size: SIZE } // the size of DATA is SIZE",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n          \n// CMD will be CMD1 or CMD2 depending on types of command.\nCMD   ::= CMD1\n        | CMD2\n        \nCMD1  ::= OPCODE { size: 4, value: 0 }   // OPCODE value 0 for send packet blob\n          PKT_SIZE { size: 4 }\n          FLAGS { size: 4 }\n          PKT_DATA { size: PKT_SIZE }\n          \nCMD2  ::= OPCODE { size: 4, value: 1 }   // OPCODE value 1 for send netlink packet\n          MSG_TYPE { size: 4 }\n          MSG_FLAGS { size: 4 }\n          NL_PROTOCOL { size: 4 }\n          NL_PKT_SIZE { size: 4 }\n          NL_PKT_DATA { size: NL_PKT_SIZE }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2\n\nCMD1  ::= PACKET_SIZE { size: 4 }\n          FLAGS { size: 4 }\n          PACKET_DATA { size: PACKET_SIZE }\n\nCMD2  ::= MSG_TYPE { size: 4 }\n          MSG_FLAGS { size: 4 }\n          PROTOCOL { size: 4 }\n          PKT_SIZE { size: 4 }\n          PKT_DATA { size: PKT_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte) ][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be COMMAND1 or COMMAND2\nCOMMAND ::= COMMAND1 \n          | COMMAND2 \n\n// COMMAND1 is for sending a packet blob \n// It consists of [COMMAND_TYPE (4byte)][PACKET_SIZE (4byte)][SEND_FLAGS (4byte)][PACKET_DATA (PACKET_SIZE byte)]\nCOMMAND1 ::= \n          COMMAND_TYPE { size: 4, value: 0 }\n          PACKET_SIZE { size: 4 } \n          SEND_FLAGS { size: 4 }\n          PACKET_DATA { size: PACKET_SIZE } \n\n// COMMAND2 is for sending a netlink packet\n// It consists of [COMMAND_TYPE (4byte)][MESSAGE_TYPE (4byte)][MESSAGE_FLAGS (4byte)]\n//                [NETLINK_PROTOCOL (4byte)][SIZE (4byte)][DATA (SIZE byte)]\nCOMMAND2 ::= \n          COMMAND_TYPE { size: 4, value: 1 } \n          MESSAGE_TYPE { size: 4 }  \n          MESSAGE_FLAGS { size: 4 }\n          NETLINK_PROTOCOL { size: 4 }\n          SIZE { size: 4 }\n          DATA { size: SIZE } ",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD0 or CMD1 if the target program has two commands.\nCMD   ::= CMD0 \n        | CMD1\n\nCMD0  ::= CMD_TYPE { size: 4, value: 0 } // CMD_TYPE value 0 comes from the case statement\n          PKT_SIZE { size: 4 }  \n          FLAGS { size: 4 }       \n          DATA { size: PKT_SIZE }     // the size of DATA is PKT_SIZE\n\nCMD1  ::= CMD_TYPE { size: 4, value: 1} // CMD_TYPE value 1 comes from the case statement\n          NETLINK_PKT { size: variable }\n\nNETLINK_PKT ::= MSG_TYPE { size: 4 }\n                MSG_FLAGS { size: 4 }\n                PROTOCOL { size: 4 }\n                PKT_SIZE { size: 4 }\n                PKT_DATA { size: PKT_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 or CMD2\nCMD   ::= CMD1 \n        | CMD2\n\nCMD1  ::= OPCODE { size: 4, value: 0} // OPCODE value 0 comes from the 'case 0' statement\n          PACKET_SIZE { size: 4} \n          PACKET_FLAGS { size: 4 }\n          PACKET_DATA { size: PACKET_SIZE }\n\nCMD2  ::= NETMSG { size: 16 } // 16 comes from the size of the 4*4 fields\n          NETMSG_DATA { size: PACKET_SIZE }\nNETMSG ::= MSG_TYPE { size: 4 }\n           MSG_FLAGS { size: 4 }\n           NETLINK_PROTOCOL { size: 4 }\n           PACKET_SIZE { size: 4 }\n\nNETMSG_DATA ::= { size: PACKET_SIZE } // PACKET_SIZE from `NETMSG` above",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\n// CMD will be either CMD1 or CMD2 based on the value of COMMAND in each command.\nCMD   ::= CMD1 \n        | CMD2\n\n// CMD1 represents a packet blob to be sent, shown with COMMAND value 0 from the switch case.\nCMD1  ::= COMMAND { size: 4, value: 0 }\n          PACKET_SIZE { size: 4 }\n          FLAGS { size: 4 }\n          PACKET_DATA { size: PACKET_SIZE }\n          \n// CMD2 represents a netlink packet to be sent, shown with COMMAND value 1 from the switch case.\nCMD2  ::= COMMAND { size: 4, value: 1 }\n          MSG_TYPE { size: 4 }\n          MSG_FLAGS { size: 4 }\n          PROTOCOL { size: 4 }\n          PACKET_SIZE { size: 4 }\n          PACKET_DATA { size: PACKET_SIZE }",
          "// INPUT is the beginning of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 or CMD2, corresponding to sending a packet or sending a netlink packet.\nCMD   ::= CMD1\n        | CMD2\n\n// Command 0 is to send a packet blob\nCMD1  ::= CMD_TYPE { size: 4, value: 0 }\n          PACKET_SIZE { size: 4 }\n          FLAGS { size: 4 }\n          PACKET_DATA { size: PACKET_SIZE }\n\n// Command 1 is to send a netlink packet.\nCMD2  ::= CMD_TYPE { size: 4, value: 1 }\n          PORT_MSG { size: 4 }\n          PORT_FLAGS { size: 4 }\n          PROTOCOL { size: 4 }\n          PKT_SIZE { size: 4 }\n          PKT_DATA { size: PKT_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD0 or CMD1 if the target program has two commands.\nCMD   ::= CMD0 \n        | CMD1\n\nCMD0  ::= OPCODE { size: 4, value: 0} // OPCODE value 0 comes from the first if statement \n          DATA0_SIZE { size: 4 }\n          FLAGS { size: 4 }\n          DATA0 { size: DATA0_SIZE }\n\nCMD1  ::= OPCODE { size: 4, value: 1} // OPCODE value 1 comes from the second if statement\n          MSGTYPE { size: 4 }\n          FLAGS { size: 4 }\n          PROTOCOL { size: 4 }\n          DATA1_SIZE { size: 4 }\n          DATA1 { size: DATA1_SIZE }",
          "// INPUT ::= -> represents the start of the input. \n// Expected format: [CMD_CNT (4byte)][CMD_CNT times of CMD]\nINPUT ::= CMD_CNT {size: 4} \n          CMD[CMD_CNT]\n\n// CMD ::= Command definition may either be CMD1, CMD2 \nCMD   ::= CMD1\n        | CMD2\n\n// CMD1 ::= This command represents the structure for sending a packet blob.\n// Format: [SEND_SIZE (4byte)][FLAGS (4byte)][SEND_DATA (size: SEND_SIZE byte)]\nCMD1  ::= SEND_SIZE {size: 4} \n          FLAGS {size: 4}\n          SEND_DATA {size: SEND_SIZE}\n\n// CMD2 ::= This command represents the structure for sending a netlink packet. \n// Format: [MSG_TYPE(4byte)][MSG_FLAGS (4byte)][NETLINK_PROTOCOL (4byte)][SEND_SIZE (4byte)][SEND_DATA (size: SEND_SIZE byte)]\nCMD2  ::= MSG_TYPE {size: 4}\n          MSG_FLAGS {size: 4}\n          NETLINK_PROTOCOL {size: 4}\n          SEND_SIZE {size: 4}\n          SEND_DATA {size: SEND_SIZE}"
        ]
      },
      "CROMU-00001": {
        "total_runs": 10,
        "success_count": 9,
        "first_success": 1,
        "unique_count": 1,
        "popular_count": 8,
        "syntactically_correct": 9,
        "generated": [
          "// IO control code stands for specific operations\nIOCTL_CREATE ::= { size: 4, value: 0xc00010ff }\nIOCTL_LOGIN ::= { size: 4, value: 0x1337beef }\nIOCTL_EXIT ::= { size: 4, value: 0x13370001 }\nIOCTL_SEND_MSG ::= { size: 4, value: 0x13370002 }\nIOCTL_READ_MSG ::= { size: 4, value: 0x13370003 }\nIOCTL_LIST_MSG ::= { size: 4, value: 0x13370004 }\nIOCTL_DEL_MSG ::= { size: 4, value: 0x13370005 }\nIOCTL_LOGOUT ::= { size: 4, value: 0x13370006 }\n\n// INPUT is the start of the input format.\n// INPUT will start with a CMD_CNT record representing the total number of command blobs\nINPUT ::= CMD_CNT { size: 4 }\n          CMD_DATABLOB[CMD_CNT] // There will be CMD_CNT command blobs\n\n// CMD_DATABLOB is a command blob consisting of an OPERATION and OPERATION specific data\nCMD_DATABLOB ::= OPERATION\n                OPERATION_DATA\n\n// OPERATION is one of eight IO control codes\nOPERATION ::= IOCTL_CREATE\n            | IOCTL_LOGIN\n            | IOCTL_EXIT\n            | IOCTL_SEND_MSG\n            | IOCTL_READ_MSG\n            | IOCTL_LIST_MSG\n            | IOCTL_DEL_MSG\n            | IOCTL_LOGOUT\n\n// OPERATION_DATA is specific to the OPERATION. Some OPERATION has no data.\nOPERATION_DATA ::= CREATE_DATA\n                 | LOGIN_DATA\n                 | SENDMSG_DATA\n                 | READMSG_DATA\n                 | DELMSG_DATA\n                 | EMPTY // For OPERATIONs IOCTL_EXIT, IOCTL_LIST_MSG, IOCTL_LOGOUT\n\nCREATE_DATA ::= USERNAME_SIZE { size: 4 }\n                USERNAME_CONTENT[USERNAME_SIZE]\n\nLOGIN_DATA ::= USERNAME_SIZE { size: 4 }\n               USERNAME_CONTENT[USERNAME_SIZE]\n\nSENDMSG_DATA ::= USERNAME_SIZE { size: 4 }\n                 USERNAME_CONTENT[USERNAME_SIZE]\n                 MESSAGE_SIZE { size: 4 }\n                 MESSAGE_CONTENT[MESSAGE_SIZE]\n\nREADMSG_DATA ::= MESSAGE_ID { size: 4 }\n\nDELMSG_DATA ::= MESSAGE_ID { size: 4 }\n\nUSERNAME_CONTENT ::= ASCII { size: 1 }[USERNAME_SIZE]\nMESSAGE_CONTENT ::= ASCII { size: 1}[MESSAGE_SIZE]",
          "// INPUT starts with COMMAND_COUNT (4 bytes), followed by an array of COMMANDS\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND uses opcode format, each opcode calls different functions\nCOMMAND ::= CREATE_CMD \n          | LOGIN_CMD \n          | EXIT_CMD \n          | SEND_MSG_CMD \n          | READ_MSG_CMD\n          | LIST_MSG_CMD \n          | DEL_MSG_CMD\n          | LOGOUT_CMD\n\n// create_user, with opcode equal to IOCTL_CREATE (0xc00010ff)\nCREATE_CMD ::= OPCODE { size: 4, value: 0xc00010ff }\n               USERNAME_SIZE { size: 4 }\n               USERNAME { size: USERNAME_SIZE }\n\n// login, with opcode equal to IOCTL_LOGIN (0x1337beef)\nLOGIN_CMD ::= OPCODE { size: 4, value: 0x1337beef }\n              USERNAME_SIZE { size: 4 }\n              USERNAME { size: USERNAME_SIZE }\n\n// service_exit, with opcode equal to IOCTL_EXIT (0x13370001)\nEXIT_CMD ::= OPCODE { size: 4, value: 0x13370001 }\n\n// send_msg, with opcode equal to IOCTL_SEND_MSG (0x13370002)\nSEND_MSG_CMD ::= OPCODE { size: 4, value: 0x13370002 }\n                 USERNAME_SIZE { size: 4 }\n                 USERNAME { size: USERNAME_SIZE }\n                 MESSAGE_SIZE { size: 4 }\n                 MESSAGE { size: MESSAGE_SIZE }\n\n// read_msg, with opcode equal to IOCTL_READ_MSG (0x13370003)\nREAD_MSG_CMD ::= OPCODE { size: 4, value: 0x13370003 }\n                 MESSAGE_ID { size: 4 }\n\n// list_msg, with opcode equal to IOCTL_LIST_MSG (0x13370004)\nLIST_MSG_CMD ::= OPCODE { size: 4, value: 0x13370004 }\n\n// del_msg, with opcode equal to IOCTL_DEL_MSG (0x13370005)\nDEL_MSG_CMD ::= OPCODE { size: 4, value: 0x13370005 }\n                MESSAGE_ID { size: 4 }\n\n// logout, with opcode equal to IOCTL_LOGOUT (0x13370006)\nLOGOUT_CMD ::= OPCODE { size: 4, value: 0x13370006 }",
          "INPUT ::= CMD_COUNT { size: 4 }\n            CMD[CMD_COUNT]\n\nCMD ::= CMD_CREATE_USER \n      | CMD_LOGIN \n      | CMD_EXIT \n      | CMD_SEND_MSG \n      | CMD_READ_MSG \n      | CMD_LIST_MSG \n      | CMD_DEL_MSG \n      | CMD_LOGOUT \n\nCMD_CREATE_USER ::= IOCTL_CREATE { size: 4, value: 0xc00010ff }\n                      USERNAME_SIZE { size: 4 }\n                      USERNAME_DATA { size: USERNAME_SIZE }\n\nCMD_LOGIN ::= IOCTL_LOGIN { size: 4, value: 0x1337beef }\n                USERNAME_SIZE { size: 4 }\n                USERNAME_DATA { size: USERNAME_SIZE }\n\nCMD_EXIT ::= IOCTL_EXIT { size: 4, value: 0x13370001 }\n\nCMD_SEND_MSG ::= IOCTL_SEND_MSG { size: 4, value: 0x13370002 }\n                   USERNAME_SIZE { size: 4 }\n                   USERNAME_DATA { size: USERNAME_SIZE }\n                   MSG_SIZE { size: 4 }\n                   MSG_DATA { size: MSG_SIZE }\n\nCMD_READ_MSG ::= IOCTL_READ_MSG { size: 4, value: 0x13370003 }\n                   MSG_ID { size: 4 }\n\nCMD_LIST_MSG ::= IOCTL_LIST_MSG { size: 4, value: 0x13370004 }\n\nCMD_DEL_MSG ::= IOCTL_DEL_MSG { size: 4, value: 0x13370005 }\n                  MSG_ID { size: 4 }\n\nCMD_LOGOUT ::= IOCTL_LOGOUT { size: 4, value: 0x13370006 }",
          "INPUT ::= COMMAND_COUNT { size: 4} \n          COMMANDS[COMMAND_COUNT]\n\nCOMMANDS ::=  CREATE_COMMAND\n            | LOGIN_COMMAND\n            | EXIT_COMMAND\n            | SEND_MSG_COMMAND\n            | READ_MSG_COMMAND\n            | LIST_MSG_COMMAND\n            | DEL_MSG_COMMAND\n            | LOGOUT_COMMAND\n\nCREATE_COMMAND ::= COMMAND { size: 4, value: 0xc00010ff }\n                   USERNAME_SIZE { size: 4 }       \n                   USERNAME { size: USERNAME_SIZE }\n\nLOGIN_COMMAND ::= COMMAND { size: 4, value: 0x1337beef } // IOCTL_LOGIN = 0x1337beef\n                  USERNAME_SIZE { size: 4 }       \n                  USERNAME { size: USERNAME_SIZE }\n\nEXIT_COMMAND ::= COMMAND { size: 4, value: 0x13370001 } // IOCTL_EXIT = 0x13370001\n\nSEND_MSG_COMMAND ::= COMMAND { size: 4, value: 0x13370002 } // IOCTL_SEND_MSG = 0x13370002\n                     USERNAME_SIZE { size: 4 }\n                     USERNAME { size: USERNAME_SIZE }\n                     MESSAGE_SIZE { size: 4 }\n                     MESSAGE { size: MESSAGE_SIZE }\n\nREAD_MSG_COMMAND ::= COMMAND { size: 4, value: 0x13370003 } // IOCTL_READ_MSG = 0x13370003\n                     MESSAGE_ID { size: 4 }\n\nLIST_MSG_COMMAND ::= COMMAND { size: 4, value: 0x13370004 } // IOCTL_LIST_MSG = 0x13370004\n\nDEL_MSG_COMMAND ::= COMMAND { size: 4, value: 0x13370005 } // IOCTL_DEL_MSG = 0x13370005\n                    MESSAGE_ID { size: 4 }\n\nLOGOUT_COMMAND ::= COMMAND { size: 4, value: 0x13370006 } // IOCTL_LOGOUT = 0x13370006",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4 byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be one of the eight commands depending on the valued extracted\nCMD   ::= CREATE_CMD\n        | LOGIN_CMD\n        | EXIT_CMD\n        | SEND_MSG_CMD\n        | READ_MSG_CMD\n        | LIST_MSG_CMD\n        | DEL_MSG_CMD\n        | LOGOUT_CMD\n        \nCREATE_CMD  ::= CMD_TYPE { size: 4, value: 0xc00010ff } // The value comes from the command\n               USERNAME_SIZE { size: 4 }       \n               USERNAME_DATA { size: USERNAME_SIZE }\n\nLOGIN_CMD   ::= CMD_TYPE { size: 4, value: 0x1337beef }\n               USERNAME_SIZE { size: 4 }\n               USERNAME_DATA { size: USERNAME_SIZE }\n               \nEXIT_CMD    ::= CMD_TYPE { size: 4, value: 0x13370001 }\n\nSEND_MSG_CMD::= CMD_TYPE { size: 4, value: 0x13370002 }\n                USERNAME_SIZE { size: 4 }\n                USERNAME_DATA { size: USERNAME_SIZE }\n                MSG_SIZE { size: 4 }\n                MSG_DATA { size: MSG_SIZE }\n\nREAD_MSG_CMD ::= CMD_TYPE { size: 4, value: 0x13370003 }\n                 MSG_ID { size: 4 }\n\nLIST_MSG_CMD ::= CMD_TYPE { size: 4, value: 0x13370004 }\n\nDEL_MSG_CMD  ::= CMD_TYPE { size: 4, value: 0x13370005 }\n                 MSG_ID { size: 4 }\n\nLOGOUT_CMD   ::= CMD_TYPE { size: 4, value: 0x13370006 }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD_CREATE\n        | CMD_LOGIN\n        | CMD_EXIT\n        | CMD_SEND_MSG\n        | CMD_READ_MSG\n        | CMD_LIST_MSG\n        | CMD_DEL_MSG\n        | CMD_LOGOUT\n\nCMD_CREATE  ::= CMD_TYPE_CREATE { size: 4, value: 0xc00010ff }\n               USERNAME_SIZE { size: 4 }\n               USERNAME { size: USERNAME_SIZE }\n\nCMD_LOGIN   ::= CMD_TYPE_LOGIN { size: 4, value: 0x1337beef }\n               USERNAME_SIZE { size: 4 }\n               USERNAME { size: USERNAME_SIZE }\n\nCMD_EXIT    ::= CMD_TYPE_EXIT { size: 4, value: 0x13370001 }\n\nCMD_SEND_MSG ::= CMD_TYPE_SEND_MSG { size: 4, value: 0x13370002 }\n                USERNAME_SIZE { size: 4 }\n                USERNAME { size: USERNAME_SIZE }\n                MSG_SIZE { size: 4 }\n                MSG { size: MSG_SIZE }\n\nCMD_READ_MSG ::= CMD_TYPE_READ_MSG { size: 4, value: 0x13370003 }\n                MSG_ID { size: 4 }\n\nCMD_LIST_MSG ::= CMD_TYPE_LIST_MSG { size: 4, value: 0x13370004 }\n\nCMD_DEL_MSG ::= CMD_TYPE_DEL_MSG { size: 4, value: 0x13370005 }\n               MSG_ID { size: 4 }\n\nCMD_LOGOUT ::= CMD_TYPE_LOGOUT { size: 4, value: 0x13370006 }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= IOCTL_CREATE_CMD \n        | IOCTL_LOGIN_CMD \n        | IOCTL_EXIT_CMD\n        | IOCTL_SEND_MSG_CMD \n        | IOCTL_READ_MSG_CMD\n        | IOCTL_LIST_MSG_CMD\n        | IOCTL_DEL_MSG_CMD\n        | IOCTL_LOGOUT_CMD\n\nIOCTL_CREATE_CMD ::= OPCODE { size: 4, value: 0xc00010ff }\n                     USERNAME_SIZE { size: 4 }\n                     USERNAME_DATA { size: USERNAME_SIZE }\n\nIOCTL_LOGIN_CMD  ::= OPCODE { size: 4, value: 0x1337beef }\n                     USERNAME_SIZE { size: 4 }\n                     USERNAME_DATA { size: USERNAME_SIZE }\n\nIOCTL_EXIT_CMD   ::= OPCODE { size: 4, value: 0x13370001 }\n\nIOCTL_SEND_MSG_CMD ::= OPCODE { size: 4, value: 0x13370002 }\n                       USERNAME_SIZE { size: 4 }\n                       USERNAME_DATA { size: USERNAME_SIZE }\n                       MSG_SIZE { size: 4 }\n                       MSG_DATA { size: MSG_SIZE }\n\nIOCTL_READ_MSG_CMD ::= OPCODE { size: 4, value: 0x13370003 }\n                       MSG_ID { size: 4 }\n\nIOCTL_LIST_MSG_CMD ::= OPCODE { size: 4, value: 0x13370004 }\n\nIOCTL_DEL_MSG_CMD ::= OPCODE { size: 4, value: 0x13370005 }\n                      MSG_ID { size: 4 }\n\nIOCTL_LOGOUT_CMD ::= OPCODE { size: 4, value: 0x13370006 }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= IOCTL_CREATE_CMD \n        | IOCTL_LOGIN_CMD\n        | IOCTL_EXIT_CMD\n        | IOCTL_SEND_MSG_CMD\n        | IOCTL_READ_MSG_CMD\n        | IOCTL_LIST_MSG_CMD\n        | IOCTL_DEL_MSG_CMD\n        | IOCTL_LOGOUT_CMD\n\n// each CMD type is associated with different command parameters\n\nIOCTL_CREATE_CMD ::= CMD_TYPE { size: 4, value: 0xc00010ff }  // IOCTL_CREATE command\n                     USERNAME_SIZE { size: 4 }\n                     USERNAME_DATA { size: USERNAME_SIZE }\n\nIOCTL_LOGIN_CMD ::= CMD_TYPE { size: 4, value: 0x1337beef }  // IOCTL_LOGIN command\n                    USERNAME_SIZE { size: 4 }\n                    USERNAME_DATA { size: USERNAME_SIZE }\n\nIOCTL_EXIT_CMD ::= CMD_TYPE { size: 4, value: 0x13370001 }   // IOCTL_EXIT command\n\nIOCTL_SEND_MSG_CMD ::= CMD_TYPE { size: 4, value: 0x13370002 } // IOCTL_SEND_MSG command\n                       USERNAME_SIZE { size: 4 }\n                       USERNAME_DATA { size: USERNAME_SIZE }\n                       MESSAGE_SIZE { size: 4 }\n                       MESSAGE_DATA { size: MESSAGE_SIZE }\n\nIOCTL_READ_MSG_CMD ::= CMD_TYPE { size: 4, value: 0x13370003 } // IOCTL_READ_MSG command\n                       MESSAGE_ID { size: 4 }\n\nIOCTL_LIST_MSG_CMD ::= CMD_TYPE { size: 4, value: 0x13370004 } // IOCTL_LIST_MSG command\n\nIOCTL_DEL_MSG_CMD ::= CMD_TYPE { size: 4, value: 0x13370005 }  // IOCTL_DEL_MSG command\n                      MESSAGE_ID { size: 4 }\n\nIOCTL_LOGOUT_CMD ::= CMD_TYPE { size: 4, value: 0x13370006 }   // IOCTL_LOGOUT command",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2 \n        | CMD3 \n        | CMD4 \n        | CMD5\n        | CMD6\n        | CMD7\n        | CMD8\n\nCMD1  ::= IOCTL_CREATE { size: 4, value: 0xc00010ff } \n          USERNAME_SIZE { size: 4 }\n          USERNAME { size: USERNAME_SIZE }\n\nCMD2  ::= IOCTL_LOGIN { size: 4, value: 0x1337beef }\n          USERNAME_SIZE { size: 4 }\n          USERNAME { size: USERNAME_SIZE }\n\nCMD3  ::= IOCTL_EXIT { size: 4, value: 0x13370001 }\n\nCMD4  ::= IOCTL_SEND_MSG { size: 4, value: 0x13370002 }\n          USERNAME_SIZE { size: 4 }\n          USERNAME { size: USERNAME_SIZE }\n          MSG_SIZE { size: 4 }\n          MESSAGE { size: MSG_SIZE }\n\nCMD5  ::= IOCTL_READ_MSG { size: 4, value: 0x13370003 }\n          MSG_ID { size: 4 }\n\nCMD6  ::= IOCTL_LIST_MSG { size: 4, value: 0x13370004 }\n\nCMD7  ::= IOCTL_DEL_MSG { size: 4, value: 0x13370005 }\n          MSG_ID { size: 4 }\n\nCMD8  ::= IOCTL_LOGOUT { size: 4, value: 0x13370006 }",
          "// INPUT is the start of the blob and will include a command count followed by commands\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will represent one of the eight commands available\nCOMMAND ::= IOCTL_CREATE_CMD\n          | IOCTL_LOGIN_CMD\n          | IOCTL_EXIT_CMD\n          | IOCTL_SEND_MSG_CMD\n          | IOCTL_READ_MSG_CMD\n          | IOCTL_LIST_MSG_CMD\n          | IOCTL_DEL_MSG_CMD\n          | IOCTL_LOGOUT_CMD\n\n\nIOCTL_CREATE_CMD ::= OPCODE { size: 4, value: 0xc00010ff }\n                     USER_SIZE { size: 4 }\n                     USERNAME { size: USER_SIZE }\n\nIOCTL_LOGIN_CMD ::= OPCODE { size: 4, value: 0x1337beef }\n                    USER_SIZE { size: 4 }\n                    USERNAME { size: USER_SIZE }\n\nIOCTL_EXIT_CMD ::= OPCODE { size: 4, value: 0x13370001 }\n\nIOCTL_SEND_MSG_CMD ::= OPCODE { size: 4, value: 0x13370002 }\n                       USER_SIZE { size: 4 }\n                       USERNAME { size: USER_SIZE }\n                       MESSAGE_SIZE { size: 4 }\n                       MESSAGE { size: MESSAGE_SIZE }\n\nIOCTL_READ_MSG_CMD ::= OPCODE { size: 4, value: 0x13370003 }\n                       MSG_ID { size: 4 }\n\nIOCTL_LIST_MSG_CMD ::= OPCODE { size: 4, value: 0x13370004 }\n\nIOCTL_DEL_MSG_CMD ::= OPCODE { size: 4, value: 0x13370005 }\n                      MSG_ID { size: 4 }\n\nIOCTL_LOGOUT_CMD ::= OPCODE { size: 4, value: 0x13370006 }"
        ]
      },
      "CVE-2021-38208": {
        "total_runs": 10,
        "success_count": 9,
        "first_success": 1,
        "unique_count": 1,
        "popular_count": 8,
        "syntactically_correct": 9,
        "generated": [
          "INPUT ::= COMMAND_COUNT \n          COMMAND { count: COMMAND_COUNT }\n\nCOMMAND_COUNT ::= UINT32\n\nUINT32 ::= _ { size: 4 }\n\nIDENTIFIER ::= _ { size: 4, range: 0 - 99 }\n\nUINT32_SIZE ::= UINT32\n\nDOMAIN ::= UINT32\n\nTYPE ::= UINT32\n\nPROTOCOL ::= UINT32\n\nBACKLOG ::= UINT32\n\nADDR_SIZE ::= _ { size: 4 }\n\nADDR ::= _ { size: ADDR_SIZE }\n\nCOMMAND ::= COMMAND_SOCKET \n          | COMMAND_BIND \n          | COMMAND_LISTEN \n          | GETPEERNAME_COMMAND \n\nCOMMAND_SOCKET ::= OPCODE { value: 0, size: 4 }\n                   IDENTIFIER \n                   DOMAIN \n                   TYPE \n                   PROTOCOL \n\nCOMMAND_BIND ::= OPCODE { value: 1, size: 4 }\n                 IDENTIFIER \n                 ADDR_SIZE \n                 ADDR { size: ADDR_SIZE }\n\nCOMMAND_LISTEN ::= OPCODE { value: 2, size: 4 }\n                   IDENTIFIER \n                   BACKLOG \n\nGETPEERNAME_COMMAND ::= OPCODE { value: 3, size: 4 }\n                        IDENTIFIER",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD can be CMD1, CMD2, CMD3 or CMD4\nCMD   ::= CMD1 \n        | CMD2\n        | CMD3\n        | CMD4\n\nCMD1  ::= OPCODE { size: 4, value: 0 } \n          IDENTIFIER { size: 4 }\n          DOMAIN { size: 4 } \n          TYPE { size: 4 }\n          PROTOCOL { size: 4 }\n\nCMD2  ::= OPCODE { size: 4, value: 1 } \n          IDENTIFIER { size: 4 }\n          SIZE { size: 4 }\n          ADDR_DATA { size: SIZE }\n\nCMD3  ::= OPCODE { size: 4, value: 2 }\n          IDENTIFIER { size: 4 }\n          BACKLOG { size: 4 }\n\nCMD4  ::= OPCODE { size: 4, value: 3 }\n          IDENTIFIER { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte) ][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be CMD_SOCKET, CMD_BIND, CMD_LISTEN, or CMD_GETPEERNAME\nCOMMAND   ::= CMD_SOCKET \n            | CMD_BIND\n            | CMD_LISTEN\n            | CMD_GETPEERNAME\n\n// CMD_SOCKET format is [opcode {4-bytes (value: 0)}][identifier {4-bytes}][domain {4-bytes}][type {4-bytes}][protocol {4-bytes}]\nCMD_SOCKET  ::= OPCODE { size: 4, value: 0 }\n               IDENTIFIER { size: 4 }\n               DOMAIN { size: 4 }\n               TYPE { size: 4 }\n               PROTOCOL { size: 4 }\n\n// CMD_BIND format is [opcode {4-bytes (value: 1)}][identifier {4-bytes}][size {4-bytes}][addr data {size-bytes}]\nCMD_BIND  ::= OPCODE { size: 4, value: 1 }\n              IDENTIFIER { size: 4 }\n              SIZE { size: 4 }\n              ADDR_DATA { size: SIZE }\n\n// CMD_LISTEN format is [opcode {4-bytes (value: 2)}][identifier {4-bytes}][backlog {4-bytes}]\nCMD_LISTEN  ::= OPCODE { size: 4, value: 2 }\n                IDENTIFIER { size: 4 }\n                BACKLOG { size: 4 }\n\n// CMD_GETPEERNAME format is [opcode {4-bytes (value: 3)}][identifier {4-bytes}]\nCMD_GETPEERNAME  ::= OPCODE { size: 4, value: 3 }\n                     IDENTIFIER { size: 4 }",
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\nCOMMAND ::= SOCKET_COMMAND\n          | BIND_COMMAND\n          | LISTEN_COMMAND\n          | GETPEERNAME_COMMAND\n\nSOCKET_COMMAND ::= COMMAND { size: 4, value: 0 }\n                   IDENTIFIER { size: 4 }\n                   DOMAIN { size: 4 }\n                   TYPE  { size: 4 }\n                   PROTOCOL  { size: 4 }\n\nBIND_COMMAND ::= COMMAND { size: 4, value: 1 }\n                 IDENTIFIER { size: 4 }\n                 SIZE { size: 4 }\n                 ADDR { size: SIZE }\n\nLISTEN_COMMAND ::= COMMAND { size: 4, value: 2 }\n                   IDENTIFIER { size: 4 }\n                   BACKLOG { size: 4 }\n\nGETPEERNAME_COMMAND ::= COMMAND { size: 4, value: 3 }\n                        IDENTIFIER { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD0, CMD1, CMD2 or CMD3 according to the given program\nCMD   ::= CMD0\n        | CMD1\n        | CMD2\n        | CMD3\n\nCMD0  ::= OPCODE { size: 4, value: 0} \n          IDENTIFIER { size: 4}\n          DOMAIN { size: 4}\n          TYPE { size: 4}\n          PROTOCOL { size: 4}\n\nCMD1  ::= OPCODE { size: 4, value: 1}\n          IDENTIFIER { size: 4}\n          DATA_SIZE { size: 4}\n          DATA { size: DATA_SIZE}\n\nCMD2  ::= OPCODE { size: 4, value: 2}\n          IDENTIFIER { size: 4}\n          BACKLOG { size: 4}\n\nCMD3  ::= OPCODE { size: 4, value: 3}\n          IDENTIFIER { size: 4}",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be one of four values corresponding to the four commands.\nCMD   ::= CMD0 \n        | CMD1 \n        | CMD2\n        | CMD3\n\nCMD0  ::= OPCODE { size: 4, value: 0 } \n          IDENTIFIER { size: 4 }\n          DOMAIN { size: 4 }\n          TYPE { size: 4 }\n          PROTOCOL { size: 4 }\n\nCMD1  ::= OPCODE { size: 4, value: 1 }\n          IDENTIFIER { size: 4 }\n          SIZE { size: 4 }\n          ADDR_DATA { size: SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 2 }\n          IDENTIFIER { size: 4 }\n          BACKLOG { size: 4 }\n\nCMD3  ::= OPCODE { size: 4, value: 3 }\n          IDENTIFIER { size: 4 }",
          "// The input starts with a Command Count.\nINPUT ::= CMD_CNT {size: 4}\n          CMD[CMD_CNT]\n\n// CMD is one of CMD0, CMD1, CMD2, or CMD3.\nCMD ::= CMD0\n       |CMD1\n       |CMD2\n       |CMD3\n\nCMD0 ::= OPCODE {size: 4, value: 0} \n         IDENTIFIER {size: 4}\n         DOMAIN {size: 4}\n         TYPE {size: 4}\n         PROTOCOL {size: 4}\n         \nCMD1 ::= OPCODE {size: 4, value: 1}\n         IDENTIFIER {size: 4}\n         ADDR_SIZE {size: 4}\n         ADDR_DATA {size: ADDR_SIZE}\n         \nCMD2 ::= OPCODE {size: 4, value: 2} \n         IDENTIFIER {size: 4}\n         BACKLOG {size: 4}\n         \nCMD3 ::= OPCODE {size: 4, value: 3}\n         IDENTIFIER {size: 4}",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= SOCKET_CMD\n        | BIND_CMD\n        | LISTEN_CMD\n        | GETPEERNAME_CMD\n\nSOCKET_CMD  ::= OPCODE { size: 4, value: 0 }\n               IDENTIFIER { size: 4 }\n               DOMAIN { size: 4 }\n               TYPE { size: 4 }\n               PROTOCOL { size: 4 }\n\nBIND_CMD    ::= OPCODE { size: 4, value: 1 } \n               IDENTIFIER { size: 4 }\n               ADDR_SIZE { size: 4 }\n               ADDR_DATA { size: ADDR_SIZE }\n\nLISTEN_CMD  ::= OPCODE { size: 4, value: 2 }\n                IDENTIFIER { size: 4 }\n                BACKLOG { size: 4 }\n\nGETPEERNAME_CMD ::= OPCODE { size: 4, value: 3 }\n                    IDENTIFIER { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte)][CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1, CMD2, CMD3 or CMD4 depending on the command type.\nCMD   ::= CMD1 \n        | CMD2 \n        | CMD3\n        | CMD4\n\n// For opcode value 0, the command is 'socket'.\nCMD1  ::= OPCODE { size: 4, value: 0 } \n          IDENTIFIER { size: 4 }\n          DOMAIN { size: 4 }\n          TYPE { size: 4 }\n          PROTOCOL { size: 4 }\n\n// For opcode value 1, the command is 'bind'.\nCMD2  ::= OPCODE { size: 4, value: 1 }\n          IDENTIFIER { size: 4 }\n          SIZE { size: 4 }\n          ADDR_DATA { size: SIZE }\n\n// For opcode value 2, the command is 'listen'.\nCMD3  ::= OPCODE { size: 4, value: 2 }\n          IDENTIFIER { size: 4 }\n          BACKLOG { size: 4 }\n\n// For opcode value 3, the command is 'getpeername'.\nCMD4  ::= OPCODE { size: 4, value: 3 }\n          IDENTIFIER { size: 4 }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD0\n        | CMD1\n        | CMD2\n        | CMD3\n\nCMD0  ::= OPCODE { size: 4, value: 0 }\n          IDENTIFIER { size: 4 }\n          DOMAIN { size: 4 }\n          TYPE { size: 4 }\n          PROTOCOL { size: 4 }\n\nCMD1  ::= OPCODE { size: 4, value: 1 }\n          IDENTIFIER { size: 4 }\n          SIZE { size: 4 }\n          ADDR_DATA { size: SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 2 }\n          IDENTIFIER { size: 4 }\n          BACKLOG { size: 4 }\n\nCMD3  ::= OPCODE { size: 4, value: 3 }\n          IDENTIFIER { size: 4 }"
        ]
      },
      "CADET-00001-2": {
        "total_runs": 10,
        "success_count": 7,
        "first_success": 0,
        "unique_count": 1,
        "popular_count": 6,
        "syntactically_correct": 7,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [DEVICE_NAME_SIZE][DEVICE_NAME][OPEN_FLAGS][DATA_SIZE][DATA]\nINPUT ::= DEVICE_NAME_SIZE { size: 4 }\n          DEVICE_NAME { size: DEVICE_NAME_SIZE }\n          OPEN_FLAGS { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }",
          "INPUT  ::= DEVICE_NAME_SIZE { size: 4 }\n           DEVICE_NAME { size: DEVICE_NAME_SIZE }\n           OPEN_FLAGS { size: 4 }\n           DATA_SIZE { size: 4 }\n           DATA { size: DATA_SIZE }",
          "INPUT ::= DEVICE_NAME_SIZE { size: 4 }\n          DEVICE_NAME { size: DEVICE_NAME_SIZE }\n          OPEN_FLAGS { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }",
          "INPUT ::= DEVICE_NAME_LEN { size: 4 }\n          DEVICE_NAME { size: DEVICE_NAME_LEN }\n          OPEN_FLAGS { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }",
          "// INPUT is the start of the input format.\nINPUT ::= DEVI_SIZE {size: 4}\n          DEVICE_NAME{size: DEVI_SIZE}\n          OPEN_FLAGS {size: 4}\n          DATA_SIZE {size: 4}\n          DATA {size: DATA_SIZE}\n          \n// DEVICE_NAME is the name of the device. Its size is specified before it.\nDEVICE_NAME ::= BYTE[DEVI_SIZE]\n\n// OPEN_FLAGS are the flags used for opening the device. It is a four-byte integer.\nOPEN_FLAGS ::= BYTE {size: 4}\n\n// DATA_SIZE specifies the size of the following data. It is a four-byte integer.\nDATA_SIZE ::= BYTE {size: 4}\n\n// DATA holds the data that will be passed to ioctl. Its size is specified before it.\nDATA ::= BYTE[DATA_SIZE]\n\n// BYTE is a single byte.\nBYTE ::= __any_byte__",
          "// INPUT is the start of the input format.\n// The input contains DEVICE_NAME_SIZE, DEVICE_NAME, OPEN_FLAGS, IOCTL_DATA_SIZE and IOCTL_DATA.\nINPUT ::= DEVICE_NAME_SIZE { size: 4 }\n          DEVICE_NAME { size: DEVICE_NAME_SIZE }\n          OPEN_FLAGS { size: 4 }\n          IOCTL_DATA_SIZE { size: 4 }\n          IOCTL_DATA { size: IOCTL_DATA_SIZE }",
          "INPUT ::= DEVICE_NAME_SIZE { size: 4 }\n          DEVICE_NAME[ DEVICE_NAME_SIZE ]\n          OPEN_FLAGS { size: 4 }\n          IOCTL_DATA_SIZE { size: 4 }\n          IOCTL_DATA[ IOCTL_DATA_SIZE ]\n\nDEVICE_NAME_SIZE ::= SIZE { size: 4 }\n\nDEVICE_NAME ::= CHAR { size: 1 } [ DEVICE_NAME_SIZE ]\n\nOPEN_FLAGS ::= FLAGS { SIZE: 4 }\n\nIOCTL_DATA_SIZE ::= SIZE { size: 4 } \n\nIOCTL_DATA ::= UINT8 { size: 1 } [ IOCTL_DATA_SIZE ]",
          "INPUT ::= DEVICE_NAME_LENGTH { size: 4 }\n          DEVICE_NAME { size: DEVICE_NAME_LENGTH }\n          OPEN_FLAGS { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }",
          "INPUT ::= DEVICE_NAME_SIZE { size: 4 }\n          DEVICE_NAME { size: DEVICE_NAME_SIZE }\n          OPEN_FLAGS { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }",
          "INPUT ::= DEVICE_NAME_SIZE { size: 4 }\n          DEVICE_NAME[DEVICE_NAME_SIZE]\n          OPEN_FLAGS { size: 4 }\n          CMD_DATA_SIZE { size: 4 }\n          CMD_DATA[CMD_DATA_SIZE]\n\nDEVICE_NAME_SIZE ::= uint32 // This is the size of the device name\nDEVICE_NAME ::= uint8[DEVICE_NAME_SIZE] // This is the name of the device to be open\nOPEN_FLAGS ::= Flags for opening the device\nCMD_DATA_SIZE ::= uint32 // This is the size of the data\nCMD_DATA ::= uint8[CMD_DATA_SIZE] // This is the data that will be used by ioctl_CADET_00001"
        ]
      },
      "CROMU-00003": {
        "total_runs": 10,
        "success_count": 0,
        "first_success": -1,
        "unique_count": 7,
        "popular_count": 1,
        "syntactically_correct": 8,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte)][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n        | COMMAND[COMMAND_COUNT]\n\n// COMMAND will be chosen among the following action commands.\nCOMMAND ::= YOLO_ADD \n          | YOLO_DEL \n          | YOLO_EDIT \n          | YOLO_SHOW \n          | YOLO_SHOW_Q \n          | YOLO_SHOW_D \n          | YOLO_SHOW_E \n          | YOLO_SHOW_N \n          | YOLO_SHOW_P \n          | YOLO_LIST \n          | YOLO_SORT \n          | YOLO_EXIT \n\nYOLO_ADD ::= OPCODE { size: 4, value: YOLO_ADD }\n             FIRST_NAME_SIZE { size: 4 }\n             FIRST_NAME { size: FIRST_NAME_SIZE }\n             LAST_NAME_SIZE { size: 4 }\n             LAST_NAME { size: LAST_NAME_SIZE }\n             PHONE_SIZE { size: 4 }\n             PHONE { size: PHONE_SIZE }\n             OFFICE { size: 2}\n             GENDER { size: 1}\n             HACKER_BOOL { size: 1}\n\nYOLO_DEL ::= OPCODE { size: 4, value: YOLO_DEL }\n             FIRST_NAME_SIZE { size: 4 }\n             FIRST_NAME { size: FIRST_NAME_SIZE }\n             LAST_NAME_SIZE { size: 4 }\n             LAST_NAME { size: LAST_NAME_SIZE }\n\nYOLO_EDIT ::= OPCODE { size: 4, value: YOLO_EDIT }\n              OLD_FIRST_NAME_SIZE { size: 4 }\n              OLD_FIRST_NAME { size: OLD_FIRST_NAME_SIZE }\n              OLD_LAST_NAME_SIZE { size: 4 }\n              OLD_LAST_NAME { size: OLD_LAST_NAME_SIZE }\n              FIRST_NAME_SIZE { size: 4 }\n              FIRST_NAME { size: FIRST_NAME_SIZE }\n              LAST_NAME_SIZE { size: 4 }\n              LAST_NAME { size: LAST_NAME_SIZE }\n              PHONE_SIZE { size: 4 }\n              PHONE { size: PHONE_SIZE }\n              OFFICE { size: 2}\n              GENDER { size: 1}\n              HACKER_BOOL { size: 1}\n\nYOLO_SHOW ::= OPCODE { size: 4, value: YOLO_SHOW }\n              FIRST_NAME_SIZE { size: 4 }\n              FIRST_NAME { size: FIRST_NAME_SIZE }\n              LAST_NAME_SIZE { size: 4 }\n              LAST_NAME { size: LAST_NAME_SIZE }\n\nYOLO_SHOW_Q ::= OPCODE { size: 4, value: YOLO_SHOW_Q }\n\nYOLO_SHOW_D ::= OPCODE { size: 4, value: YOLO_SHOW_D }\n\nYOLO_SHOW_E ::= OPCODE { size: 4, value: YOLO_SHOW_E }\n                FIRST_NAME_SIZE { size: 4 }\n                FIRST_NAME { size: FIRST_NAME_SIZE }\n                LAST_NAME_SIZE { size: 4 }\n                LAST_NAME { size: LAST_NAME_SIZE }\n                PHONE_SIZE { size: 4 }\n                PHONE { size: PHONE_SIZE }\n                OFFICE { size: 2}\n                GENDER { size: 1}\n                HACKER_BOOL { size: 1}\n\nYOLO_SHOW_N ::= OPCODE { size: 4, value: YOLO_SHOW_N }\n\nYOLO_SHOW_P ::= OPCODE { size: 4, value: YOLO_SHOW_P }\n\nYOLO_LIST ::= OPCODE { size: 4, value: YOLO_LIST }\n        \nYOLO_SORT ::= OPCODE { size: 4, value: YOLO_SORT } \n\nYOLO_EXIT ::= OPCODE { size: 4, value: YOLO_EXIT } \n",
          "INPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\nCMD   ::= YOLO_ADD_CMD\n        | YOLO_DEL_CMD\n        | YOLO_EDIT_CMD\n        | YOLO_SHOW_CMD \n        | YOLO_SHOW_Q_CMD { size: 0 } \n        | YOLO_SHOW_D_CMD { size: 0 } \n        | YOLO_SHOW_E_CMD \n        | YOLO_SHOW_N_CMD { size: 0 } \n        | YOLO_SHOW_P_CMD { size: 0 } \n        | YOLO_LIST_CMD { size: 0 } \n        | YOLO_SORT_CMD { size: 0 } \n        | YOLO_EXIT_CMD { size: 0 }\n\nYOLO_ADD_CMD ::= OPCODE { size: 2, value: YOLO_ADD }\n                 FIRST_NAME_SIZE { size: 4 }       \n                 FIRST_NAME { size: FIRST_NAME_SIZE }\n                 LAST_NAME_SIZE { size: 4 }\n                 LAST_NAME { size: LAST_NAME_SIZE }\n                 PHONE_SIZE { size: 4 }\n                 PHONE { size: PHONE_SIZE }\n                 OFFICE { size: 2 }\n                 GENDER { size: 1 }\n                 HACKER_BOOL { size: 1 }\n\nYOLO_DEL_CMD ::= OPCODE { size: 2, value: YOLO_DEL }\n                 FIRST_NAME_SIZE { size: 4 }       \n                 FIRST_NAME { size: FIRST_NAME_SIZE }\n                 LAST_NAME_SIZE { size: 4 }\n                 LAST_NAME { size: LAST_NAME_SIZE }\n\nYOLO_EDIT_CMD ::= OPCODE { size: 2, value: YOLO_EDIT }\n                  OLD_FIRST_NAME_SIZE { size: 4 }       \n                  OLD_FIRST_NAME { size: OLD_FIRST_NAME_SIZE }\n                  OLD_LAST_NAME_SIZE { size: 4 }\n                  OLD_LAST_NAME { size: OLD_LAST_NAME_SIZE }\n                  FIRST_NAME_SIZE { size: 4 }       \n                  FIRST_NAME { size: FIRST_NAME_SIZE }\n                  LAST_NAME_SIZE { size: 4 }\n                  LAST_NAME { size: LAST_NAME_SIZE }\n                  PHONE_SIZE { size: 4 }\n                  PHONE { size: PHONE_SIZE }\n                  OFFICE { size: 2 }\n                  GENDER { size: 1 }\n                  HACKER_BOOL { size: 1 }\n\nYOLO_SHOW_CMD ::= OPCODE { size: 2, value: YOLO_SHOW }\n                  FIRST_NAME_SIZE { size: 4 }       \n                  FIRST_NAME { size: FIRST_NAME_SIZE }\n                  LAST_NAME_SIZE { size: 4 }\n                  LAST_NAME { size: LAST_NAME_SIZE }\n\nYOLO_SHOW_E_CMD ::= OPCODE { size: 2, value: YOLO_SHOW_E }\n                    FIRST_NAME_SIZE { size: 4 }       \n                    FIRST_NAME { size: FIRST_NAME_SIZE }\n                    LAST_NAME_SIZE { size: 4 }\n                    LAST_NAME { size: LAST_NAME_SIZE }\n                    PHONE_SIZE { size: 4 }\n                    PHONE { size: PHONE_SIZE }\n                    OFFICE { size: 2 }\n                    GENDER { size: 1 }\n                    HACKER_BOOL { size: 1 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\n\nINPUT ::= CMD_CNT {size: 4}\n            CMD[CMD_CNT]\n\n//Based on the switch-case statement in the harness function, \n//CMD can be one of the twelve commands below.\nCMD   ::= YOLO_ADD\n        | YOLO_DEL\n        | YOLO_EDIT\n        | YOLO_SHOW\n        | YOLO_SHOW_Q\n        | YOLO_SHOW_D\n        | YOLO_SHOW_E\n        | YOLO_SHOW_N\n        | YOLO_SHOW_P\n        | YOLO_LIST\n        | YOLO_SORT\n        | YOLO_EXIT\n\nYOLO_ADD ::= OPCODE {size: 4, value: 0}  //OPCODE value from the switch-case statement in the function\n             FIRST_NAME_SIZE {size: 4}        \n             FIRST_NAME_DATA {size: FIRST_NAME_SIZE}\n             LAST_NAME_SIZE {size: 4}\n             LAST_NAME_DATA {size: LAST_NAME_SIZE}\n             PHONE_SIZE {size: 4}\n             PHONE_DATA {size: PHONE_SIZE}\n             OFFICE {size: 2}\n             GENDER {size: 1}\n             HACKER_BOOL {size: 1}\n\nYOLO_DEL ::= OPCODE {size: 4, value: 1} \n             FIRST_NAME_SIZE {size: 4}        \n             FIRST_NAME_DATA  {size: FIRST_NAME_SIZE}\n             LAST_NAME_SIZE {size: 4}       \n             LAST_NAME_DATA {size: LAST_NAME_SIZE}\n\nYOLO_EDIT ::= OPCODE {size: 4, value: 2}\n              OLD_FIRST_NAME_SIZE {size: 4}\n              OLD_FIRST_NAME_DATA {size: OLD_FIRST_NAME_SIZE}\n              OLD_LAST_NAME_SIZE {size: 4}\n              OLD_LAST_NAME_DATA {size:OLD_LAST_NAME_SIZE}\n              FIRST_NAME_SIZE {size: 4}        \n              FIRST_NAME_DATA {size: FIRST_NAME_SIZE}\n              LAST_NAME_SIZE {size: 4}\n              LAST_NAME_DATA {size: LAST_NAME_SIZE}\n              PHONE_SIZE {size: 4}\n              PHONE_DATA {size: PHONE_SIZE}\n              OFFICE {size: 2}\n              GENDER {size: 1}\n              HACKER_BOOL {size: 1}\n\nYOLO_SHOW ::= OPCODE {size: 4, value: 3} \n              FIRST_NAME_SIZE {size: 4}       \n              FIRST_NAME_DATA {size: FIRST_NAME_SIZE}\n              LAST_NAME_SIZE {size: 4}       \n              LAST_NAME_DATA {size: LAST_NAME_SIZE}\n\nYOLO_SHOW_Q ::= OPCODE {size: 4, value: 4}\n\nYOLO_SHOW_D ::= OPCODE {size: 4, value: 5}\n\nYOLO_SHOW_E ::= OPCODE {size: 4, value: 6} \n                FIRST_NAME_SIZE {size: 4}        \n                FIRST_NAME_DATA {size: FIRST_NAME_SIZE}\n                LAST_NAME_SIZE {size: 4}\n                LAST_NAME_DATA {size: LAST_NAME_SIZE}\n                PHONE_SIZE {size: 4}\n                PHONE_DATA {size: PHONE_SIZE}\n                OFFICE {size: 2}\n                GENDER {size: 1}\n                HACKER_BOOL {size: 1}\n\nYOLO_SHOW_N ::= OPCODE {size: 4, value: 7}\n\nYOLO_SHOW_P ::= OPCODE {size: 4, value: 8}\n\nYOLO_LIST ::= OPCODE {size: 4, value: 9}\n\nYOLO_SORT ::= OPCODE {size: 4, value: 10}\n\nYOLO_EXIT ::= OPCODE {size: 4, value: 11}",
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\nCOMMAND ::= COMMAND_YOLO_ADD\n          | COMMAND_YOLO_DEL\n          | COMMAND_YOLO_EDIT\n          | COMMAND_YOLO_SHOW\n          | COMMAND_YOLO_SHOW_Q\n          | COMMAND_YOLO_SHOW_D\n          | COMMAND_YOLO_SHOW_E\n          | COMMAND_YOLO_SHOW_N\n          | COMMAND_YOLO_SHOW_P\n          | COMMAND_YOLO_SORT\n          | COMMAND_YOLO_LIST\n          | COMMAND_YOLO_EXIT\n\nCOMMAND_YOLO_ADD ::= OPCODE { size: 4, value: YOLO_ADD }\n                     NAME_SIZE { size: 4 }\n                     NAME { size: NAME_SIZE }\n                     LASTNAME_SIZE { size: 4 }\n                     LASTNAME { size: LASTNAME_SIZE }\n                     PHONE_SIZE { size: 4 }\n                     PHONE { size: PHONE_SIZE }\n                     OFFICE_AND_STATUS { size: 4 }\n\n\nCOMMAND_YOLO_DEL ::= OPCODE { size: 4, value: YOLO_DEL }\n                     NAME_SIZE { size: 4 }\n                     NAME { size: NAME_SIZE }\n                     LASTNAME_SIZE { size: 4 }\n                     LASTNAME { size: LASTNAME_SIZE }\n\nCOMMAND_YOLO_EDIT ::= OPCODE { size: 4, value: YOLO_EDIT }\n                      OLD_NAME_SIZE { size: 4 }\n                      OLD_NAME { size: OLD_NAME_SIZE }\n                      OLD_LASTNAME_SIZE { size: 4 }\n                      OLD_LASTNAME { size: OLD_LASTNAME_SIZE }\n                      NAME_SIZE { size: 4 }\n                      NAME { size: NAME_SIZE }\n                      LASTNAME_SIZE { size: 4 }\n                      LASTNAME { size: LASTNAME_SIZE }\n                      PHONE_SIZE { size: 4 }\n                      PHONE { size: PHONE_SIZE }\n                      OFFICE_AND_STATUS { size: 4 }\n\nCOMMAND_YOLO_SHOW ::= OPCODE { size: 4, value: YOLO_SHOW }\n                      NAME_SIZE { size: 4 }\n                      NAME { size: NAME_SIZE }\n                      LASTNAME_SIZE { size: 4 }\n                      LASTNAME { size: LASTNAME_SIZE }\n\nCOMMAND_YOLO_SHOW_Q ::= OPCODE { size: 4, value: YOLO_SHOW_Q }\n\nCOMMAND_YOLO_SHOW_D ::= OPCODE { size: 4, value: YOLO_SHOW_D }\n\nCOMMAND_YOLO_SHOW_E ::= OPCODE { size: 4, value: YOLO_SHOW_E }\n                        NAME_SIZE { size: 4 }\n                        NAME { size: NAME_SIZE }\n                        LASTNAME_SIZE { size: 4 }\n                        LASTNAME { size: LASTNAME_SIZE }\n                        PHONE_SIZE { size: 4 }\n                        PHONE { size: PHONE_SIZE }\n                        OFFICE_AND_STATUS { size: 4 }\n\nCOMMAND_YOLO_SHOW_N ::= OPCODE { size: 4, value: YOLO_SHOW_N }\n\nCOMMAND_YOLO_SHOW_P ::= OPCODE { size: 4, value: YOLO_SHOW_P }\n\nCOMMAND_YOLO_LIST ::= OPCODE { size: 4, value: YOLO_LIST }\n\nCOMMAND_YOLO_SORT ::= OPCODE { size: 4, value: YOLO_SORT }\n\nCOMMAND_YOLO_EXIT ::= OPCODE { size: 4, value: YOLO_EXIT } ",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD_YOLO_ADD \n        | CMD_YOLO_DEL\n        | CMD_YOLO_EDIT\n        | CMD_YOLO_SHOW\n        | CMD_YOLO_SHOW_Q\n        | CMD_YOLO_SHOW_D\n        | CMD_YOLO_SHOW_E\n        | CMD_YOLO_SHOW_N\n        | CMD_YOLO_SHOW_P\n        | CMD_YOLO_LIST\n        | CMD_YOLO_SORT\n        | CMD_YOLO_EXIT\n\nCMD_YOLO_ADD  ::= OPCODE { size: 4, value: YOLO_ADD }\n                  FIRST_NAME_SIZE { size: 4 }\n                  FIRST_NAME { size: FIRST_NAME_SIZE }\n                  LAST_NAME_SIZE { size: 4 }\n                  LAST_NAME { size: LAST_NAME_SIZE }\n                  PHONE_SIZE { size: 4 }\n                  PHONE { size: PHONE_SIZE }\n                  OFFICE { size: 2 }\n                  GENDER { size: 1 }\n                  HACKER_BOOL { size: 1 }\n\nCMD_YOLO_DEL  ::= OPCODE { size: 4, value: YOLO_DEL }\n                  FIRST_NAME_SIZE { size: 4 }\n                  FIRST_NAME { size: FIRST_NAME_SIZE }\n                  LAST_NAME_SIZE { size: 4 }\n                  LAST_NAME { size: LAST_NAME_SIZE }\n\nCMD_YOLO_EDIT ::= OPCODE { size: 4, value: YOLO_EDIT }\n                  OLD_FIRST_NAME_SIZE { size: 4 }\n                  OLD_FIRST_NAME { size: OLD_FIRST_NAME_SIZE }\n                  OLD_LAST_NAME_SIZE { size: 4 }\n                  OLD_LAST_NAME { size: OLD_LAST_NAME_SIZE }\n                  FIRST_NAME_SIZE { size: 4 }\n                  FIRST_NAME { size: FIRST_NAME_SIZE }\n                  LAST_NAME_SIZE { size: 4 }\n                  LAST_NAME { size: LAST_NAME_SIZE }\n                  PHONE_SIZE { size: 4 }\n                  PHONE { size: PHONE_SIZE }\n                  OFFICE { size: 2 }\n                  GENDER { size: 1 }\n                  HACKER_BOOL { size: 1 }\n\nCMD_YOLO_SHOW ::= OPCODE { size: 4, value: YOLO_SHOW }\n                  FIRST_NAME_SIZE { size: 4 }\n                  FIRST_NAME { size: FIRST_NAME_SIZE }\n                  LAST_NAME_SIZE { size: 4 }\n                  LAST_NAME { size: LAST_NAME_SIZE }\n\nCMD_YOLO_SHOW_Q ::= OPCODE { size: 4, value: YOLO_SHOW_Q }\n\nCMD_YOLO_SHOW_D ::= OPCODE { size: 4, value: YOLO_SHOW_D }\n\nCMD_YOLO_SHOW_E ::= OPCODE { size: 4, value: YOLO_SHOW_E }\n                    FIRST_NAME_SIZE { size: 4 }\n                    FIRST_NAME { size: FIRST_NAME_SIZE }\n                    LAST_NAME_SIZE { size: 4 }\n                    LAST_NAME { size: LAST_NAME_SIZE }\n                    PHONE_SIZE { size: 4 }\n                    PHONE { size: PHONE_SIZE }\n                    OFFICE { size: 2 }\n                    GENDER { size: 1 }\n                    HACKER_BOOL { size: 1 }\n\nCMD_YOLO_SHOW_N ::= OPCODE { size: 4, value: YOLO_SHOW_N }\n\nCMD_YOLO_SHOW_P ::= OPCODE { size: 4, value: YOLO_SHOW_P }\n\nCMD_YOLO_LIST ::= OPCODE { size: 4, value: YOLO_LIST }\n\nCMD_YOLO_SORT ::= OPCODE { size: 4, value: YOLO_SORT }\n                  \nCMD_YOLO_EXIT ::= OPCODE { size: 4, value: YOLO_EXIT }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= YOLO_ADD \n        | YOLO_DEL\n        | YOLO_EDIT\n        | YOLO_SHOW\n        | YOLO_SHOW_Q\n        | YOLO_SHOW_D\n        | YOLO_SHOW_E\n        | YOLO_SHOW_N\n        | YOLO_SHOW_P\n        | YOLO_LIST\n        | YOLO_SORT\n        | YOLO_EXIT\n\nYOLO_ADD ::= OPCODE { size: 4, value: YOLO_ADD_CONV }\n             NAMESIZE { size: 4 } \n             NAME[NAMESIZE]\n             LNSIZE { size: 4 } \n             LN[LNSIZE]\n             PHONESIZE { size: 4 }\n             PHONE[PHONESIZE]\n             OFFICE { size: 2 }\n             GENDER { size: 1 }\n             HACKER { size: 1 }\n\nYOLO_DEL ::= OPCODE { size: 4, value: YOLO_DEL_CONV }\n             NAMESIZE { size: 4 } \n             NAME[NAMESIZE]\n             LNSIZE { size: 4 } \n             LN[LNSIZE]\n\nYOLO_EDIT ::= OPCODE { size: 4, value: YOLO_EDIT_CONV }\n              OLDNAMESIZE { size: 4 } \n              OLDNAME[OLDNAMESIZE]\n              OLDLNSIZE { size: 4 } \n              OLDLN[OLDLNSIZE]\n              NAMESIZE { size: 4 } \n              NAME[NAMESIZE]\n              LNSIZE { size: 4 } \n              LN[LNSIZE]\n              PHONESIZE { size: 4 }\n              PHONE[PHONESIZE]\n              OFFICE { size: 2 }\n              GENDER { size: 1 }\n              HACKER { size: 1 }\n\nYOLO_SHOW ::= OPCODE { size: 4, value: YOLO_SHOW_CONV }\n              NAMESIZE { size: 4 } \n              NAME[NAMESIZE]\n              LNSIZE { size: 4 } \n              LN[LNSIZE]\n\nYOLO_SHOW_Q ::= OPCODE { size: 4, value: YOLO_SHOW_Q_CONV }\n\nYOLO_SHOW_D ::= OPCODE { size: 4, value: YOLO_SHOW_D_CONV }\n\nYOLO_SHOW_E ::= OPCODE { size: 4, value: YOLO_SHOW_E_CONV }\n                NAMESIZE { size: 4 } \n                NAME[NAMESIZE]\n                LNSIZE { size: 4 } \n                LN[LNSIZE]\n                PHONESIZE { size: 4 }\n                PHONE[PHONESIZE]\n                OFFICE { size: 2 }\n                GENDER { size: 1 }\n                HACKER { size: 1 }\n\nYOLO_SHOW_N ::= OPCODE { size: 4, value: YOLO_SHOW_N_CONV }\n\nYOLO_SHOW_P ::= OPCODE { size: 4, value: YOLO_SHOW_P_CONV }\n\nYOLO_LIST ::= OPCODE { size: 4, value: YOLO_LIST_CONV }\n\nYOLO_SORT ::= OPCODE { size: 4, value: YOLO_SORT_CONV }\n\nYOLO_EXIT ::= OPCODE { size: 4, value: YOLO_EXIT_CONV }\n\n\nWhere YOLO_ADD_CONV, YOLO_DEL_CONV, YOLO_EDIT_CONV, YOLO_SHOW_CONV, YOLO_SHOW_Q_CONV, YOLO_SHOW_D_CONV, YOLO_SHOW_E_CONV, YOLO_SHOW_N_CONV, YOLO_SHOW_P_CONV, YOLO_LIST_CONV, YOLO_SORT_CONV, YOLO_EXIT_CONV are given integer values for commands YOLO_ADD, YOLO_DEL, YOLO_EDIT, YOLO_SHOW, YOLO_SHOW_Q, YOLO_SHOW_D, YOLO_SHOW_E, YOLO_SHOW_N, YOLO_SHOW_P, YOLO_LIST, YOLO_SORT, YOLO_EXIT respectively.",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 } \n          CMD[CMD_CNT]\n\n// CMD will be one of the twelve commands: YOLO_ADD, YOLO_DEL, YOLO_EDIT, YOLO_SHOW, YOLO_SHOW_Q, YOLO_SHOW_D, YOLO_SHOW_E, YOLO_SHOW_N, YOLO_SHOW_P, YOLO_LIST, YOLO_SORT, YOLO_EXIT.\nCMD   ::= YOLO_ADD \n        | YOLO_DEL\n        | YOLO_EDIT\n        | YOLO_SHOW\n        | YOLO_SHOW_Q\n        | YOLO_SHOW_D\n        | YOLO_SHOW_E\n        | YOLO_SHOW_N\n        | YOLO_SHOW_P\n        | YOLO_LIST\n        | YOLO_SORT\n        | YOLO_EXIT\n\nYOLO_ADD ::= OPCODE { size: 4, value: 'The value representing YOLO_ADD opcode' }\n            FIRST_NAME_SIZE { size: 4 }       \n            FIRST_NAME { size: FIRST_NAME_SIZE }\n            LAST_NAME_SIZE { size: 4 }\n            LAST_NAME { size: LAST_NAME_SIZE }\n            PHONE_SIZE { size: 4 }\n            PHONE { size: PHONE_SIZE }\n            OFFICE { size: 2 }\n            GENDER { size: 1 }\n            HACKER_BOOL { size: 1 }\n\nYOLO_DEL ::= OPCODE { size: 4, value: 'The value representing YOLO_DEL opcode' }\n            FIRST_NAME_SIZE { size: 4 }       \n            FIRST_NAME { size: FIRST_NAME_SIZE }\n            LAST_NAME_SIZE { size: 4 }\n            LAST_NAME { size: LAST_NAME_SIZE }\n\nYOLO_EDIT ::= OPCODE { size: 4, value: 'The value representing YOLO_EDIT opcode' }\n              OLD_FIRST_NAME_SIZE { size: 4 }\n              OLD_FIRST_NAME { size: OLD_FIRST_NAME_SIZE }\n              OLD_LAST_NAME_SIZE { size: 4 }\n              OLD_LAST_NAME { size: OLD_LAST_NAME_SIZE }\n              FIRST_NAME_SIZE { size: 4 }       \n              FIRST_NAME { size: FIRST_NAME_SIZE }\n              LAST_NAME_SIZE { size: 4 }\n              LAST_NAME { size: LAST_NAME_SIZE }\n              PHONE_SIZE { size: 4 }\n              PHONE { size: PHONE_SIZE }\n              OFFICE { size: 2 }\n              GENDER { size: 1 }\n              HACKER_BOOL { size: 1 }\n              \nYOLO_SHOW     ::= OPCODE { size: 4, value: 'The value representing YOLO_SHOW opcode' }\n                FIRST_NAME_SIZE { size: 4 }       \n                FIRST_NAME { size: FIRST_NAME_SIZE }\n                LAST_NAME_SIZE { size: 4 }\n                LAST_NAME { size: LAST_NAME_SIZE }\n\nYOLO_SHOW_Q   ::= OPCODE { size: 4, value: 'The value representing YOLO_SHOW_Q opcode' }\n\nYOLO_SHOW_D   ::= OPCODE { size: 4, value: 'The value representing YOLO_SHOW_D opcode' }\n\nYOLO_SHOW_E   ::= OPCODE { size: 4, value: 'The value representing YOLO_SHOW_E opcode' }\n                FIRST_NAME_SIZE { size: 4 }       \n                FIRST_NAME { size: FIRST_NAME_SIZE }\n                LAST_NAME_SIZE { size: 4 }\n                LAST_NAME { size: LAST_NAME_SIZE }\n                PHONE_SIZE { size: 4 }\n                PHONE { size: PHONE_SIZE }\n                OFFICE { size: 2 }\n                GENDER { size: 1 }\n                HACKER_BOOL { size: 1 }\n                \nYOLO_SHOW_N   ::= OPCODE { size: 4, value: 'The value representing YOLO_SHOW_N opcode' }\n\nYOLO_SHOW_P   ::= OPCODE { size: 4, value: 'The value representing YOLO_SHOW_P opcode' }\n\nYOLO_LIST     ::= OPCODE { size: 4, value: 'The value representing YOLO_LIST opcode' }\n\nYOLO_SORT     ::= OPCODE { size: 4, value: 'The value representing YOLO_SORT opcode' }\n\nYOLO_EXIT     ::= OPCODE { size: 4, value: 'The value representing YOLO_EXIT opcode' }",
          "INPUT ::= COMMAND_COUNT { size: 4 } \n           COMMAND[COMMAND_COUNT]\n\nCOMMAND ::= YOLO_ADD\n          | YOLO_DEL\n          | YOLO_EDIT\n          | YOLO_SHOW\n          | YOLO_SHOW_Q { size: 0 }\n          | YOLO_SHOW_D { size: 0 }\n          | YOLO_SHOW_E\n          | YOLO_SHOW_N { size: 0 }\n          | YOLO_SHOW_P { size: 0 }\n          | YOLO_LIST { size: 0 }\n          | YOLO_SORT { size: 0 }\n          | YOLO_EXIT { size: 0 }\n\nYOLO_ADD ::= OPCODE { size: 4, value: YOLO_ADD }\n             NAME_SIZE { size: 4 }\n             FIRST_NAME { size: NAME_SIZE }\n             NAME_SIZE { size: 4 }\n             LAST_NAME { size: NAME_SIZE }\n             PHONE_SIZE { size: 4 }\n             PHONE_NUMBER { size: PHONE_SIZE }\n             OFFICE_GENDER_HACKER { size: 4 }\n\nYOLO_DEL ::= OPCODE { size: 4, value: YOLO_DEL }\n             NAME_SIZE { size: 4 }\n             FIRST_NAME { size: NAME_SIZE }\n             NAME_SIZE { size: 4 }\n             LAST_NAME { size: NAME_SIZE }\n\nYOLO_EDIT ::= OPCODE { size: 4, value: YOLO_EDIT }\n              NAME_SIZE { size: 4 }\n              OLD_FIRST_NAME { size: NAME_SIZE }\n              NAME_SIZE { size: 4 }\n              OLD_LAST_NAME { size: NAME_SIZE }\n              NAME_SIZE { size: 4 }\n              FIRST_NAME { size: NAME_SIZE }\n              NAME_SIZE { size: 4 }\n              LAST_NAME { size: NAME_SIZE }\n              PHONE_SIZE { size: 4 }\n              PHONE_NUMBER { size: PHONE_SIZE }\n              OFFICE_GENDER_HACKER { size: 4 }\n\nYOLO_SHOW ::= OPCODE { size: 4, value: YOLO_SHOW }\n              NAME_SIZE { size: 4 }\n              FIRST_NAME { size: NAME_SIZE }\n              NAME_SIZE { size: 4 }\n              LAST_NAME { size: NAME_SIZE }\n\nYOLO_SHOW_E ::= OPCODE { size: 4, value: YOLO_SHOW_E }\n                NAME_SIZE { size: 4 }\n                FIRST_NAME { size: NAME_SIZE }\n                NAME_SIZE { size: 4 }\n                LAST_NAME { size: NAME_SIZE }\n                PHONE_SIZE { size: 4 }\n                PHONE_NUMBER { size: PHONE_SIZE }\n                OFFICE_GENDER_HACKER { size: 4 }",
          "INPUT ::= COMMAND_COUNT { size: 4 } COMMAND[COMMAND_COUNT]\n\nCOMMAND ::= ADD_COMMAND \n          | DEL_COMMAND \n          | EDIT_COMMAND\n          | SHOW_COMMAND\n          | SHOW_Q_COMMAND { opcode: YOLO_SHOW_Q }\n          | SHOW_D_COMMAND { opcode: YOLO_SHOW_D }\n          | SHOW_E_COMMAND\n          | SHOW_N_COMMAND { opcode: YOLO_SHOW_N }\n          | SHOW_P_COMMAND { opcode: YOLO_SHOW_P }\n          | LIST_COMMAND { opcode: YOLO_LIST }\n          | SORT_COMMAND { opcode: YOLO_SORT }\n          | EXIT_COMMAND { opcode: YOLO_EXIT }\n\nADD_COMMAND ::= { opcode: YOLO_ADD }\n                FIRST_NAME \n                LAST_NAME\n                PHONE_NUMBER\n                OFFICE { size: 2 } \n                GENDER { size: 1 }\n                HACKER_BOOL { size: 1 }\n\nDEL_COMMAND ::= { opcode: YOLO_DEL }\n                FIRST_NAME\n                LAST_NAME\n\nEDIT_COMMAND ::= { opcode: YOLO_EDIT }\n                 OLD_FIRST_NAME \n                 OLD_LAST_NAME\n                 FIRST_NAME\n                 LAST_NAME\n                 PHONE_NUMBER\n                 OFFICE { size: 2 }\n                 GENDER { size: 1 }\n                 HACKER_BOOL { size: 1 }\n\nSHOW_COMMAND ::= { opcode: YOLO_SHOW }\n                 FIRST_NAME\n                 LAST_NAME\n\nSHOW_E_COMMAND ::= { opcode: YOLO_SHOW_E }\n                   FIRST_NAME \n                   LAST_NAME\n                   PHONE_NUMBER\n                   OFFICE { size: 2 }\n                   GENDER { size: 1 }\n                   HACKER_BOOL { size: 1 }\n\nFIRST_NAME ::= SIZE { size: 4 }\n               NAME { size: SIZE }\n\nLAST_NAME ::= SIZE { size: 4 }\n              NAME { size: SIZE }\n\nOLD_FIRST_NAME ::= SIZE { size: 4 }\n                   NAME { size: SIZE }\n\nOLD_LAST_NAME ::= SIZE { size: 4 }\n                  NAME { size: SIZE }\n\nPHONE_NUMBER ::= SIZE { size: 4 }\n                 NUMBER { size: SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// Command definitions can occur in the variety of forms mentioned below\nCMD   ::= CMD_ADD\n        | CMD_DEL\n        | CMD_EDIT\n        | CMD_SHOW\n        | CMD_SHOW_Q\n        | CMD_SHOW_D\n        | CMD_SHOW_E\n        | CMD_SHOW_N\n        | CMD_SHOW_P\n        | CMD_LIST\n        | CMD_SORT\n        | CMD_EXIT\n\nCMD_ADD ::= OPCODE { size: 4, value: 0 } // Assumed OPCODE values, should be replaced with the actuals\n           FIRST_NAME_SIZE { size: 4 }\n           FIRST_NAME { size: FIRST_NAME_SIZE }\n           LAST_NAME_SIZE { size: 4 }\n           LAST_NAME { size: LAST_NAME_SIZE }\n           PHONE_SIZE { size: 4 }\n           PHONE { size: PHONE_SIZE }\n           OFFICE { size: 2 }\n           GENDER { size: 1 }\n           HACKER_BOOL { size: 1 }\n\nCMD_DEL ::= OPCODE { size: 4, value: 1}\n           FIRST_NAME_SIZE { size: 4 }\n           FIRST_NAME { size: FIRST_NAME_SIZE }\n           LAST_NAME_SIZE { size: 4 }\n           LAST_NAME { size: LAST_NAME_SIZE }\n\nCMD_EDIT ::= OPCODE { size: 4, value: 2}\n             OLD_FIRST_NAME_SIZE { size: 4 }\n             OLD_FIRST_NAME { size: OLD_FIRST_NAME_SIZE }\n             OLD_LAST_NAME_SIZE { size: 4 }\n             OLD_LAST_NAME { size: OLD_LAST_NAME_SIZE }\n             // The rest is same as CMD_ADD\n             FIRST_NAME_SIZE { size: 4 }\n             FIRST_NAME { size: FIRST_NAME_SIZE }\n             LAST_NAME_SIZE { size: 4 }\n             LAST_NAME { size: LAST_NAME_SIZE }\n             PHONE_SIZE { size: 4 }\n             PHONE { size: PHONE_SIZE }\n             OFFICE { size: 2 }\n             GENDER { size: 1 }\n             HACKER_BOOL { size: 1 }\n\nCMD_SHOW ::= OPCODE { size: 4, value: 3}\n             FIRST_NAME_SIZE { size: 4 }\n             FIRST_NAME { size: FIRST_NAME_SIZE }\n             LAST_NAME_SIZE { size: 4 }\n             LAST_NAME { size: LAST_NAME_SIZE }\n\nCMD_SHOW_Q ::= OPCODE { size: 4, value: 4 }\n\nCMD_SHOW_D ::= OPCODE { size: 4, value: 5 }\n\nCMD_SHOW_E ::= OPCODE { size: 4, value: 6}\n               // Same as CMD_ADD\n               FIRST_NAME_SIZE { size: 4 }\n               FIRST_NAME { size: FIRST_NAME_SIZE }\n               LAST_NAME_SIZE { size: 4 }\n               LAST_NAME { size: LAST_NAME_SIZE }\n               PHONE_SIZE { size: 4 }\n               PHONE { size: PHONE_SIZE }\n               OFFICE { size: 2 }\n               GENDER { size: 1 }\n               HACKER_BOOL { size: 1 }\n\nCMD_SHOW_N ::= OPCODE { size: 4, value: 7 }\n\nCMD_SHOW_P ::= OPCODE { size: 4, value: 8 }\n\nCMD_LIST ::= OPCODE { size: 4, value: 9 }\n\nCMD_SORT ::= OPCODE { size: 4, value: 10 }\n\nCMD_EXIT ::= OPCODE { size: 4, value: 11 }"
        ]
      },
      "NRFIN-00001": {
        "total_runs": 10,
        "success_count": 0,
        "first_success": -1,
        "unique_count": 8,
        "popular_count": 1,
        "syntactically_correct": 9,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will include [COMMAND_COUNT (4byte)][COMMAND_COUNT * CMDS]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          CMD[COMMAND_COUNT]\n\n// CMD will either be CMD1, CMD2 or CMD3, if the target program has three commands.\nCMD   ::= CMD1 \n        | CMD2\n        | CMD3 \n\nCMD1  ::= OPCODE { size: 4, value: 0xdeadbeef + 1 }  // LIST opcode value comes from the first if statement\n        | OPCODE { size: 4, value: 0xdeadbeef + 3 }  // COUNT opcode value comes from switch-case if statement\n        | OPCODE { size: 4, value: 0xdeadbeef + 5 }  // HELP opcode value comes from switch-case if statement\n        | OPCODE { size: 4, value: 0xdeadbeef + 6 }  // QUIT opcode value comes from switch-case if statement\n\nCMD2  ::= OPCODE { size: 4, value: 0xdeadbeef + 2 } // ADD opcode value comes from switch-case if statement\n          BUF_LEN { size: 4}\n          BUF { size: BUF_LEN } \n\nCMD3  ::= OPCODE { size: 4, value: 0xdeadbeef + 4 } // SHOW opcode value comes from switch-case if statement\n          BUF_LEN { size: 4}\n          BUF { size: BUF_LEN }",
          "INPUT ::= CMD_COUNT { size: 4 }                       \n          | CMD[CMD_COUNT] \n\nCMD   ::= CMD1 \n        | CMD2 \n        | CMD3 \n        | CMD4 \n        | CMD5 \n        | CMD6 \n\nCMD1  ::= COMMAND_IDENTIFIER { size: 4, value: 0xdeadbeef + 1 } //{IOCTL_ONE}\n\nCMD2  ::= COMMAND_IDENTIFIER { size: 4, value: 0xdeadbeef + 2 } //{IOCTL_TWO}\n          | BUFFER_LENGTH { size: 4 }                                    \n          | BUFFER_DATA { size: BUFFER_LENGTH }\n\nCMD3  ::= COMMAND_IDENTIFIER { size: 4, value: 0xdeadbeef + 3 } //{IOCTL_THREE}\n\nCMD4  ::= COMMAND_IDENTIFIER { size: 4, value: 0xdeadbeef + 4 } //{IOCTL_FOUR}\n          | BUFFER_LENGTH { size: 4 }                               \n          | BUFFER_DATA { size: BUFFER_LENGTH }\n\nCMD5  ::= COMMAND_IDENTIFIER { size: 4, value: 0xdeadbeef + 5 } //{IOCTL_FIVE}\n\nCMD6  ::= COMMAND_IDENTIFIER { size: 4, value: 0xdeadbeef + 6 } //{IOCTL_SIX}",
          "INPUT  ::= CMD_COUNT { size: 4 }\n           CMD[CMD_COUNT]\n\nCMD    ::= CMD1\n         | CMD2\n         | CMD3\n         | CMD4\n         | CMD5\n         | CMD6\n\nCMD1   ::= OPCODE { size: 4, value: 0xdeadbeef + 1 }\n\nCMD2   ::= OPCODE { size: 4, value: 0xdeadbeef + 2 }\n           BUF_LEN { size: 4 }\n           BUF { size: BUF_LEN }\n\nCMD3   ::= OPCODE { size: 4, value: 0xdeadbeef + 3 }\n\nCMD4   ::= OPCODE { size: 4, value: 0xdeadbeef + 4 }\n           BUF_LEN { size: 4 }\n           BUF { size: BUF_LEN }\n\nCMD5   ::= OPCODE { size: 4, value: 0xdeadbeef + 5 }\n\nCMD6   ::= OPCODE { size: 4, value: 0xdeadbeef + 6 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD could be any one of the six commands.\nCMD   ::= CMD1 \n        | CMD2\n        | CMD3\n        | CMD4\n        | CMD5\n        | CMD6\n\nCMD1  ::= OPCODE { size: 4, value: 0xdeadbeef } // this is IOCTL_ONE\n\nCMD2  ::= OPCODE { size: 4, value: 0xdeadbef0 } // this is IOCTL_TWO\n          BUF_SIZE { size: 4 }\n          BUF { size: BUF_SIZE }\n\nCMD3  ::= OPCODE { size: 4, value: 0xdeadbef1 } // this is IOCTL_THREE\n\nCMD4  ::= OPCODE { size: 4, value: 0xdeadbef2 } // this is IOCTL_FOUR\n          BUF_SIZE { size: 4 }\n          BUF { size: BUF_SIZE }\n\nCMD5  ::= OPCODE { size: 4, value: 0xdeadbef3 } // this is IOCTL_FIVE\n\nCMD6  ::= OPCODE { size: 4, value: 0xdeadbef4 } // this is IOCTL_SIX",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD{CMD_CNT}\n\nCMD   ::= CMD_LIST \n        | CMD_ADD\n        | CMD_COUNT \n        | CMD_SHOW \n        | CMD_HELP\n        | CMD_QUIT        \n\nCMD_LIST  ::= OPC_LIST { size: 4, value: 3735928550 } \n\nCMD_ADD   ::= OPC_ADD { size: 4, value: 3735928551 } \n              BUF_LEN { size: 4 }\n              BUF_VAL { size: BUF_LEN }\n\nCMD_COUNT ::= OPC_COUNT { size: 4, value: 3735928552 } \n\nCMD_SHOW  ::= OPC_SHOW { size: 4, value: 3735928553 }  \n              BUF_LEN { size: 4 }   \n              BUF_VAL { size: BUF_LEN }\n\nCMD_HELP  ::= OPC_HELP { size: 4, value: 3735928554 } \n\nCMD_QUIT  ::= OPC_QUIT { size: 4, value: 3735928555 } ",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2\n        | CMD3\n        | CMD4 \n        | CMD5\n        | CMD6\n\nCMD1  ::= OPCODE { size: 4, value: 3735928550 } // Recall that IOCTL_ONE is defined as IOCTL_BASE + 1, which is 0xdeadbeef + 1 = 3735928550\n\nCMD2  ::= OPCODE { size: 4, value: 3735928551 } // Recall that IOCTL_TWO is defined as IOCTL_BASE + 2, which is 0xdeadbeef + 2 = 3735928551\n          BUFFER_SIZE { size: 4 }\n          BUFFER { size: BUFFER_SIZE }\n\nCMD3  ::= OPCODE { size: 4, value: 3735928552 } // Recall that IOCTL_THREE is defined as IOCTL_BASE + 3, which is 0xdeadbeef + 3 = 3735928552\n\nCMD4  ::= OPCODE { size: 4, value: 3735928553 } // Recall that IOCTL_FOUR is defined as IOCTL_BASE + 4, which is 0xdeadbeef + 4 = 3735928553\n          BUFFER_SIZE { size: 4 }\n          BUFFER { size: BUFFER_SIZE }\n\nCMD5  ::= OPCODE { size: 4, value: 3735928554 } // Recall that IOCTL_FIVE is defined as IOCTL_BASE + 5, which is 0xdeadbeef + 5 = 3735928554\n\nCMD6  ::= OPCODE { size: 4, value: 3735928555 } // Recall that IOCTL_SIX is defined as IOCTL_BASE + 6, which is 0xdeadbeef + 6 = 3735928555\n",
          "// INPUT is the start of the input format.\n// The input start with a command count of 4 bytes.\n// Then, it is followed by the command count chunks of CMD.\nINPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\n// CMD will be one of the six commands: do_list, do_add, do_count, do_show, do_help, do_quit.\nCMD   ::= CMD1\n        | CMD2\n        | CMD3 \n        | CMD4\n        | CMD5\n        | CMD6\n\n// do_list command, OPCODE value retrieved from IOCTL_ONE = 0xdeadbeef + 1.\nCMD1  ::= OPCODE { size: 4, value: 0xdeadbef0}\n  \n// do_add command, OPCODE value retrieved from IOCTL_TWO = 0xdeadbeef + 2.\nCMD2  ::= OPCODE { size: 4, value: 0xdeadbef1 }\n          CMD_BUF_LEN { size: 4 }\n          CMD_BUF { size: CMD_BUF_LEN }\n\n// do_count command, OPCODE value retrieved from IOCTL_THREE = 0xdeadbeef + 3.\nCMD3  ::= OPCODE { size: 4, value: 0xdeadbef2 }\n\n// do_show command, OPCODE value retrieved from IOCTL_FOUR = 0xdeadbeef + 4.\nCMD4  ::= OPCODE { size: 4, value: 0xdeadbef3 }\n          CMD_BUF_LEN { size: 4 }\n          CMD_BUF { size: CMD_BUF_LEN }\n\n// do_help command, OPCODE value retrieved from IOCTL_FIVE = 0xdeadbeef + 5.\nCMD5  ::= OPCODE { size: 4, value: 0xdeadbef4 }\n\n// do_quit command, OPCODE value retrieved from IOCTL_SIX = 0xdeadbeef + 6.\nCMD6  ::= OPCODE { size: 4, value: 0xdeadbef5 }",
          "INPUT ::= SIZE { size: 4 }\n          COMMAND[SIZE]\n\nCOMMAND ::= COMMAND1\n          | COMMAND2\n          | COMMAND3\n          | COMMAND4\n          | COMMAND5\n\nCOMMAND1 ::= OP { size: 4, value: 3735928553}\n\nCOMMAND2 ::= OP { size: 4, value: 3735928554}\n             BUF_LEN { size: 4 }\n             BUF { size: BUF_LEN }\n\nCOMMAND3 ::= OP { size: 4, value: 3735928555 }\n\nCOMMAND4 ::= OP { size: 4, value: 3735928556 }\n             BUF_LEN { size: 4 }\n             BUF { size: BUF_LEN }\n\nCOMMAND5 ::= OP { size: 4, value: 3735928557 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1, CMD2, CMD4, CMD3, CMD5 or CMD6\nCMD   ::= CMD1 \n        | CMD2 \n        | CMD3\n        | CMD4 \n        | CMD5\n        | CMD6 \n\nCMD1  ::= OPCODE { size: 4, value: 0xdeadbf00 } // OPCODE value 0xdeadbf00 represents list command\n\nCMD2  ::= OPCODE { size: 4, value: 0xdeadbf01 } // OPCODE value 0xdeadbf01 represents add command\n          BUF_LEN { size: 4 }\n          BUF { size: BUF_LEN }\n\nCMD3  ::= OPCODE { size: 4, value: 0xdeadbf02 } // OPCODE value 0xdeadbf02 represents count command\n\nCMD4  ::= OPCODE { size: 4, value: 0xdeadbf03 } // OPCODE value 0xdeadbf03 represents show command\n          BUF_LEN { size: 4 }\n          BUF { size: BUF_LEN }\n\nCMD5  ::= OPCODE { size: 4, value: 0xdeadbf04 } // OPCODE value 0xdeadbf04 represents help command\n\nCMD6  ::= OPCODE { size: 4, value: 0xdeadbf05 } // OPCODE value 0xdeadbf05 represents quit command",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2\n        | CMD3\n        | CMD4\n        | CMD5\n        | CMD6\n\nCMD1  ::= OPCODE { size: 4, value: 3735928550 } \n\nCMD2  ::= OPCODE { size: 4, value: 3735928551 }\n          BUF_LEN { size: 4 }\n          BUF { size: BUF_LEN }\n          \nCMD3  ::= OPCODE { size: 4, value: 3735928552 }\n\nCMD4  ::= OPCODE { size: 4, value: 3735928553 }\n          BUF_LEN { size: 4 }\n          BUF { size: BUF_LEN }\n\nCMD5  ::= OPCODE { size: 4, value: 3735928554 }\n\nCMD6  ::= OPCODE { size: 4, value: 3735928555 }"
        ]
      },
      "CVE-2022-0995-2": {
        "total_runs": 10,
        "success_count": 8,
        "first_success": 0,
        "unique_count": 1,
        "popular_count": 7,
        "syntactically_correct": 8,
        "generated": [
          "INPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }",
          "// INPUT is the start of the input format.\nINPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }\n\n// PIPE_FLAGS is the flags for the pipe2 system call.\nPIPE_FLAGS ::= <integer>\n\n// NR_FILTERS is the number of filters which has a fixed value in the program.\nNR_FILTERS ::= <integer>\n\n// RESERVED must be 0 according to the watch_notification_filter struct.\nRESERVED ::= <integer>\n\n// TYPE is a parameter for the watch_notification_type_filter in the ioctl system call.\nTYPE ::= <integer>",
          "INPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [PIPE_FLAGS (4byte)][NR_FILTERS (4byte)][RESERVED (4byte)][TYPE (4byte)]\nINPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }\n",
          "// INPUT is the start of the input format.\n// INPUT will be [PIPE_FLAG (4byte) ][ NR_FILTERS (4byte) ][ RESERVED (4byte) ][ TYPE (4byte) ]\nINPUT ::= PIPE_FLAG { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }",
          "INPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESRVD { size: 4 }\n          TYPE { size: 4 }",
          "INPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }",
          "INPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }",
          "// INPUT is the start of the input format.\nINPUT ::= PIPE_FLAGS { size: 4 } \n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4}\n          TYPE { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [PIPE_FLAGS { size: 4 }][NR_FILTERS { size: 4 }][RESERVED { size: 4 }][TYPE { size: 4 }]\nINPUT ::= PIPE_FLAGS { size: 4 }\n          NR_FILTERS { size: 4 }\n          RESERVED { size: 4 }\n          TYPE { size: 4 }\n\nPIPE_FLAGS ::= INT32\nNR_FILTERS ::= INT32\nRESERVED ::= INT32\nTYPE ::= INT32"
        ]
      },
      "CVE-2022-32250": {
        "total_runs": 10,
        "success_count": 9,
        "first_success": 1,
        "unique_count": 1,
        "popular_count": 8,
        "syntactically_correct": 9,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 or CMD2 since the target program has two commands.\nCMD   ::= CMD1  { opcode: 0 }\n        | CMD2 { opcode: 1 }\n\n// CMD1 format is [OPCODE (4bytes)][TABLE_SIZE (4bytes)][TABLE_NAME (TABLE_SIZE bytes)]\nCMD1  ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from the first switch case\n          TABLE_SIZE { size: 4 }       \n          TABLE_NAME { size: TABLE_SIZE }  // the size of TABLE_NAME is TABLE_SIZE\n\n// CMD2 format is [OPCODE (4bytes)][TABLE_SIZE (4bytes)][TABLE_NAME (TABLE_SIZE bytes)][SET_SIZE (4bytes)][SET_NAME (SET_SIZE bytes)]\nCMD2  ::= OPCODE { size: 4, value: 1} // OPCODE value 1 comes from the second switch case\n          TABLE_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_SIZE }\n          SET_SIZE { size: 4 }\n          SET_NAME { size: SET_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD0 or CMD1.\nCMD   ::= CMD0 \n        | CMD1\n\n// CMD0 will be triggered when command == 0\nCMD0  ::= CMD_ID { size: 4, value: 0 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n\n// CMD1 will be triggered when command == 1\nCMD1  ::= CMD_ID { size: 4, value: 1 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n          SET_NAME_SIZE { size: 4 }\n          SET_NAME { size: SET_NAME_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 or CMD2.\nCMD   ::= CMD1 \n        | CMD2\n\nCMD1  ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from the first case statement\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE } // the size of TABLE_NAME is TABLE_NAME_SIZE\n\nCMD2  ::= OPCODE { size: 4, value: 1 } // OPCODE value 1 comes from the second case statement\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE } // the size of TABLE_NAME is TABLE_NAME_SIZE\n          SET_NAME_SIZE { size: 4 }\n          SET_NAME { size: SET_NAME_SIZE } // the size of SET_NAME is SET_NAME_SIZE",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2\n\nCMD1  ::= OPCODE { size: 4, value: 0 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 1 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n          SET_NAME_SIZE { size: 4 }\n          SET_NAME { size: SET_NAME_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT(4byte)][CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 or CMD2 if the target program has two commands.\nCMD   ::= CMD1\n        | CMD2\n\nCMD1  ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from the first command\n          TABLENAME_SIZE { size: 4 }\n          TABLENAME { size: TABLENAME_SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 1 } // OPCODE value 1 comes from the second command\n          TABLENAME_SIZE { size: 4 }\n          TABLENAME { size: TABLENAME_SIZE }\n          SETNAME_SIZE { size: 4 }\n          SETNAME { size: SETNAME_SIZE }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD0 \n        | CMD1\n\nCMD0  ::= CMD_TYPE { size: 4, value: 0 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n\nCMD1  ::= CMD_TYPE { size: 4, value: 1 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n          SET_NAME_SIZE { size: 4 }\n          SET_NAME { size: SET_NAME_SIZE }",
          "INPUT ::= COMMAND_CNT { size: 4 }\n          COMMAND[COMMAND_CNT]\n\nCOMMAND ::= COMMAND0\n          | COMMAND1\n\nCOMMAND0 ::= COMMAND_ID { size: 4, value: 0 }\n             TABLE_SIZE { size: 4 }\n             TABLE_NAME { size: TABLE_SIZE }\n\nCOMMAND1 ::= COMMAND_ID { size: 4, value: 1 }\n             TABLE_SIZE { size: 4 }\n             TABLE_NAME { size: TABLE_SIZE }\n             SET_SIZE { size: 4 }\n             SET_NAME { size: SET_SIZE }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2\n\nCMD1  ::= OPCODE { size: 4, value: 0 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 1 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n          SET_NAME_SIZE { size: 4 }\n          SET_NAME { size: SET_NAME_SIZE }",
          "// INPUT is the start of the input format.\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 or CMD2 if the target program has two commands.\nCMD   ::= CMD1 \n        | CMD2\n\nCMD1 ::= COMMAND { size: 4, value: 0 } \n         SIZE { size: 4 }  \n         DATA { size: SIZE }    // the size of DATA field is SIZE\n\nCMD2 ::= COMMAND { size: 4, value: 1 }  \n         SIZE1 { size: 4 }\n         DATA1 { size: SIZE1 }  // the size of DATA1 field is SIZE1\n         SIZE2 { size: 4 }\n         DATA2 { size: SIZE2 }  // the size of DATA2 field is SIZE2",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will have two types: CMD0 or CMD1\nCMD   ::= CMD0\n        | CMD1\n\n// CMD0 comprises of a OPCODE with value 0, followed by TABLE_NAME_SIZE, \n// followed by a TABLE_NAME of TABLE_NAME_SIZE bytes\nCMD0  ::= OPCODE { size: 4, value: 0 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n\n// CMD1 comprises of a OPCODE with value 1, followed by TABLE_NAME_SIZE,\n// followed by a TABLE_NAME of TABLE_NAME_SIZE bytes, then followed by SET_NAME_SIZE\n// and finally followed by a SET_NAME of SET_NAME_SIZE bytes\nCMD1  ::= OPCODE { size: 4, value: 1 }\n          TABLE_NAME_SIZE { size: 4 }\n          TABLE_NAME { size: TABLE_NAME_SIZE }\n          SET_NAME_SIZE { size: 4 }\n          SET_NAME { size: SET_NAME_SIZE }"
        ]
      },
      "CVE-2022-0995": {
        "total_runs": 10,
        "success_count": 9,
        "first_success": 0,
        "unique_count": 2,
        "popular_count": 8,
        "syntactically_correct": 10,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of COMMAND]\nINPUT ::= CMD_CNT { size: 4 }\n          COMMAND[CMD_CNT]\n\n// A COMMAND can be COMMAND_KIND_0 or COMMAND_KIND_1\nCOMMAND ::= COMMAND_KIND_0\n          | COMMAND_KIND_1\n\n// COMMAND_KIND_0 is distinguished by its command value of 0.\n// Following the command, a size value is appended.\nCOMMAND_KIND_0 ::= COMMAND { size: 4, value: 0 }\n                  SIZE { size: 4 }\n\n// COMMAND_KIND_1 is distinguished by its command value of 1.\n// Following the command, a size value and its respective data are appended.\nCOMMAND_KIND_1 ::= COMMAND { size: 4, value: 1 }\n                  SIZE { size: 4 }\n                  DATA { size: SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte) ][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be COMMAND_0 or COMMAND_1\nCOMMAND ::= COMMAND_0\n          | COMMAND_1\n\nCOMMAND_0 ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from case 0 \n               SIZE { size: 4 } \n\nCOMMAND_1 ::= OPCODE { size: 4, value: 1 } // OPCODE value 1 comes from case 1\n               SIZE { size: 4 } \n               FILTER { size: SIZE } // the size of FILTER is SIZE\n",
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\nCOMMAND ::= COMMAND_0\n          | COMMAND_1\n\nCOMMAND_0 ::= COMMAND_TYPE { size: 4, value: 0 }\n              SIZE { size: 4 }\n\nCOMMAND_1 ::= COMMAND_TYPE { size: 4, value: 1 }\n              DATA_SIZE { size: 4 }\n              DATA { size: DATA_SIZE }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1\n        | CMD2\n\nCMD1  ::= OPCODE { size: 4, value: 0}\n          SIZE { size: 4 }\n\nCMD2  ::= OPCODE { size: 4, value: 1}\n          FILTER_SIZE { size: 4 }\n          FILTER_DATA { size: FILTER_SIZE }",
          "INPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\nCMD ::= CMD_SET_SIZE\n      | CMD_SET_FILTER\n      | ERR_CMD\n\nCMD_SET_SIZE ::= OPCODE { size: 4, value: 0 }\n                 SIZE { size: 4 }\n\nCMD_SET_FILTER ::= OPCODE { size: 4, value: 1 }\n                   SIZE { size: 4 }\n                   FILTER { size: SIZE }\n\nERR_CMD ::= OPCODE { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte) ][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be COMMAND1 or COMMAND2 depending on the command type defined in its command opcode.\nCOMMAND   ::= COMMAND1 \n            | COMMAND2\n\n// COMMAND1 is a chunk defining IOC_WATCH_QUEUE_SET_SIZE. \nCOMMAND1  ::= OPCODE { size: 4, value: 0 }  // OPCODE 0 defines the command type.\n              SIZE { size: 4 }\n\n// COMMAND2 is a chunk defining IOC_WATCH_QUEUE_SET_FILTER with data blob. \nCOMMAND2  ::= OPCODE { size: 4, value: 1 } // OPCODE 1 defines the command type.\n              SIZE { size: 4 }\n              DATA_BLOB { size: SIZE }  // The size of DATA_BLOB is defined by SIZE.",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2\n\nCMD1  ::= OPCODE_SET_SIZE { size: 4, value: 0 } \n          SIZE { size: 4 }\n\nCMD2  ::= OPCODE_SET_FILTER { size: 4, value: 1} \n          FILTER_SIZE { size: 4 }\n          FILTER { size: FILTER_SIZE }",
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\nCOMMAND  ::= COMMAND_0\n           | COMMAND_1\n\nCOMMAND_0  ::= CMD_ID { size: 4, value: 0 }  \n               SIZE { size: 4 }     \n\nCOMMAND_1  ::= CMD_ID { size: 4, value: 1}\n               SIZE { size: 4 }\n               DATA { size: SIZE }",
          "// Input starts with the COMMAND_COUNT and followed by COMMAND_COUNT commands.\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// The COMMAND can be of type COMMAND0 or COMMAND1.\nCOMMAND ::= COMMAND0 \n          | COMMAND1\n\nCOMMAND0 ::= COMMAND_ID { size: 4, value: 0 } // The command ID 0 is based on the first switch case.\n            SIZE { size: 4 } // The size of the IOC_WATCH_QUEUE_SET_SIZE, max value is 5.\n\nCOMMAND1 ::= COMMAND_ID { size: 4, value: 1 }  // The command ID 1 from the second switch case. \n            SIZE { size: 4 } // Size of the IOC_WATCH_QUEUE_SET_FILTER, max value is 4096.\n            FILTER_DATA { size: SIZE }",
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT] \n\nCOMMAND ::= COMMAND_0\n          | COMMAND_1 \n\nCOMMAND_0  ::= OPCODE { size: 4, value: 0 } \n               SIZE { size: 4 }\n\nCOMMAND_1  ::= OPCODE { size: 4, value: 1} \n               SIZE { size: 4}\n               FILTER { size: SIZE } "
        ]
      },
      "KPRCA-00001": {
        "total_runs": 10,
        "success_count": 1,
        "first_success": 4,
        "unique_count": 3,
        "popular_count": 3,
        "syntactically_correct": 6,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4 bytes) ][ COMMAND_COUNT amount of CMD]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          CMD[COMMAND_COUNT]\n\n\n// CMD will be CMD_INIT_STDIN or CMD_GET_STDOUT or CMD_WORK_WITH_DATA\nCMD   ::= CMD_INIT_STDIN\n        | CMD_GET_STDOUT\n        | CMD_WORK_WITH_DATA\n\nCMD_INIT_STDIN ::= OPCODE { size: 4, value: 0x40 } // value comes from IOCTL_INIT_STDIN\n\nCMD_GET_STDOUT ::= OPCODE { size: 4, value: 0x41 } // value comes from IOCTL_GET_STDOUT\n\nCMD_WORK_WITH_DATA ::= OPCODE { size: 4, value: 0x50 } // value comes from WORK_WITH_DATA\n                      BUF_LEN { size: 4 } \n                      BUF { size : BUF_LEN }",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte) ][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT {size: 4} COMMAND[COMMAND_COUNT]\n\n// COMMAND will be IOCTL_INIT_STDIN, IOCTL_GET_STDOUT or WORK_WITH_DATA\nCOMMAND ::= IOCTL_INIT_STDIN_CMD\n          | IOCTL_GET_STDOUT_CMD\n          | WORK_WITH_DATA_CMD\n\nIOCTL_INIT_STDIN_CMD ::= IOCTL_INIT_STDIN {size: 4, value: 0x40}\n\nIOCTL_GET_STDOUT_CMD ::= IOCTL_GET_STDOUT {size: 4, value: 0x41}\n\n// WORK_WITH_DATA_CMD includes the size of buffer and the buffer content\nWORK_WITH_DATA_CMD ::= WORK_WITH_DATA {size: 4, value: 0x50} BUF_LEN {size: 4} BUF {size: BUF_LEN}",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte)][COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 } \n            COMMAND[COMMAND_COUNT] \n\n// COMMAND will be one of three options, depending on what type the CMD_TYPE represents\nCOMMAND ::= COMMAND1 | COMMAND2 | COMMAND3 \n\nCOMMAND1 ::= CMD_TYPE { size: 4, value: 0x40 }            // corresponds to IOCTL_INIT_STDIN   \n\nCOMMAND2 ::= CMD_TYPE { size: 4, value: 0x41 }            // corresponds to IOCTL_GET_STDOUT \n\nCOMMAND3 ::= CMD_TYPE { size: 4, value: 0x50 }            // corresponds to WORK_WITH_DATA\n             BUF_LEN { size: 8 }                                  \n             BUF { size: BUF_LEN }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD_INIT_STDIN, CMD_GET_STDOUT or CMD_WORK_WITH_DATA\nCMD   ::= CMD_INIT_STDIN\n        | CMD_GET_STDOUT\n        | CMD_WORK_WITH_DATA\n\nCMD_INIT_STDIN ::= CMD_TYPE { size: 4, value: 0x40 }  // CMD_TYPE value comes from the `case IOCTL_INIT_STDIN:` section\n\nCMD_GET_STDOUT ::= CMD_TYPE { size: 4, value: 0x41 }  // CMD_TYPE value comes from the `case IOCTL_GET_STDOUT:` section\n\nCMD_WORK_WITH_DATA ::= CMD_TYPE { size: 4, value: 0x50 } // CMD_TYPE value comes from the `case WORK_WITH_DATA:` section\n                      BUF_LEN { size: 4 }               // BUF_LEN value comes from `memcpy(&buf_len, blob + index, 4);`\n                      BUF { size: BUF_LEN }             // BUF is a block of arbitrary data, its size comes from previous BUF_LEN",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_COUNT (4 bytes) ][ CMD_COUNT chunks of CMD]\nINPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\n// CMD will be CMD_INIT_STDIN, CMD_GET_STDOUT or CMD_WORK_WITH_DATA\nCMD   ::= CMD_INIT_STDIN \n        | CMD_GET_STDOUT\n        | CMD_WORK_WITH_DATA\n\n// CMD_INIT_STDIN just consists of opcode\nCMD_INIT_STDIN ::= OPCODE { size: 4, value: 0x40 } \n\n// CMD_GET_STDOUT just consists of opcode\nCMD_GET_STDOUT ::= OPCODE { size: 4, value: 0x41 }  \n\n// CMD_WORK_WITH_DATA consists of opcode, buf_len and buf\nCMD_WORK_WITH_DATA ::= OPCODE { size: 4, value: 0x50 }\n                       BUF_LEN { size: 8 }      \n                       BUF { size: BUF_LEN }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be one of Driver commands like CMD1, CMD2, CMD3.\nCMD    ::= CMD1\n        | CMD2\n        | CMD3\n\nCMD1   ::= IOCTL_INIT_STDIN { size: 4, value: 0x40 } // IOCTL_INIT_STDIN comes from the IOCTL_INIT_STDIN case in the switch statement\n\nCMD2   ::= IOCTL_GET_STDOUT { size: 4, value: 0x41 } // IOCTL_GET_STDOUT comes from the IOCTL_GET_STDOUT case in the switch statement\n\nCMD3   ::= WORK_WITH_DATA { size: 4, value: 0x50 } // WORK_WITH_DATA comes from the WORK_WITH_DATA case in the switch statement\n           BUF_LEN { size: 4} // Then the size of BUF\n           BUF { size: BUF_LEN } // The BUF itself",
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND_SEQUENCE[COMMAND_COUNT]\n\nCOMMAND ::= CMD1 \n          | CMD2\n          | CMD3\n\nCMD1 ::= IOCTL_INIT_STDIN { size: 4, value: 0x40 }\n\nCMD2 ::= IOCTL_GET_STDOUT { size: 4, value: 0x41 }\n\nCMD3 ::= WORK_WITH_DATA { size: 4, value: 0x50 }\n          BUF_LEN { size: 4 }\n          BUF[BUF_LEN]",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4 byte) ][COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be one of the following: INIT_STDIN, GET_STDOUT, WORK_WITH_DATA\nCOMMAND   ::= INIT_STDIN \n            | GET_STDOUT \n            | WORK_WITH_DATA\n\n// No data is associated with INIT_STDIN command\nINIT_STDIN ::= CMD_CODE { size: 4, value: 0x40 } // CMD_CODE 0x40 corresponds to IOCTL_INIT_STDIN\n\n// No data is associated with GET_STDOUT command\nGET_STDOUT ::= CMD_CODE { size: 4, value: 0x41 } // CMD_CODE 0x41 corresponds to IOCTL_GET_STDOUT\n\n// WORK_WITH_DATA begins with CMD_CODE 0x50 and followed by BUFFER_LENGTH then BUFFER\nWORK_WITH_DATA ::= CMD_CODE { size: 4, value: 0x50 } // CMD_CODE 0x50 corresponds to WORK_WITH_DATA\n                   BUFFER_LENGTH { size: 4 }\n                   BUFFER { size: BUFFER_LENGTH }",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_CNT (4byte)][ COMMAND_CNT chunks of COMMAND]\nINPUT ::= COMMAND_CNT { size: 4 }\n          COMMAND[COMMAND_CNT] \n\n// COMMAND will be either INIT_STDIN, GET_STDOUT or WORK_WITH_DATA, adhering to the command codes defined in the program.\nCOMMAND ::= INIT_STDIN { size: 4, value: 0x40 }  // Corresponding to IOCTL_INIT_STDIN\n          | GET_STDOUT { size: 4, value: 0x41 }  // Corresponding to IOCTL_GET_STDOUT\n          | WORK_DATA\n\n// WORK_DATA consists of the command code followed by the data length and the actual data.\nWORK_DATA ::= WORK_COMMAND { size: 4, value: 0x50 }  // Corresponding to WORK_WITH_DATA\n              DATA_LEN { size: 4 }\n              DATA { size: DATA_LEN }",
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\nCOMMAND ::= CMD_INIT_STDIN { value: 0x40, size: 4 }  \n          | CMD_GET_STDOUT { value: 0x41, size: 4 }\n          | CMD_WORK_WITH_DATA { value: 0x50, size: 4 }\n            BUF_LEN { size: 4 }\n            BUF[BUF_LEN]\n            \nCMD_INIT_STDIN ::= \"IOCTL_INIT_STDIN\" { value: 0x40, size: 4 }\n\nCMD_GET_STDOUT ::= \"IOCTL_GET_STDOUT\" { value: 0x41, size: 4 }\n\nCMD_WORK_WITH_DATA ::= \"WORK_WITH_DATA\" { value: 0x50, size: 4 }\n                       BUF_LEN { size: 4 }\n                       BUF[BUF_LEN]"
        ]
      },
      "CVE-2022-0185": {
        "total_runs": 10,
        "success_count": 0,
        "first_success": -1,
        "unique_count": 1,
        "popular_count": 8,
        "syntactically_correct": 9,
        "generated": [
          "INPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\nCOMMAND ::= SET_FLAG\n          | SET_STRING\n          | SET_BINARY\n          | SET_PATH\n          | SET_PATH_EMPTY\n          | CMD_CREATE\n          | CMD_RECONFIGURE\n\nSET_FLAG ::= COMMAND_ID { size: 4, value: 0 }\n             DATA_SIZE { size: 4 }\n             DATA { size: DATA_SIZE }\n\nSET_STRING ::= COMMAND_ID { size: 4, value: 1 }\n               KEY_SIZE { size: 4 }\n               KEY { size: KEY_SIZE }\n               VALUE_SIZE { size: 4 }\n               VALUE { size: VALUE_SIZE }\n\nSET_BINARY ::= COMMAND_ID { size: 4, value: 2 }\n               KEY_SIZE { size: 4 }\n               KEY { size: KEY_SIZE }\n               VALUE_SIZE { size: 4 }\n               VALUE_ATOM { size: VALUE_SIZE }\n\nSET_PATH ::= COMMAND_ID { size: 4, value: 3 }\n             KEY_SIZE { size: 4 }\n             KEY { size: KEY_SIZE }\n             PATH_SIZE { size: 4 }\n             PATH { size: PATH_SIZE }\n\nSET_PATH_EMPTY ::= COMMAND_ID { size: 4, value: 4 }\n                   KEY_SIZE { size: 4 }\n                   KEY { size: KEY_SIZE }\n                   PATH_SIZE { size: 4 }\n                   PATH { size: PATH_SIZE }\n\nCMD_CREATE ::= COMMAND_ID { size: 4, value: 5 }\n\nCMD_RECONFIGURE ::= COMMAND_ID { size: 4, value: 6 }",
          "// INPUT is the start of the input format.\n// Each record contains a key and its corresponding size\nINPUT ::= COMMAND_COUNT { size: 4}\n            CMD[COMMAND_COUNT]\n\nCMD   ::= FSCONFIG_SET_FLAG\n        | FSCONFIG_SET_STRING\n        | FSCONFIG_SET_BINARY\n        | FSCONFIG_SET_PATH\n        | FSCONFIG_SET_PATH_EMPTY\n        | FSCONFIG_CMD_CREATE\n        | FSCONFIG_CMD_RECONFIGURE\n\nFSCONFIG_SET_FLAG ::= COMMAND { size: 4, value: 0} //value 0 comes from the constant FSCONFIG_SET_FLAG\n                        SIZE { size: 4}\n                        DATA { size: SIZE}\n\nFSCONFIG_SET_STRING ::= COMMAND { size: 4, value: 1} //value 1 comes from the constant FSCONFIG_SET_STRING\n                            KEY_SIZE { size: 4}\n                            KEY_DATA { size: KEY_SIZE }\n                            VALUE_SIZE { size: 4}\n                            VALUE_DATA { size: VALUE_SIZE }\n\nFSCONFIG_SET_BINARY ::= COMMAND { size: 4, value: 2} //value 2 comes from the constant FSCONFIG_SET_BINARY\n                            KEY_SIZE { size: 4}\n                            KEY_DATA { size: KEY_SIZE }\n                            VALUE_SIZE { size: 4}\n                            VALUE_DATA { size: VALUE_SIZE }\n\nFSCONFIG_SET_PATH ::= COMMAND { size: 4, value: 3} //value 3 comes from the constant FSCONFIG_SET_PATH\n                        KEY_SIZE { size: 4}\n                        KEY_DATA { size: KEY_SIZE }\n                        FILENAME_SIZE { size: 4}\n                        FILENAME_DATA { size: FILENAME_SIZE}\n\nFSCONFIG_SET_PATH_EMPTY ::= COMMAND { size: 4, value: 4} //value 4 comes from the constant FSCONFIG_SET_PATH_EMPTY\n                                KEY_SIZE { size: 4}\n                                KEY_DATA { size: KEY_SIZE }\n                                FILENAME_SIZE { size: 4}\n                                FILENAME_DATA { size: FILENAME_SIZE}\n\nFSCONFIG_CMD_CREATE ::= COMMAND { size: 4, value: 5} //value 5 comes from the constant FSCONFIG_CMD_CREATE\n\nFSCONFIG_CMD_RECONFIGURE ::= COMMAND { size: 4, value: 6}   //value 6 comes from the constant FSCONFIG_CMD_RECONFIGURE",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1\n        | CMD2\n        | CMD3\n        | CMD4\n        | CMD5\n        | CMD6\n        | CMD7 \n\nCMD1  ::= OPCODE { size: 4, value: 0 } // FSCONFIG_SET_FLAG\n          SIZE { size: 4 }\n          FLAG_PARAMS { size: SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 1 } // FSCONFIG_SET_STRING\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n\nCMD3  ::= OPCODE { size: 4, value: 2 } // FSCONFIG_SET_BINARY\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n         \nCMD4  ::= OPCODE { size: 4, value: 3 } // FSCONFIG_SET_PATH\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME { size: FILENAME_SIZE }\n         \nCMD5  ::= OPCODE { size: 4, value: 4 } // FSCONFIG_SET_PATH_EMPTY\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME { size: FILENAME_SIZE }\n\nCMD6  ::= OPCODE { size: 4, value: 5 } // FSCONFIG_CMD_CREATE\n\nCMD7  ::= OPCODE { size: 4, value: 6 } // FSCONFIG_CMD_RECONFIGURE",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will represent one of the seven possible command types.\nCMD   ::= CMD1 \n        | CMD2\n        | CMD3\n        | CMD4\n        | CMD5\n        | CMD6\n        | CMD7\n\n// CMD1 will be the representation of FSCONFIG_SET_FLAG\nCMD1  ::= COMMAND { size: 4, value: 0 } // COMMAND value 0 comes from the constant FSCONFIG_SET_FLAG\n          SIZE { size: 4 }       \n          FLAG_PARAMS { size: SIZE }     // the size of FLAG_PARAMS is SIZE\n\n// CMD2 will be the representation of FSCONFIG_SET_STRING\nCMD2  ::= COMMAND { size: 4, value: 1 } // COMMAND value 1 comes from the constant FSCONFIG_SET_STRING\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n\n// CMD3 will be the representation of FSCONFIG_SET_BINARY\nCMD3  ::= COMMAND { size: 4, value: 2 } // COMMAND value 2 comes from the constant FSCONFIG_SET_BINARY\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n\n// CMD4 will be the representation of FSCONFIG_SET_PATH\nCMD4  ::= COMMAND { size: 4, value: 3 } // COMMAND value 3 comes from the constant FSCONFIG_SET_PATH\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME { size: FILENAME_SIZE }\n\n// CMD5 will be the representation of FSCONFIG_SET_PATH_EMPTY\nCMD5  ::= COMMAND { size: 4, value: 4 } // COMMAND value 4 comes from the constant FSCONFIG_SET_PATH_EMPTY\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME { size: FILENAME_SIZE }\n\n// CMD6 will be the representation of FSCONFIG_CMD_CREATE\nCMD6  ::= COMMAND { size: 4, value: 5 } // COMMAND value 5 comes from the constant FSCONFIG_CMD_CREATE\n\n// CMD7 will be the representation of FSCONFIG_CMD_RECONFIGURE\nCMD7  ::= COMMAND { size: 4, value: 6 } // COMMAND value 6 comes from the constant FSCONFIG_CMD_RECONFIGURE",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1 \n        | CMD2 \n        | CMD3 \n        | CMD4 \n        | CMD5 \n        | CMD6\n        | CMD7\n\nCMD1  ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 corresponds FSCONFIG_SET_FLAG in switch-case\n          FLAG_PARAMS_SIZE { size: 4 }  \n          FLAG_PARAMS_DATA { size: FLAG_PARAMS_SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 1 } // OPCODE value 1 corresponds FSCONFIG_SET_STRING in switch-case\n          KEY_SIZE1 { size: 4 } \n          KEY_DATA1 { size: KEY_SIZE1 }\n          VALUE_SIZE1 { size: 4 }\n          VALUE_DATA1 { size: VALUE_SIZE1  }\n\nCMD3  ::= OPCODE { size: 4, value: 2 } // OPCODE value 2 corresponds FSCONFIG_SET_BINARY in switch-case\n          KEY_SIZE2 { size: 4 } \n          KEY_DATA2 { size: KEY_SIZE2 }\n          VALUE_SIZE2 { size: 4 }\n          VALUE_DATA2 { size: VALUE_SIZE2 }\n\nCMD4  ::= OPCODE { size: 4, value: 3 } // OPCODE value 3 corresponds FSCONFIG_SET_PATH in switch-case\n          KEY_SIZE3 { size: 4 } \n          KEY_DATA3 { size: KEY_SIZE3 }\n          FILENAME_SIZE1 { size: 4 }\n          FILENAME_DATA1 { size: FILENAME_SIZE1 }\n\nCMD5  ::= OPCODE { size: 4, value: 4 } // OPCODE value 4 corresponds FSCONFIG_SET_PATH_EMPTY in switch-case\n          KEY_SIZE4 { size: 4 } \n          KEY_DATA4 { size: KEY_SIZE4 }\n          FILENAME_SIZE2 { size: 4 }\n          FILENAME_DATA2 { size: FILENAME_SIZE2 }\n\nCMD6  ::= OPCODE { size: 4, value: 5 } // OPCODE value 5 corresponds FSCONFIG_CMD_CREATE in switch-case\n\nCMD7  ::= OPCODE { size: 4, value: 6 } // OPCODE value 6 corresponds FSCONFIG_CMD_RECONFIGURE in switch-case",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= SET_FLAG_CMD\n        | SET_STRING_CMD\n        | SET_BINARY_CMD\n        | SET_PATH_CMD\n        | SET_PATH_EMPTY_CMD\n        | CMD_CREATE_CMD\n        | CMD_RECONFIGURE_CMD\n\nSET_FLAG_CMD       ::= OPCODE { size: 4, value: 0 }\n                       SIZE { size: 4}\n                       FLAG_PARAMS { size: SIZE }\n\nSET_STRING_CMD     ::= OPCODE { size: 4, value: 1 }\n                       KEY_SIZE { size: 4 }\n                       KEY_DATA { size: KEY_SIZE }\n                       VALUE_SIZE { size: 4 }\n                       VALUE_DATA { size: VALUE_SIZE }\n\nSET_BINARY_CMD     ::= OPCODE { size: 4, value: 2 }\n                       KEY_SIZE { size: 4 }\n                       KEY_DATA { size: KEY_SIZE }\n                       VALUE_SIZE { size: 4 }\n                       VALUE_DATA { size: VALUE_SIZE }\n\nSET_PATH_CMD       ::= OPCODE { size: 4, value: 3 }\n                       KEY_SIZE { size: 4 }\n                       KEY_DATA { size: KEY_SIZE }\n                       FILENAME_SIZE { size: 4 }\n                       FILENAME_DATA { size: FILENAME_SIZE }\n\nSET_PATH_EMPTY_CMD ::= OPCODE { size: 4, value: 4 }\n                       KEY_SIZE { size: 4 }\n                       KEY_DATA { size: KEY_SIZE }\n                       FILENAME_SIZE { size: 4 }\n                       FILENAME_DATA { size: FILENAME_SIZE }\n\nCMD_CREATE_CMD     ::= OPCODE { size: 4, value: 5 }\n\nCMD_RECONFIGURE_CMD ::= OPCODE { size: 4, value: 6 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD  ::= CMD1 \n       | CMD2 \n       | CMD3 \n       | CMD4 \n       | CMD5 \n       | CMD6 \n       | CMD7\n\nCMD1 ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from FSCONFIG_SET_FLAG\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE } \n\nCMD2 ::= OPCODE { size: 4, value: 1 } // OPCODE value 1 comes from FSCONFIG_SET_STRING\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n\nCMD3 ::= OPCODE { size: 4, value: 2 } // OPCODE value 2 comes from FSCONFIG_SET_BINARY\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n\nCMD4 ::= OPCODE { size: 4, value: 3 } // OPCODE value 3 comes from FSCONFIG_SET_PATH\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME { size: FILENAME_SIZE }\n\nCMD5 ::= OPCODE { size: 4, value: 4 } // OPCODE value 4 comes from FSCONFIG_SET_PATH_EMPTY\n          KEY_SIZE { size: 4 }\n          KEY { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME { size: FILENAME_SIZE }\n\nCMD6 ::= OPCODE { size: 4, value: 5 } // OPCODE value 5 comes from FSCONFIG_CMD_CREATE\n\nCMD7 ::= OPCODE { size: 4, value: 6 } // OPCODE value 6 comes from FSCONFIG_CMD_RECONFIGURE",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// Single Command (CMD) is one of command types from CMD1 to CMD7\nCMD   ::= CMD1\n        | CMD2\n        | CMD3\n        | CMD4\n        | CMD5\n        | CMD6\n        | CMD7\n\nCMD1  ::= OPCODE { size: 4, value: 0 } // FSCONFIG_SET_FLAG\n          SIZE { size: 4}       \n          DATA { size: SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 1 } // FSCONFIG_SET_STRING\n          KEY_SIZE { size: 4}\n          KEY_DATA { size: KEY_SIZE }\n          VALUE_SIZE { size: 4}\n          VALUE_DATA { size: VALUE_SIZE }\n\nCMD3  ::= OPCODE { size: 4, value: 2 } // FSCONFIG_SET_BINARY\n          KEY_SIZE { size: 4}\n          KEY_DATA { size: KEY_SIZE }\n          VAL_SIZE { size: 4}\n          VAL_DATA { size: VAL_SIZE }\n\nCMD4  ::= OPCODE { size: 4, value: 3 } // FSCONFIG_SET_PATH\n          KEY_SIZE { size: 4}\n          KEY_DATA { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4}\n          FILENAME_DATA { size: FILENAME_SIZE }\n\nCMD5  ::= OPCODE { size: 4, value: 4 } // FSCONFIG_SET_PATH_EMPTY\n          KEY_SIZE { size: 4}\n          KEY_DATA { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4}\n          FILENAME_DATA { size: FILENAME_SIZE }\n\nCMD6  ::= OPCODE { size: 4, value: 5 } // FSCONFIG_CMD_CREATE\n\nCMD7  ::= OPCODE { size: 4, value: 6 } // FSCONFIG_CMD_RECONFIGURE",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD ::= CMD1\n      | CMD2\n      | CMD3\n      | CMD4\n      | CMD5\n      | CMD6\n      | CMD7\n\nCMD1 ::= OPCODE { size: 4, value: 0 } \n          SIZE { size: 4 }\n          FLAG_PARAMS { size: SIZE }\n\nCMD2 ::= OPCODE { size: 4, value: 1 } \n          KEY_SIZE { size: 4 }\n          KEY_DATA { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE_DATA { size: VALUE_SIZE }\n\nCMD3 ::= OPCODE { size: 4, value: 2 } \n          KEY_SIZE { size: 4 }\n          KEY_DATA { size: KEY_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE_DATA { size: VALUE_SIZE }\n\nCMD4 ::= OPCODE { size: 4, value: 3 } \n          KEY_SIZE { size: 4 }\n          KEY_DATA { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME_DATA { size: FILENAME_SIZE }\n\nCMD5 ::= OPCODE { size: 4, value: 4 } \n          KEY_SIZE { size: 4 }\n          KEY_DATA { size: KEY_SIZE }\n          FILENAME_SIZE { size: 4 }\n          FILENAME_DATA { size: FILENAME_SIZE }\n\nCMD6 ::= OPCODE { size: 4, value: 5 }\n\nCMD7 ::= OPCODE { size: 4, value: 6 }",
          "INPUT :: = CMD_CNT {size: 4}\n            CMD[CMD_CNT]\n\nCMD  :: = SET_FLAG_CMD\n        | SET_STRING_CMD\n        | SET_BINARY_CMD\n        | SET_PATH_CMD\n        | SET_PATH_EMPTY_CMD\n        | SET_FD_CMD\n        | CMD_CREATE_CMD\n        | CMD_RECONFIGURE_CMD\n\nSET_FLAG_CMD ::= OPCODE {size: 4, value: 0} // opcode value comes from the case: FSCONFIG_SET_FLAG\n                 SIZE {size: 4}\n                 FLAG_PARAM_DATA {size: SIZE}\n\nSET_STRING_CMD ::= OPCODE {size: 4, value: 1} // opcode value comes from the case: FSCONFIG_SET_STRING\n                   KEY_SIZE {size: 4}\n                   KEY_DATA {size: KEY_SIZE}\n                   VALUE_SIZE {size: 4}\n                   VALUE_DATA {size: VALUE_SIZE}\n\nSET_BINARY_CMD ::= OPCODE {size: 4, value: 2} // opcode value comes from the case: FSCONFIG_SET_BINARY \n                    KEY_SIZE {size: 4}\n                    KEY_DATA {size: KEY_SIZE}\n                    VALUE_SIZE {size: 4}\n                    VALUE_DATA {size: VALUE_SIZE}\n\nSET_PATH_CMD ::= OPCODE {size: 4, value: 3} // opcode value comes from the case: FSCONFIG_SET_PATH\n                 KEY_SIZE {size: 4}\n                 KEY_DATA {size: KEY_SIZE}\n                 FILENAME_SIZE {size: 4}\n                 FILENAME_DATA {size: FILENAME_SIZE}\n\nSET_PATH_EMPTY_CMD ::= OPCODE {size: 4, value: 4} // opcode value comes from the case: FSCONFIG_SET_PATH_EMPTY\n                       KEY_SIZE {size: 4}\n                       KEY_DATA {size: KEY_SIZE}\n                       FILENAME_SIZE {size: 4}\n                       FILENAME_DATA {size: FILENAME_SIZE}\n\nCMD_CREATE_CMD ::= OPCODE {size: 4, value: 5} // opcode value comes from the case: FSCONFIG_CMD_CREATE\n\nCMD_RECONFIGURE_CMD ::= OPCODE {size: 4, value: 6} // opcode value comes from the case: FSCONFIG_CMD_RECONFIGURE"
        ]
      },
      "CADET-00001": {
        "total_runs": 10,
        "success_count": 9,
        "first_success": 0,
        "unique_count": 1,
        "popular_count": 8,
        "syntactically_correct": 9,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n          \n// CMD will consist of one of the possible command types, identified by their opcode.\nCMD   ::= CMD1\n\nCMD1  ::= OPCODE { size: 4, value: 0} // OPCODE value 0 is for the case 0 in the code.\n          SIZE { size: 4 }\n          DATA { size: SIZE }",
          "INPUT  ::= CMD_COUNT { size: 4 }\n           CMD[CMD_COUNT]\n\nCMD    ::= CMD0 \n\nCMD0   ::= OPCODE { size: 4, value: 0 }\n           DATA_SIZE { size: 4}\n           DATA { size: DATA_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4bytes) ][ CMD_CNT chunks of CMD0]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD0[CMD_CNT]\n\n// CMD0 will be always be a 4-byte command literal 0, followed by 4 bytes indicating the size of the data, and then the data itself.\nCMD0  ::= COMMAND { size: 4, value: 0 }\n          SIZE { size: 4 }\n          DATA { size: SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4byte) ][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be COMMAND1 based on the existing logic.\nCOMMAND   ::= COMMAND1\n\nCOMMAND1  ::= OPCODE { size: 4, value: 0 }  // OPCODE value 0 is the only command identified\n              SIZE { size: 4 }              // Size of data pointed by PTR\n              PTR { size: SIZE }            // PTR points to data based on the SIZE",
          "INPUT ::= CMD_NUM { size: 4 }\n          CMD[CMD_NUM]\n\nCMD   ::= CMD_TYPE { size: 4 }\n\nCMD_TYPE  ::= IOCTL { value: 0 }\n            | UNKNOWN\n\nIOCTL ::= COMMAND { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE } ",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4 bytes)][COMMAND_COUNT commands]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will have a format of CMD0\nCOMMAND ::= CMD0\n\n// CMD0 is an ioctl command to the target driver\n// CMD0 format is [OPCODE (4 bytes)][SIZE (4 bytes)][DATA (SIZE bytes)]\nCMD0 ::= OPCODE { size: 4, value: 0 }\n         SIZE { size: 4 }       \n         DATA { size: SIZE }   ",
          "INPUT ::= CMD_COUNT { size: 4 }\n          CMD [CMD_COUNT]\n\nCMD   ::= CMD1\n\nCMD1  ::= COMMAND_TYPE { size: 4, value: 0 }\n          SIZE { size: 4 }\n          DATA { size: SIZE }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT] \n\nCMD   ::= CMD1 \n\nCMD1  ::= COMMAND { size: 4, value: 0 }\n          SIZE { size: 4 }\n          DATA { size: SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of COMMAND]\nINPUT ::= CMD_CNT { size: 4 }\n          COMMAND[CMD_CNT]\n\nCOMMAND  ::= CMD_TYPE { size: 4, value: 0 } \n             SIZE { size: 4 }\n             DATA { size: SIZE } ",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4-byte) ][ COMMAND_COUNT chunks of COMMAND]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be COMMAND_0 if the opcode value is 0.\nCOMMAND ::= COMMAND_0\n\nCOMMAND_0 ::= OPCODE { size: 4, value: 0 } // OPCODE 0 comes from the case of command switch\n             SIZE { size: 4 }\n             DATA { size: SIZE }           // the size of DATA is SIZE"
        ]
      },
      "CVE-2023-2513": {
        "total_runs": 10,
        "success_count": 10,
        "first_success": 0,
        "unique_count": 1,
        "popular_count": 9,
        "syntactically_correct": 10,
        "generated": [
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD0 \n        | CMD1\n        | CMD2\n        | CMD3\n        | CMD4\n\nCMD0  ::= CMD_TYPE { size: 4, value: 0 }\n          DIRECTORY_PATH_SIZE { size: 4 }\n          DIRECTORY_PATH { size: DIRECTORY_PATH_SIZE }\n          \nCMD1  ::= CMD_TYPE { size: 4, value: 1 }\n          MOUNT_FLAG { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }\n          \nCMD2  ::= CMD_TYPE { size: 4, value: 2 }\n          \nCMD3  ::= CMD_TYPE { size: 4, value: 3 }\n          FILE_PATH_SIZE { size: 4 }\n          FILE_PATH { size: FILE_PATH_SIZE }\n          \nCMD4  ::= CMD_TYPE { size: 4, value: 4 }\n          FILE_PATH_SIZE { size: 4 }\n          FILE_PATH { size: FILE_PATH_SIZE }\n          NAME_SIZE { size: 4 }\n          NAME_DATA { size: NAME_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE_DATA { size: VALUE_SIZE }\n          ATTRIBUTE_FLAG { size: 4 }",
          "INPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\nCMD ::= CMD0\n       | CMD1\n       | CMD2\n       | CMD3\n       | CMD4\n\nCMD0 ::= OPCODE { size: 4, value: 0 }\n         SIZE { size: 4 }\n         DIR_PATH { size: SIZE }\n\nCMD1 ::= OPCODE { size: 4, value: 1 }\n         MOUNT_FLAGS { size: 4 }\n         SIZE { size: 4 }\n         DATA { size: SIZE }\n\nCMD2 ::= OPCODE { size: 4, value: 2 }\n\nCMD3 ::= OPCODE { size: 4, value: 3 }\n         SIZE { size: 4 }\n         FILE_PATH { size: SIZE }\n\nCMD4 ::= OPCODE { size: 4, value: 4 }\n         FILE_PATH_SIZE { size: 4 }\n         FILE_PATH { size: FILE_PATH_SIZE }\n         NAME_SIZE { size: 4 }\n         NAME { size: NAME_SIZE }\n         VALUE_SIZE { size: 4 }\n         VALUE { size: VALUE_SIZE }\n         XATTR_FLAGS { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of COMMAND]\nINPUT ::= CMD_CNT { size: 4 }\n          COMMAND[CMD_CNT]\n\n// COMMAND will be one of the five commands. It depends on the OPCODE\nCOMMAND ::= CMD1 \n          | CMD2\n          | CMD3\n          | CMD4\n          | CMD5\n\n// Command 1 - Making directory under the given path\nCMD1 ::= OPCODE { size: 4, value: 0 }\n         DIRECTORY_PATH_SIZE { size: 4 }\n         DIRECTORY_PATH { size: DIRECTORY_PATH_SIZE }\n\n// Command 2 - Mounting /dev/loop1 to /tmp/ext4 with flags and optionally data\nCMD2 ::= OPCODE { size: 4, value: 1 }\n         FLAGS { size: 4 }\n         DATA_SIZE { size: 4 }\n         DATA { size: DATA_SIZE }\n\n// Command 3 - Unmount /tmp/ext4\nCMD3 ::= OPCODE { size: 4, value: 2 }\n\n// Command 4 - Create an empty file\nCMD4 ::= OPCODE { size: 4, value: 3 }\n         FILEPATH_SIZE { size: 4 }\n         FILEPATH { size: FILEPATH_SIZE }\n\n// Command 5 - Set xattr to a file\nCMD5 ::= OPCODE { size: 4, value: 4 }\n         FILEPATH_SIZE { size: 4 }\n         FILEPATH { size: FILEPATH_SIZE }\n         NAME_SIZE { size: 4 }\n         NAME { size: NAME_SIZE }\n         VALUE_SIZE { size: 4 }\n         VALUE { size: VALUE_SIZE }\n         FLAGS { size: 4 }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= MKDIR\n        | MOUNT\n        | UMOUNT\n        | CREATE_EMPTY_FILE\n        | SET_XATTR\n\nMKDIR ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 from case 0\n          PATH_SIZE { size: 4 }\n          PATH_DATA { size: PATH_SIZE }\n\nMOUNT ::= OPCODE { size: 4, value: 1 } // OPCODE value 1 from case 1\n          FLAGS { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }\n\nUMOUNT ::= OPCODE { size: 4, value: 2 } // OPCODE value 2 from case 2\n\nCREATE_EMPTY_FILE ::= OPCODE { size: 4, value: 3 } // OPCODE value 3 from case 3\n                      FILE_PATH_SIZE { size: 4 }\n                      FILE_PATH_DATA { size: FILE_PATH_SIZE }\n\nSET_XATTR ::= OPCODE { size: 4, value: 4 } // OPCODE value 4 from case 4\n              FILEPATH_SIZE { size: 4 }       \n              FILEPATH_DATA { size: FILEPATH_SIZE }\n              NAME_SIZE { size: 4 }\n              NAME_DATA { size: NAME_SIZE }\n              VALUE_SIZE { size: 4 }\n              VALUE_DATA { size: VALUE_SIZE }\n              FLAGS { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD0 \n        | CMD1\n        | CMD2\n        | CMD3\n        | CMD4\n\nCMD0  ::= OPCODE { size: 4, value: 0 }\n          SIZE { size: 4 }\n          DIR_PATH { size: SIZE }\n\nCMD1  ::= OPCODE { size: 4, value: 1 }\n          FLAGS { size: 4 }\n          SIZE { size: 4 }\n          DATA { size: SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 2 }\n\nCMD3  ::= OPCODE { size: 4, value: 3 }\n          SIZE { size: 4 }\n          FILE_PATH { size: SIZE }\n\nCMD4  ::= OPCODE { size: 4, value: 4 }\n          FILEPATH_SIZE { size: 4 }\n          FILE_PATH { size: FILEPATH_SIZE }\n          NAME_SIZE { size: 4 }\n          NAME { size: NAME_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n          FLAGS { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4 bytes)][CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD0, CMD1, CMD2, CMD3 or CMD4 depending on the command to be executed.\nCMD   ::= CMD0 \n        | CMD1 \n        | CMD2 \n        | CMD3 \n        | CMD4\n\n// Command 0: make directory\nCMD0  ::= OPCODE { size: 4, value: 0 }\n          DIRECTORY_SIZE { size: 4 }\n          DIRECTORY_PATH { size: DIRECTORY_SIZE }\n\n// Command 1: mounts /dev/loop1 to /tmp/ext4 with flags and data\nCMD1  ::= OPCODE { size: 4, value: 1 }\n          FLAGS { size: 4 }\n          DATA_SIZE { size: 4 }\n          DATA { size: DATA_SIZE }\n\n// Command 2: umounts /tmp/ext4\nCMD2  ::= OPCODE { size: 4, value: 2 }\n\n// Command 3: create empty file\nCMD3  ::= OPCODE { size: 4, value: 3 }\n          FILE_PATH_SIZE { size: 4 }\n          FILE_PATH { size: FILE_PATH_SIZE }\n\n// Command 4: set xattr to a file\nCMD4  ::= OPCODE { size: 4, value: 4 }\n          FILEPATH_SIZE { size: 4 }\n          FILEPATH { size: FILEPATH_SIZE }\n          NAME_SIZE { size: 4 }\n          NAME { size: NAME_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n          FLAGS { size: 4}",
          "// INPUT is the start of the input format.\n// INPUT will be [COMMAND_COUNT (4bytes)][COMMAND_COUNT commands]\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]\n\n// COMMAND will be one of the five possible commands.\nCOMMAND ::= COMMAND0\n          | COMMAND1 \n          | COMMAND2 \n          | COMMAND3 \n          | COMMAND4     \n       \n// Each command is defined based on its opcode.\n\n// COMMAND0: Make directory\nCOMMAND0 ::= OPCODE { size: 4, value: 0 } \n             SIZE { size: 4 }\n             DIRECTORY_PATH_DATA { size: SIZE }\n             \n// COMMAND1: Mounts /dev/loop1 to /tmp/ext4 with flags and data(option)\nCOMMAND1 ::= OPCODE { size: 4, value: 1 } \n             FLAGS { size: 4 }\n             SIZE { size: 4 }\n             DATA { size: SIZE }\n             \n// COMMAND2: Umounts /tmp/ext4\nCOMMAND2 ::= OPCODE { size: 4, value: 2 }\n\n// COMMAND3: Create empty file\nCOMMAND3 ::= OPCODE { size: 4, value: 3 } \n             SIZE { size: 4 }\n             FILE_PATH_DATA { size: SIZE }\n\n// COMMAND4: Set xattr to a file\nCOMMAND4 ::= OPCODE { size: 4, value: 4 } \n             FILEPATH_SIZE { size: 4 }\n             FILEPATH { size: FILEPATH_SIZE }\n             NAME_SIZE { size: 4 }\n             NAME { size: NAME_SIZE }\n             VALUE_SIZE { size: 4 }\n             VALUE { size: VALUE_SIZE }\n             FLAGS { size: 4 }",
          "// INPUT is the start of the input format\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD0 \n        | CMD1\n        | CMD2\n        | CMD3\n        | CMD4\n\nCMD0  ::= OPCODE { size: 4, value: 0 } \n          DIR_SIZE { size: 4 } \n          DIR_DATA { size: DIR_SIZE }\n\nCMD1  ::= OPCODE { size: 4, value: 1 } \n          MNT_FLAGS { size: 4 }\n          MNT_SIZE { size: 4 } \n          MNT_DATA { size: MNT_SIZE }\n\nCMD2  ::= OPCODE { size: 4, value: 2 }\n\nCMD3  ::= OPCODE { size: 4, value: 3 }\n          FILE_SIZE { size: 4 } \n          FILE_DATA { size: FILE_SIZE }\n\nCMD4  ::= OPCODE { size: 4, value: 4 } \n          FILEPATH_SIZE { size: 4 } \n          FILEPATH_DATA { size: FILEPATH_SIZE }\n          NAME_SIZE { size: 4 }\n          NAME_DATA { size: NAME_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE_DATA { size: VALUE_SIZE }\n          XATTR_FLAG { size: 4 }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= MAKE_DIRECTORY_CMD\n        | MOUNT_CMD\n        | UMOUNT_CMD\n        | CREATE_EMPTY_FILE_CMD\n        | SET_XATTR_CMD\n\nMAKE_DIRECTORY_CMD ::= OPCODE { size: 4, value: 0} // OPCODE value 0 represents the command \"make directory\"\n                      SIZE { size: 4 }\n                      DIRECTORY_PATH { size: SIZE }\n\nMOUNT_CMD ::= OPCODE { size: 4, value: 1 } // OPCODE value 1 represents the command \"mount\"\n              FLAGS { size: 4 }\n              SIZE { size: 4 }\n              DATA { size: SIZE }\n\nUMOUNT_CMD ::= OPCODE { size: 4, value: 2 } // OPCODE value 2 represents the command \"umount\"\n\nCREATE_EMPTY_FILE_CMD ::= OPCODE { size: 4, value: 3 } // OPCODE value 3 represents the command \"create empty file\"\n                          SIZE { size: 4 }\n                          FILE_PATH { size: SIZE }\n\nSET_XATTR_CMD ::= OPCODE { size: 4, value: 4 } // OPCODE value 4 represents the command \"set xattr\"\n                  FILEPATH_SIZE { size: 4 }\n                  FILEPATH { size: FILEPATH_SIZE }\n                  NAME_SIZE { size: 4 }\n                  NAME { size: NAME_SIZE }\n                  VALUE_SIZE { size: 4 }\n                  VALUE { size: VALUE_SIZE }\n                  FLAGS { size: 4 }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD].\n\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n\n// CMD will contain one of the five commands available.\n\nCMD   ::= CMD0\n        | CMD1\n        | CMD2\n        | CMD3\n        | CMD4\n\n\n// CMD0 is 'make directory'. It contains size and directory_path.\n\nCMD0  ::= OPCODE { size: 4, value: 0 }\n          SIZE { size: 4 }\n          DIRECTORY_PATH { size: SIZE }\n\n\n// CMD1 'mounts /dev/loop1 to /tmp/ext4 with flags and data(option)\n// It contains flags, size and data.\n\nCMD1  ::= OPCODE { size: 4, value: 1 }\n          FLAGS { size: 4 }\n          SIZE { size: 4 }\n          DATA { size: SIZE }\n\n\n// CMD2 'umounts /tmp/ext4'. It doesn't contain any additional fields.\n\nCMD2  ::= OPCODE { size: 4, value: 2 }\n\n\n// CMD3 'create empty file'. It contains size and filepath.\n\nCMD3  ::= OPCODE { size: 4, value: 3 }\n          SIZE { size: 4 }\n          FILEPATH { size: SIZE }\n\n\n// CMD4 'set xattr to a file'.\n// It contains filepath, name, value and flags each with their own size.\n\nCMD4  ::= OPCODE { size: 4, value: 4 }\n          FILEPATH_SIZE { size: 4 }\n          FILEPATH { size: FILEPATH_SIZE }\n          NAME_SIZE { size: 4 }\n          NAME { size: NAME_SIZE }\n          VALUE_SIZE { size: 4 }\n          VALUE { size: VALUE_SIZE }\n          FLAGS { size: 4 }"
        ]
      },
      "CROMU-00004": {
        "total_runs": 10,
        "success_count": 10,
        "first_success": 0,
        "unique_count": 1,
        "popular_count": 9,
        "syntactically_correct": 10,
        "generated": [
          "INPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\nCMD   ::= CMD1\n\nCMD1  ::= OPCODE { size: 4, value: 0 }\n          WAV_LEN { size: 4 }\n          WAV_DATA { size: WAV_LEN }",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD  ::= CMD1 \n\nCMD1 ::= CMD_ID   { size: 4, value: 0 }\n         WAV_SIZE { size: 4 }\n         WAV_DATA { size: WAV_SIZE }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 if the program has a single command.\nCMD   ::= CMD1\n\nCMD1  ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from the case 0\n          WAV_LEN { size: 4 }  \n          WAV { size: WAV_LEN }  // The size of WAV is WAV_LEN",
          "INPUT ::= CMD_COUNT { size: 4 }\n          CMD[CMD_COUNT]\n\nCMD ::= CMD1\n\nCMD1 ::= COMMAND { size: 4, value: 0 } // COMMAND value 0 is for decoding wav data\n       WAV_LENGTH { size: 4 }\n       WAV_DATA { size: WAV_LENGTH } // the size of WAV_DATA is WAV_LENGTH",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4bytes) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1\nCMD   ::= CMD1 \n\nCMD1  ::= CMD_ID { size: 4, value: 0 } // CMD_ID value 0 comes from the switch statement\n          WAV_LENGTH { size: 4 }       \n          WAV_DATA { size: WAV_LENGTH }     // the size of WAV_DATA is WAV_LENGTH",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4bytes)][CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD0 if the harness function supports the decode_wav data command.\nCMD   ::= CMD0 \n\nCMD0  ::= CMD_ID { size: 4, value: 0 } // CMD_ID value 0 comes from the switch case statement for decode_wav data\n          WAV_SIZE { size: 4 }\n          WAV_DATA { size: WAV_SIZE }",
          "INPUT ::= CMD_CNT { size: 4 } \n          CMD[CMD_CNT]\n\nCMD   ::= CMD1\n\nCMD1  ::= OPCODE { size: 4, value: 0 }\n          WAV_SIZE { size: 4 }\n          WAV_DATA { size: WAV_SIZE }",
          "// INPUT is the start of the input format of the target program\n// INPUT is a command count followed by the count of COMMANDs\nINPUT ::= COMMAND_COUNT { size: 4 }\n          COMMAND[COMMAND_COUNT]    \n\nCOMMAND ::= COMMAND_0 \n\n// There is only one type of command identified by their opcode (0).\nCOMMAND_0  ::= OPCODE { size: 4, value: 0 }\n               DATA_SIZE { size: 4 }\n               DATA { size: DATA_SIZE } ",
          "INPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\nCMD   ::= CMD1\n\nCMD1  ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from the switch statement\n          WAV_LEN { size: 4 }\n          WAV_DATA { size: WAV_LEN }",
          "// INPUT is the start of the input format.\n// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]\nINPUT ::= CMD_CNT { size: 4 }\n          CMD[CMD_CNT]\n\n// CMD will be CMD1 if the opcode is 0\nCMD   ::= CMD1\n\nCMD1  ::= OPCODE { size: 4, value: 0 } // OPCODE value 0 comes from the first case in switch statement\n          WAV_LEN { size: 4 }\n          WAV_DATA { size: WAV_LEN }  // the size of WAV_DATA is WAV_LEN"
        ]
      }
    }
  }
]