When a portion of data is used as a null-terminated character array, we can annotate the field in the grammar with 'type: string'.
HOWEVER, only annotate with 'string' if you know for certain that the data is intended to be used as a string.
For example, if a helper function uses both the character array and size, it may be that the data is not null-terminated since the function explicitly wants the size of the array.
If you are not certain, DO NOT ANNOTATE with 'type: string'.

Test harness:
<harness>
int harness( uint8_t *blob, uint32_t blob_size)
{
  int index = 0;
  uint32_t size = 0;

  char* name = NULL;
  char* data = NULL;
  uint8_t* bytes = NULL;

  if ( blob == NULL ) {
    return -1;
  }
  {
    if ( blob_size - index < 4 ) {
      return -1;
    }
    memcpy(&size, blob + index, 4);
    index += 4;
    if ( blob_size - index < size ) {
      return -1;
    }
    name = blob + index;
    index += size;
    if ( blob_size - index < 4 ) {
      return -1;
    }
    // use name without needing to pass in size
    if (update_name(name) < 0) {
      return -1;
    }
  }
  {
    if ( blob_size - index < 4 ) {
      return -1;
    }
    memcpy(&size, blob + index, 4);
    index += 4;
    if ( blob_size - index < size ) {
      return -1;
    }
    data = blob + index;
    index += size;
    if ( blob_size - index < 4 ) {
      return -1;
    }
    // use data and pass in size
    if (process_data(data, size) < 0) {
      return -1;
    }
  }
  {
    if ( blob_size - index < 4 ) {
      return -1;
    }
    memcpy(&size, blob + index, 4);
    index += 4;
    if ( blob_size - index < size ) {
      return -1;
    }
    bytes = blob + index;
    index += size;
    if ( blob_size - index < 4 ) {
      return -1;
    }
    // use bytes and pass in size
    if (write_bytes(bytes, size) < 0) {
      return -1;
    }
  }
  return 0;
}
</harness>

Test Language:
<testlang>
INPUT ::= UPDATE_NAME
          PROCESS_DATA
          WRITE_BYTES

UPDATE_NAME ::= OPCODE { size: 4, value: 0 }
                SIZE { size: 4 }
                NAME { size: SIZE, type: string }

PROCESS_DATA ::= OPCODE { size: 4, value: 1 }
                 SIZE { size: 4 }
                 DATA { size: SIZE }

WRITE_BYTES ::= OPCODE { size: 4, value: 2 }
                SIZE { size: 4 }
                BYTES { size: SIZE }
</testlang>
