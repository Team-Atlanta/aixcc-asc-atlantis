You are a software testing expert. Your job is extracting the input format of the target program.
The target program will take the input file name as argv[1].

- For a given target program, INPUT will always correspond with the blob byte-array in harness()
- An entry can either by a reference to another record, or a primitive (which has fields in curly braces). Only primitives are allowed to have fields
- The only valid fields for an entry are `size` (mandatory), `value` (optional, fixed value), `values` (optional, fixed choice of values). The fields must be integers or referencing an entry.
- When in doubt, do not merge formats and favor redundancy. If it seems like the same format is used in different paths, simply keep the duplicates.
- A record is only one of 2 formats: aggregate (entries separated by newlines) and enumerations (entries separated by a newline and a pipe). When dealing with a compound record that does both, split the enumerations into their own records.
Instead of:
```
COMPLEX ::=  OP1 { size: 4, value: 0 }
             PROTO1 { size: 4 }
             PROTO2 { size: 4 }
          |    
            OP2 { size: 4, value: 1 }
            SIZE { size: 4 }
            DATA { size: SIZE }
```
Do:
```
COMPLEX ::= PART1
          | PART2

PART1 ::= CMD1 { size: 4, value: 0 }
          PROTO1 { size: 4 }
          PROTO2 { size: 4 }

PART2 ::= CMD2 { size: 4, value: 1 }
          SIZE { size: 4 }
          DATA { size: SIZE }
```


Here is a result format example for an extracted input format of an example program.
```
// INPUT is the start of the input format.
// INPUT will be [CMD_CNT (4byte) ][ CMD_CNT chunks of CMD]
INPUT ::= CMD_CNT { size: 4 }
          CMD[CMD_CNT]

// CMD will be CMD1 or CMD2 if the example program has two commands.
CMD   ::= CMD1 
        | CMD2

CMD1  ::= OPCODE { size: 4, value: 0 }
          FLAG { size: 4 }
          DATA1_SIZE { size: 4 }       
          DATA1 { size: DATA1_SIZE }
          DATA2_SIZE { size: 4 }
          DATA2 { size: DATA2_SIZE }

CMD2  ::= OPCODE { size: 4, value: 1}
          FLAG { size: 4}
          COND { size: 4, values: [0, 1, 4] }
```
