#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>

#define IOC_WATCH_QUEUE_SET_FILTER 0x5761

struct watch_notification_type_filter {
	__u32	type;			/* Type to apply filter to */
	__u32	info_filter;		/* Filter on watch_notification::info */
	__u32	info_mask;		/* Mask of relevant bits in info_filter */
	__u32	subtype_filter[8];	/* Bitmask of subtypes to filter on */
};

struct watch_notification_filter {
	__u32	nr_filters;		/* Number of filters */
	__u32	__reserved;		/* Must be 0 */
	struct watch_notification_type_filter filters[];
};


int harness( uint8_t *blob, uint32_t blob_size)
{
  int index = 0;
  uint32_t size = 0;

  int pipefds[2] = {-1, -1};
  int pipe_flags = 0;
  int fd = -1;

  uint32_t nr_filters = 0;
  uint32_t reserved = 0;
  uint32_t type = 0;

  if ( blob == NULL ) {
    return -1;
  }

  //Get pipe_flags
  if ( blob_size < 4 ) {
    return -1;
  }
  memcpy(&pipe_flags, blob + index, 4);
  index += 4;

  //open pipe
  if(pipe2(pipefds, pipe_flags)) {
    return -1;
  }
  fd = pipefds[0];


  //Get nr_filters
  if ( blob_size < 4 ) {
    close(pipefds[0]);
    close(pipefds[1]);
    return -1;
  }
  memcpy(&nr_filters, blob + index, 4);
  index += 4;

  //Get reserved
  if ( blob_size < 4 ) {
    close(pipefds[0]);
    close(pipefds[1]);
    return -1;
  }
  memcpy(&reserved, blob + index, 4);
  index += 4;

  //Get type
  if ( blob_size < 4 ) {
    close(pipefds[0]);
    close(pipefds[1]);
    return -1;
  }
  memcpy(&type, blob + index, 4);
  index += 4;

  struct watch_notification_filter *filter =
    malloc(sizeof(struct watch_notification_filter) +
        sizeof(struct watch_notification_type_filter));

  filter->nr_filters = 1;
  filter->__reserved = 0;
  filter->filters[0] = (struct watch_notification_type_filter){ .type = 511 };

  ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, filter);

  close(pipefds[0]);
  close(pipefds[1]);

  return 0;
}

int main(int argc, char *argv[])
{
  char *blob = NULL;
  struct stat st;
  int fd;

  if (argc < 2) {
    printf("Need file\n");
    return -1;
  }

  if ( stat(argv[1], &st) != 0) {
    printf("Failed to stat file\n");
    return -1;
  }

  fd = open(argv[1], O_RDONLY);

  if ( fd < 0 ) {
    printf("[ERROR] Failed to open file\n");
    return -1;
  }

  blob = malloc(st.st_size);

  if ( blob == NULL ) {
    return 0;
  }

  read(fd, blob, st.st_size);

  close(fd);

  harness(blob, st.st_size);

  return 0;
}
