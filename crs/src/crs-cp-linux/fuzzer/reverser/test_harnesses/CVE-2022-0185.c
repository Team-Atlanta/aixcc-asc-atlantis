#define _GNU_SOURCE
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <err.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sched.h>

#include <sys/syscall.h>


#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#define FSCONFIG_SET_FLAG 0
#define FSCONFIG_SET_STRING 1
#define FSCONFIG_SET_BINARY 2
#define FSCONFIG_SET_PATH 3
#define FSCONFIG_SET_PATH_EMPTY 4
//#define FSCONFIG_SET_FD 5
#define FSCONFIG_CMD_CREATE 5
#define FSCONFIG_CMD_RECONFIGURE 6


void unshare_setup(uid_t uid, gid_t gid)
{
  int temp;
  char edit[0x100];

  unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);

  temp = open("/proc/self/setgroups", O_WRONLY);
  write(temp, "deny", strlen("deny"));
  close(temp);

  temp = open("/proc/self/uid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", uid);
  write(temp, edit, strlen(edit));
  close(temp);

  temp = open("/proc/self/gid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", gid);
  write(temp, edit, strlen(edit));
  close(temp);

  return;
}

/***
 * Blob begins with a 4 byte command count
 * [4-bytes command count]
 * Currently there are seven commands:
 *  FSCONFIG_SET_FLAG         - call syscall __NR_fsconfig cmd=FSCONFIG_SET_FLAG
 *                              [4-bytes size][size-bytes flag_params data]
 *  FSCONFIG_SET_STRING       - call syscall __NR_fsconfig cmd=FSCONFIG_SET_STRING
 *                              [4-bytes key_size][key_size-bytes key data][4-bytes value_size][value_size-bytes value data]
 *  FSCONFIG_SET_BINARY       - call syscall __NR_fsconfig cmd=FSCONFIG_SET_BINARY
 *                              [4-bytes key_size][key_size-bytes key data][4-bytes value_size][value_size-bytes value data]
 *  FSCONFIG_SET_PATH         - call syscall __NR_fsconfig cmd=FSCONFIG_VSET_PATH
 *                              [4-bytes key_size][key_size-bytes key data][4-bytes filename_size][value_size-bytes filename data]
 *  FSCONFIG_SET_PATH_EMPTY   - call syscall __NR_fsconfig cmd=FSCONFIG_SET_PATH_EMPTY
 *                              [4-bytes key_size][key_size-bytes key data][4-bytes filename_size][value_size-bytes filename data]
 *  FSCONFIG_CMD_CREATE       - call syscall __NR_fsconfig cmd=FSCONFIG_CMD_CREATE
 *                              [None]
 *  FSCONFIG_CMD_RECONFIGURE  - call syscall __NR_fsconfig cmd=FSCONFIG_CMD_RECONFIGURE
 *                              [None]
 *
 * blob_size MUST be a trusted value
 */

//FSCONFIG_SET_FD was not used in this harness!
int harness( uint8_t *blob, uint32_t blob_size)
{
  int fd = -1;
  int index = 0;
  uint32_t command, command_count = 0;
  uint32_t size = 0;
  uint32_t size2 = 0;
  uint8_t* ptr = NULL;
  const char* cmd[8] = {"FSCONFIG_SET_FLAG", "FSCONFIG_SET_STRING", "FSCONFIG_SET_BINARY", "FSCONFIG_SET_PATH", "FSCONFIG_SET_PATH_EMPTY", "FSCONFIG_SET_FD", "FSCONFIG_CMD_CREATE", "FSCONFIG_CMD_RECONFIGURE"};

  printf("[INFO] harness blob_size %u \n", blob_size);

  if ( blob == NULL ) {
    return -1;
  }

  unshare_setup(getuid(), getgid());

  if((fd = syscall(__NR_fsopen, "9p", 0)) < 0) {
    printf("[ERROR] unable to fsopen! \n");
    return -1;
  }

  if ( blob_size < 4 ) {
    close(fd);
    return -1;
  }

  memcpy(&command_count, blob, 4);
  index += 4;

  printf("[INFO] Executing %d commands\n", command_count);
  for ( uint32_t i = 0; i < command_count; i++) {
    if ( blob_size - index < 4 ) {
      printf("[ERROR] ran out of commands\n");
      close(fd);
      return -1;
    }

    memcpy(&command, blob + index, 4);
    index += 4;

    switch ( command ) {
      case FSCONFIG_SET_FLAG:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] FSCONFIG_SET_FLAG error\n");
          close(fd);
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] FSCONFIG_SET_FLAG error\n");
          close(fd);
          return -1;
        }
        if (syscall(__NR_fsconfig, fd, command, blob + index, 0, 0) < 0) {
          printf("[ERROR] FSCONFIG_SET_FLAG error\n");
          close(fd);
          return -1;
        }
        index += size;
        break;
      case FSCONFIG_SET_STRING:
      case FSCONFIG_SET_PATH:
      case FSCONFIG_SET_PATH_EMPTY:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] %s error\n", cmd[command]);
          close(fd);
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] %s error\n", cmd[command]);
          close(fd);
          return -1;
        }
        ptr = blob + index;
        index += size;
        if ( blob_size - index < 4 ) {
          printf("[ERROR] %s error\n", cmd[command]);
          close(fd);
          return -1;
        }
        memcpy(&size2, blob + index, 4);
        index += 4;
        if ( blob_size - index < size2 ) {
          printf("[ERROR] %s error\n", cmd[command]);
          close(fd);
          return -1;
        }
        if (syscall(__NR_fsconfig, fd, command, ptr, blob + index, 0) < 0) {
          printf("[ERROR] %s syscall error. fd %d ptr %s blob + index %s\n", cmd[command], fd, ptr, blob+index);
          close(fd);
          return -1;
        }
        index += size2;
        break;
      case FSCONFIG_SET_BINARY:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] FSCONFIG_SET_BINARY error\n");
          close(fd);
          return -1;
        }
        memcpy(&size, blob + index, 4);
        index += 4;
        if ( blob_size - index < size ) {
          printf("[ERROR] FSCONFIG_SET_BINARY error\n");
          close(fd);
          return -1;
        }
        ptr = blob + index;
        index += size;
        if ( blob_size - index < 4 ) {
          printf("[ERROR] FSCONFIG_SET_BINARY error\n");
          close(fd);
          return -1;
        }
        memcpy(&size2, blob + index, 4);
        index += 4;
        if ( blob_size - index < size2 ) {
          printf("[ERROR] FSCONFIG_SET_BINARY error\n");
          close(fd);
          return -1;
        }
        if (syscall(__NR_fsconfig, fd, command, ptr, blob + index, size2) < 0) {
          printf("[ERROR] FSCONFIG_SET_BINARY error\n");
          close(fd);
          return -1;
        }
        index += size2;
        break;
      case FSCONFIG_CMD_CREATE:
      case FSCONFIG_CMD_RECONFIGURE:
        if (syscall(__NR_fsconfig, fd, command, 0, 0, 0) < 0) {
          printf("[ERROR] %s error\n", cmd[command]);
          close(fd);
          return -1;
        }
        break;
      default:
        printf("[ERROR] Unknown command: %x\n", command);
        return -1;
    }
  }

  close(fd);
  return 0;
}

int main(int argc, char *argv[])
{
  char *blob = NULL;
  struct stat st;
  int fd;

  printf("[INFO] main start! \n");

  if (argc < 2) {
    printf("Need file\n");
    return -1;
  }

  if ( stat(argv[1], &st) != 0) {
    printf("Failed to stat file\n");
    return -1;
  }

  fd = open(argv[1], O_RDONLY);

  if ( fd < 0 ) {
    printf("[ERROR] Failed to open file\n");
    return -1;
  }

  blob = malloc(st.st_size);

  if ( blob == NULL ) {
    printf("[ERROR] malloc failed! \n");
    return 0;
  }

  read(fd, blob, st.st_size);

  close(fd);

  harness(blob, st.st_size);

  return 0;
}
