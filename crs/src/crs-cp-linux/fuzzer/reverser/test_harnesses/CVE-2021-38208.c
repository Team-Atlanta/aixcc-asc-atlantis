#define _GNU_SOURCE
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <err.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sched.h>
#include <errno.h>

#include <sys/syscall.h>

#define MAX_IDENTIFIER 100
#define UNINITIALIZED_SOCKET -2

int sockets[MAX_IDENTIFIER];

void init_sockets_array(){
  for(int i = 0; i < MAX_IDENTIFIER; i++){
    sockets[i] = UNINITIALIZED_SOCKET;
  }
}

int valid_identifier_get(int identifier){
  if(identifier < 0 || identifier >= MAX_IDENTIFIER){
    printf("[ERROR] identifier(%d) out of range! need to be between 0 and %d \n", identifier, MAX_IDENTIFIER - 1);
    return 0;
  }
  if(sockets[identifier] == UNINITIALIZED_SOCKET){
    printf("[ERROR] identifier(%d) was not initialized \n", identifier);
    return 0;
  }
  return 1;
}

int valid_identifier_set(int identifier){
  if(identifier < 0 || identifier >= MAX_IDENTIFIER){
    printf("[ERROR] identifier(%d) out of range! need to be between 0 and %d \n", identifier, MAX_IDENTIFIER - 1);
    return 0;
  }
  if(sockets[identifier] != UNINITIALIZED_SOCKET){
    printf("[ERROR] identifier(%d) is already initialized \n", identifier);
    return 0;
  }
  return 1;
}

/***
 * Blob begins with a 4 byte command count
 * [4-bytes command count]
 * Currently there are four commands:
 *  0   - call socket. identifier is used for testing only. the created socket can be used later using the identifier(0~99)
 *        [4-bytes identifier][4-bytes domain][4-bytes type][4-bytes protocol]
 *  1   - call bind to a socket identified by identifier
 *        [4-bytes identifier][4-bytes size][size-bytes addr data]
 *  2   - call listen to a socket identified by identifier
 *        [4-bytes identifier][4-bytes backlog]
 *  3   - call getpeername to a socket identified by identifier
 *        [4-bytes identifier]
 *
 * blob_size MUST be a trusted value
 */

int harness( uint8_t *blob, uint32_t blob_size)
{
  int index = 0;
  uint32_t command, command_count = 0;
  uint32_t size = 0;
  const char* cmd[4] = {"socket", "bind", "listen", "getpeername"};
  int identifier = 0;
  int domain = 0;
  int type = 0;
  int protocol = 0;
  int backlog = 0;
  char output_msg[100] = {};

  printf("[INFO] harness blob_size %u \n", blob_size);

  if ( blob == NULL ) {
    return -1;
  }

  init_sockets_array();

  if ( blob_size < 4 ) {
    return -1;
  }

  memcpy(&command_count, blob, 4);
  index += 4;

  printf("[INFO] Executing %d commands\n", command_count);
  for ( uint32_t i = 0; i < command_count; i++) {
    if ( blob_size - index < 4 ) {
      printf("[ERROR] ran out of commands\n");
      return -1;
    }

    memcpy(&command, blob + index, 4);
    index += 4;

    switch ( command ) {
      case 0:
        if ( blob_size - index < 16 ) {
          printf("[ERROR] %s error. lack of remaining blob\n", cmd[command]);
          return -1;
        }
        memcpy(&identifier, blob + index, 4);
        memcpy(&domain, blob + index + 4, 4);
        memcpy(&type, blob + index + 8, 4);
        memcpy(&protocol, blob + index + 12, 4);
        index += 16;
        if (valid_identifier_set(identifier) == 0) {
          printf("[ERROR] %s error. wrong identifier \n", cmd[command]);
          return -1;
        }
        sockets[identifier] = syscall(__NR_socket, domain, type, protocol);
        if (sockets[identifier] < 0) {
          printf("[ERROR] %s error. syscall error. domain %x type %d proto %d \n", cmd[command], domain, type, protocol);
          printf("[ERROR] %s \n", strerror(errno));
          return -1;
        }
        break;
      case 1:
        if ( blob_size - index < 8 ) {
          printf("[ERROR] %s error. lack of remaining blob\n", cmd[command]);
          return -1;
        }
        memcpy(&identifier, blob + index, 4);
        memcpy(&size, blob + index + 4, 4);
        index += 8;
        if ( blob_size - index < size ) {
          printf("[ERROR] %s error. lack of remaining blob\n", cmd[command]);
          return -1;
        }
        if (valid_identifier_get(identifier) == 0){
          printf("[ERROR] %s error. wrong identifier \n", cmd[command]);
          return -1;
        }
        syscall(__NR_bind, sockets[identifier], blob + index, size);
        /*
        if (syscall(__NR_bind, sockets[identifier], blob + index, size) < 0) {
          printf("[ERROR] %s error. syscall error\n", cmd[command]);
          return -1;
        }
        */
        index += size;
        break;
      case 2:
        if ( blob_size - index < 8 ) {
          printf("[ERROR] %s error. lack of remaining blob\n", cmd[command]);
          return -1;
        }
        memcpy(&identifier, blob + index, 4);
        memcpy(&backlog, blob + index + 4, 4);
        index += 8;
        if (valid_identifier_get(identifier) == 0){
          printf("[ERROR] %s error. wrong identifier \n", cmd[command]);
          return -1;
        }
        if (syscall(__NR_listen, sockets[identifier], backlog) < 0) {
          printf("[ERROR] %s error. syscall error\n", cmd[command]);
          return -1;
        }
        break;
      case 3:
        if ( blob_size - index < 4 ) {
          printf("[ERROR] %s error. lack of remaining blob\n", cmd[command]);
          return -1;
        }
        memcpy(&identifier, blob + index, 4);
        index += 4;
        if (valid_identifier_get(identifier) == 0){
          printf("[ERROR] %s error. wrong identifier \n", cmd[command]);
          return -1;
        }
        if (syscall(__NR_getpeername, sockets[identifier], output_msg, sizeof(output_msg)) < 0) {
          printf("[ERROR] %s error. syscall error\n", cmd[command]);
          return -1;
        }
        break;
      default:
        printf("[ERROR] Unknown command: %x\n", command);
        return -1;
    }
  }

  return 0;
}

int main(int argc, char *argv[])
{
  char *blob = NULL;
  struct stat st;
  int fd;

  printf("[INFO] main start! \n");

  if (argc < 2) {
    printf("Need file\n");
    return -1;
  }

  if ( stat(argv[1], &st) != 0) {
    printf("Failed to stat file\n");
    return -1;
  }

  fd = open(argv[1], O_RDONLY);

  if ( fd < 0 ) {
    printf("[ERROR] Failed to open file\n");
    return -1;
  }

  blob = malloc(st.st_size);

  if ( blob == NULL ) {
    printf("[ERROR] malloc failed! \n");
    return 0;
  }

  read(fd, blob, st.st_size);

  close(fd);

  harness(blob, st.st_size);

  return 0;
}
