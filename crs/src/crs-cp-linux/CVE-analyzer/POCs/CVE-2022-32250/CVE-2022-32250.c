// gcc exp.c -o exp -l mnl -l nftnl -w
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>


void bye(char *info)
{
  exit(-2);
}

void do_error_exit(char *info)
{
  exit(-1);
}

void set_table_and_set(struct mnl_socket* nl, const char *name)
{
  const char * table_name = name;
  char * set_name = NULL;
  uint8_t family = NFPROTO_IPV4;
  uint32_t set_id = 1;

  // a table for the sets to be associated with
  struct nftnl_table * table = nftnl_table_alloc();
  nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
  nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

  struct nftnl_set * set_stable =  nftnl_set_alloc();
  set_name = "set0";
  nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);
  nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);
  nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, 1);
  nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);
  nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);

  // expressions
  struct nftnl_expr * exprs[128];
  int exprid = 0;

  // serialize
  char buf[MNL_SOCKET_BUFFER_SIZE*2];

  struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  int seq = 0;

  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  struct nlmsghdr * nlh;
  int table_seq = seq;

  nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);
  nftnl_table_nlmsg_build_payload(nlh, table);
  mnl_nlmsg_batch_next(batch);

  // add set_stable
  nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWSET, family,
      NLM_F_CREATE|NLM_F_ACK, seq++);
  nftnl_set_nlmsg_build_payload(nlh, set_stable);
  nftnl_set_free(set_stable);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  if (nl == NULL) {
    err(1, "mnl_socket_open");
  }

  printf("[+] setting stable %s and set\n", table_name);
  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch)) < 0) {
    err(1, "mnl_socket_send");
  }
}

void set_expr_lookup(struct mnl_socket* nl, const char *name, const char *set_name)
{
  const char * table_name = name;
  uint8_t family = NFPROTO_IPV4;
  uint32_t set_id = 1;
  struct nftnl_expr * exprs[128];
  int exprid = 0;
  struct nlmsghdr * nlh;

  struct nftnl_set * new_set = nftnl_set_alloc();

  nftnl_set_set_str(new_set, NFTNL_SET_TABLE, table_name);
  nftnl_set_set_str(new_set, NFTNL_SET_NAME, set_name);
  nftnl_set_set_u32(new_set, NFTNL_SET_FLAGS, NFT_SET_EXPR);
  nftnl_set_set_u32(new_set, NFTNL_SET_KEY_LEN, 1);
  nftnl_set_set_u32(new_set, NFTNL_SET_FAMILY, family);
  nftnl_set_set_u32(new_set, NFTNL_SET_ID, set_id);
  exprs[exprid] = nftnl_expr_alloc("lookup");
  nftnl_expr_set_str(exprs[exprid], NFTNL_EXPR_LOOKUP_SET, "set0");
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
  nftnl_set_add_expr(new_set, exprs[exprid]);
  exprid++;

  char buf[MNL_SOCKET_BUFFER_SIZE*2];

  struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  int seq = 0;

  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
      NFT_MSG_NEWSET, family,
      NLM_F_CREATE|NLM_F_ACK, seq++);
  nftnl_set_nlmsg_build_payload(nlh, new_set);
  nftnl_set_free(new_set);
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  if (nl == NULL) {
    err(1, "mnl_socket_open");
  }

  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch)) < 0) {
    err(1, "mnl_socket_send");
  }
}

int main(int argc, char ** argv)
{
  struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);

  set_table_and_set(nl, "table1");
  set_expr_lookup(nl, "table1", "set1");
  set_expr_lookup(nl, "table1", "set2");

  return 0;
}
