diff --git a/arch/x86/lib/insn-eval.c b/arch/x86/lib/insn-eval.c
index 306c3a0902ba..cf00ab6c6621 100644
--- a/arch/x86/lib/insn-eval.c
+++ b/arch/x86/lib/insn-eval.c
@@ -557,8 +557,7 @@ static int get_reg_offset_16(struct insn *insn, struct pt_regs *regs,
 }
 
 /**
- * get_desc() - Obtain contents of a segment descriptor
- * @out:	Segment descriptor contents on success
+ * get_desc() - Obtain pointer to a segment descriptor
  * @sel:	Segment selector
  *
  * Given a segment selector, obtain a pointer to the segment descriptor.
@@ -566,18 +565,18 @@ static int get_reg_offset_16(struct insn *insn, struct pt_regs *regs,
  *
  * Returns:
  *
- * True on success, false on failure.
+ * Pointer to segment descriptor on success.
  *
  * NULL on error.
  */
-static bool get_desc(struct desc_struct *out, unsigned short sel)
+static struct desc_struct *get_desc(unsigned short sel)
 {
 	struct desc_ptr gdt_desc = {0, 0};
 	unsigned long desc_base;
 
 #ifdef CONFIG_MODIFY_LDT_SYSCALL
 	if ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {
-		bool success = false;
+		struct desc_struct *desc = NULL;
 		struct ldt_struct *ldt;
 
 		/* Bits [15:3] contain the index of the desired entry. */
@@ -585,14 +584,12 @@ static bool get_desc(struct desc_struct *out, unsigned short sel)
 
 		mutex_lock(&current->active_mm->context.lock);
 		ldt = current->active_mm->context.ldt;
-		if (ldt && sel < ldt->nr_entries) {
-			*out = ldt->entries[sel];
-			success = true;
-		}
+		if (ldt && sel < ldt->nr_entries)
+			desc = &ldt->entries[sel];
 
 		mutex_unlock(&current->active_mm->context.lock);
 
-		return success;
+		return desc;
 	}
 #endif
 	native_store_gdt(&gdt_desc);
@@ -607,10 +604,9 @@ static bool get_desc(struct desc_struct *out, unsigned short sel)
 	desc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);
 
 	if (desc_base > gdt_desc.size)
-		return false;
+		return NULL;
 
-	*out = *(struct desc_struct *)(gdt_desc.address + desc_base);
-	return true;
+	return (struct desc_struct *)(gdt_desc.address + desc_base);
 }
 
 /**
@@ -632,7 +628,7 @@ static bool get_desc(struct desc_struct *out, unsigned short sel)
  */
 unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
 {
-	struct desc_struct desc;
+	struct desc_struct *desc;
 	short sel;
 
 	sel = get_segment_selector(regs, seg_reg_idx);
@@ -670,10 +666,11 @@ unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
 	if (!sel)
 		return -1L;
 
-	if (!get_desc(&desc, sel))
+	desc = get_desc(sel);
+	if (!desc)
 		return -1L;
 
-	return get_desc_base(&desc);
+	return get_desc_base(desc);
 }
 
 /**
@@ -695,7 +692,7 @@ unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
  */
 static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
 {
-	struct desc_struct desc;
+	struct desc_struct *desc;
 	unsigned long limit;
 	short sel;
 
@@ -709,7 +706,8 @@ static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
 	if (!sel)
 		return 0;
 
-	if (!get_desc(&desc, sel))
+	desc = get_desc(sel);
+	if (!desc)
 		return 0;
 
 	/*
@@ -718,8 +716,8 @@ static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
 	 * not tested when checking the segment limits. In practice,
 	 * this means that the segment ends in (limit << 12) + 0xfff.
 	 */
-	limit = get_desc_limit(&desc);
-	if (desc.g)
+	limit = get_desc_limit(desc);
+	if (desc->g)
 		limit = (limit << 12) + 0xfff;
 
 	return limit;
@@ -743,7 +741,7 @@ static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
  */
 int insn_get_code_seg_params(struct pt_regs *regs)
 {
-	struct desc_struct desc;
+	struct desc_struct *desc;
 	short sel;
 
 	if (v8086_mode(regs))
@@ -754,7 +752,8 @@ int insn_get_code_seg_params(struct pt_regs *regs)
 	if (sel < 0)
 		return sel;
 
-	if (!get_desc(&desc, sel))
+	desc = get_desc(sel);
+	if (!desc)
 		return -EINVAL;
 
 	/*
@@ -762,10 +761,10 @@ int insn_get_code_seg_params(struct pt_regs *regs)
 	 * determines whether a segment contains data or code. If this is a data
 	 * segment, return error.
 	 */
-	if (!(desc.type & BIT(3)))
+	if (!(desc->type & BIT(3)))
 		return -EINVAL;
 
-	switch ((desc.l << 1) | desc.d) {
+	switch ((desc->l << 1) | desc->d) {
 	case 0: /*
 		 * Legacy mode. CS.L=0, CS.D=0. Address and operand size are
 		 * both 16-bit.
