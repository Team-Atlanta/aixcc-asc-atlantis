diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index f9dbf41fc803..439a5bf5ebc6 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -3732,9 +3732,7 @@ static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)
 	}
 
 	/* update qgroup status and info */
-	mutex_lock(&fs_info->qgroup_ioctl_lock);
 	err = btrfs_run_qgroups(trans);
-	mutex_unlock(&fs_info->qgroup_ioctl_lock);
 	if (err < 0)
 		btrfs_handle_fs_error(fs_info, err,
 				      "failed to update qgroup status and info");
diff --git a/fs/btrfs/qgroup.c b/fs/btrfs/qgroup.c
index f41da7ac360d..52a7d2fa2284 100644
--- a/fs/btrfs/qgroup.c
+++ b/fs/btrfs/qgroup.c
@@ -2828,22 +2828,13 @@ int btrfs_qgroup_account_extents(struct btrfs_trans_handle *trans)
 }
 
 /*
- * Writes all changed qgroups to disk.
- * Called by the transaction commit path and the qgroup assign ioctl.
+ * called from commit_transaction. Writes all changed qgroups to disk.
  */
 int btrfs_run_qgroups(struct btrfs_trans_handle *trans)
 {
 	struct btrfs_fs_info *fs_info = trans->fs_info;
 	int ret = 0;
 
-	/*
-	 * In case we are called from the qgroup assign ioctl, assert that we
-	 * are holding the qgroup_ioctl_lock, otherwise we can race with a quota
-	 * disable operation (ioctl) and access a freed quota root.
-	 */
-	if (trans->transaction->state != TRANS_STATE_COMMIT_DOING)
-		lockdep_assert_held(&fs_info->qgroup_ioctl_lock);
-
 	if (!fs_info->quota_root)
 		return ret;
 
