diff --git a/drivers/md/dm-snap-persistent.c b/drivers/md/dm-snap-persistent.c
index 2d2b1b7588d7..4caa8e6d59d7 100644
--- a/drivers/md/dm-snap-persistent.c
+++ b/drivers/md/dm-snap-persistent.c
@@ -269,14 +269,6 @@ static chunk_t area_location(struct pstore *ps, chunk_t area)
 	return NUM_SNAPSHOT_HDR_CHUNKS + ((ps->exceptions_per_area + 1) * area);
 }
 
-static void skip_metadata(struct pstore *ps)
-{
-	uint32_t stride = ps->exceptions_per_area + 1;
-	chunk_t next_free = ps->next_free;
-	if (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)
-		ps->next_free++;
-}
-
 /*
  * Read or write a metadata area.  Remembering to skip the first
  * chunk which holds the header.
@@ -510,8 +502,6 @@ static int read_exceptions(struct pstore *ps,
 
 	ps->current_area--;
 
-	skip_metadata(ps);
-
 	return 0;
 }
 
@@ -626,6 +616,8 @@ static int persistent_prepare_exception(struct dm_exception_store *store,
 					struct dm_exception *e)
 {
 	struct pstore *ps = get_info(store);
+	uint32_t stride;
+	chunk_t next_free;
 	sector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);
 
 	/* Is there enough room ? */
@@ -638,8 +630,10 @@ static int persistent_prepare_exception(struct dm_exception_store *store,
 	 * Move onto the next free pending, making sure to take
 	 * into account the location of the metadata chunks.
 	 */
-	ps->next_free++;
-	skip_metadata(ps);
+	stride = (ps->exceptions_per_area + 1);
+	next_free = ++ps->next_free;
+	if (sector_div(next_free, stride) == 1)
+		ps->next_free++;
 
 	atomic_inc(&ps->pending_count);
 	return 0;
