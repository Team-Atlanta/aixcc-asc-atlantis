diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index 22f3d768b459..151b6e48b81f 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -130,7 +130,6 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 	struct flow_dissector_key_tags *key_tags;
 	struct flow_dissector_key_keyid *key_keyid;
 	u8 ip_proto = 0;
-	bool ret = false;
 
 	if (!data) {
 		data = skb->data;
@@ -172,7 +171,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 ip:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph || iph->ihl < 5)
-			goto out_bad;
+			return false;
 		nhoff += iph->ihl * 4;
 
 		ip_proto = iph->protocol;
@@ -198,7 +197,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 ipv6:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph)
-			goto out_bad;
+			return false;
 
 		ip_proto = iph->nexthdr;
 		nhoff += sizeof(struct ipv6hdr);
@@ -235,7 +234,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 
 		vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);
 		if (!vlan)
-			goto out_bad;
+			return false;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_VLANID)) {
@@ -257,7 +256,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
-			goto out_bad;
+			return false;
 		proto = hdr->proto;
 		nhoff += PPPOE_SES_HLEN;
 		switch (proto) {
@@ -266,7 +265,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 		case htons(PPP_IPV6):
 			goto ipv6;
 		default:
-			goto out_bad;
+			return false;
 		}
 	}
 	case htons(ETH_P_TIPC): {
@@ -276,7 +275,9 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
-			goto out_bad;
+			return false;
+		key_basic->n_proto = proto;
+		key_control->thoff = (u16)nhoff;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {
@@ -286,7 +287,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 			key_addrs->tipcaddrs.srcnode = hdr->srcnode;
 			key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;
 		}
-		goto out_good;
+		return true;
 	}
 
 	case htons(ETH_P_MPLS_UC):
@@ -296,7 +297,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,
 					   hlen, &_hdr);
 		if (!hdr)
-			goto out_bad;
+			return false;
 
 		if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>
 		     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {
@@ -309,17 +310,21 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 					htonl(MPLS_LS_LABEL_MASK);
 			}
 
-			goto out_good;
+			key_basic->n_proto = proto;
+			key_basic->ip_proto = ip_proto;
+			key_control->thoff = (u16)nhoff;
+
+			return true;
 		}
 
-		goto out_good;
+		return true;
 	}
 
 	case htons(ETH_P_FCOE):
 		key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);
 		/* fall through */
 	default:
-		goto out_bad;
+		return false;
 	}
 
 ip_proto_again:
@@ -332,7 +337,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
-			goto out_bad;
+			return false;
 		/*
 		 * Only look inside GRE if version zero and no
 		 * routing
@@ -352,7 +357,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 						     data, hlen, &_keyid);
 
 			if (!keyid)
-				goto out_bad;
+				return false;
 
 			if (skb_flow_dissector_uses_key(flow_dissector,
 							FLOW_DISSECTOR_KEY_GRE_KEYID)) {
@@ -373,7 +378,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 						   sizeof(_eth),
 						   data, hlen, &_eth);
 			if (!eth)
-				goto out_bad;
+				return false;
 			proto = eth->h_proto;
 			nhoff += sizeof(*eth);
 		}
@@ -390,7 +395,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 		opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),
 					      data, hlen, &_opthdr);
 		if (!opthdr)
-			goto out_bad;
+			return false;
 
 		ip_proto = opthdr[0];
 		nhoff += (opthdr[1] + 1) << 3;
@@ -410,6 +415,10 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 		break;
 	}
 
+	key_basic->n_proto = proto;
+	key_basic->ip_proto = ip_proto;
+	key_control->thoff = (u16)nhoff;
+
 	if (skb_flow_dissector_uses_key(flow_dissector,
 					FLOW_DISSECTOR_KEY_PORTS)) {
 		key_ports = skb_flow_dissector_target(flow_dissector,
@@ -419,15 +428,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,
 							data, hlen);
 	}
 
-out_good:
-	ret = true;
-
-out_bad:
-	key_basic->n_proto = proto;
-	key_basic->ip_proto = ip_proto;
-	key_control->thoff = (u16)nhoff;
-
-	return ret;
+	return true;
 }
 EXPORT_SYMBOL(__skb_flow_dissect);
 
