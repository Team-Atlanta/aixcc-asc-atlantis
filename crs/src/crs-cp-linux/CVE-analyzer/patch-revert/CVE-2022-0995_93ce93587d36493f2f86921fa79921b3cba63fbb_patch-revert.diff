--- b/fs/afs/write.c
+++ a/fs/afs/write.c
@@ -703,7 +703,7 @@
 	struct folio *folio;
 	struct page *head_page;
 	ssize_t ret;
+	int n;
-	int n, skips = 0;
 
 	_enter("%llx,%llx,", start, end);
 
@@ -754,15 +754,8 @@
 #ifdef CONFIG_AFS_FSCACHE
 				folio_wait_fscache(folio);
 #endif
-			} else {
-				start += folio_size(folio);
 			}
 			folio_put(folio);
-			if (wbc->sync_mode == WB_SYNC_NONE) {
-				if (skips >= 5 || need_resched())
-					break;
-				skips++;
-			}
 			continue;
 		}
 
--- b/fs/cachefiles/xattr.c
+++ a/fs/cachefiles/xattr.c
@@ -28,11 +28,6 @@
 static const char cachefiles_xattr_cache[] =
 	XATTR_USER_PREFIX "CacheFiles.cache";
 
-struct cachefiles_vol_xattr {
-	__be32	reserved;	/* Reserved, should be 0 */
-	__u8	data[];		/* netfs volume coherency data */
-} __packed;
-
 /*
  * set the state xattr on a cache file
  */
@@ -190,7 +185,6 @@
  */
 bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume)
 {
-	struct cachefiles_vol_xattr *buf;
 	unsigned int len = volume->vcookie->coherency_len;
 	const void *p = volume->vcookie->coherency;
 	struct dentry *dentry = volume->dentry;
@@ -198,17 +192,10 @@
 
 	_enter("%x,#%d", volume->vcookie->debug_id, len);
 
-	len += sizeof(*buf);
-	buf = kmalloc(len, GFP_KERNEL);
-	if (!buf)
-		return false;
-	buf->reserved = cpu_to_be32(0);
-	memcpy(buf->data, p, len);
-
 	ret = cachefiles_inject_write_error();
 	if (ret == 0)
 		ret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache,
+				   p, len, 0);
-				   buf, len, 0);
 	if (ret < 0) {
 		trace_cachefiles_vfs_error(NULL, d_inode(dentry), ret,
 					   cachefiles_trace_setxattr_error);
@@ -222,7 +209,6 @@
 					       cachefiles_coherency_vol_set_ok);
 	}
 
-	kfree(buf);
 	_leave(" = %d", ret);
 	return ret == 0;
 }
@@ -232,7 +218,7 @@
  */
 int cachefiles_check_volume_xattr(struct cachefiles_volume *volume)
 {
+	struct cachefiles_xattr *buf;
-	struct cachefiles_vol_xattr *buf;
 	struct dentry *dentry = volume->dentry;
 	unsigned int len = volume->vcookie->coherency_len;
 	const void *p = volume->vcookie->coherency;
@@ -242,7 +228,6 @@
 
 	_enter("");
 
-	len += sizeof(*buf);
 	buf = kmalloc(len, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
@@ -260,9 +245,7 @@
 					"Failed to read xattr with error %zd", xlen);
 		}
 		why = cachefiles_coherency_vol_check_xattr;
+	} else if (memcmp(buf->data, p, len) != 0) {
-	} else if (buf->reserved != cpu_to_be32(0)) {
-		why = cachefiles_coherency_vol_check_resv;
-	} else if (memcmp(buf->data, p, len - sizeof(*buf)) != 0) {
 		why = cachefiles_coherency_vol_check_cmp;
 	} else {
 		why = cachefiles_coherency_vol_check_ok;
--- b/fs/pipe.c
+++ a/fs/pipe.c
@@ -253,8 +253,7 @@
 	 */
 	was_full = pipe_full(pipe->head, pipe->tail, pipe->max_usage);
 	for (;;) {
+		unsigned int head = pipe->head;
-		/* Read ->head with a barrier vs post_one_notification() */
-		unsigned int head = smp_load_acquire(&pipe->head);
 		unsigned int tail = pipe->tail;
 		unsigned int mask = pipe->ring_size - 1;
 
@@ -832,8 +831,10 @@
 	int i;
 
 #ifdef CONFIG_WATCH_QUEUE
+	if (pipe->watch_queue) {
-	if (pipe->watch_queue)
 		watch_queue_clear(pipe->watch_queue);
+		put_watch_queue(pipe->watch_queue);
+	}
 #endif
 
 	(void) account_pipe_buffers(pipe->user, pipe->nr_accounted, 0);
@@ -843,10 +844,6 @@
 		if (buf->ops)
 			pipe_buf_release(pipe, buf);
 	}
-#ifdef CONFIG_WATCH_QUEUE
-	if (pipe->watch_queue)
-		put_watch_queue(pipe->watch_queue);
-#endif
 	if (pipe->tmp_page)
 		__free_page(pipe->tmp_page);
 	kfree(pipe->bufs);
--- b/include/linux/watch_queue.h
+++ a/include/linux/watch_queue.h
@@ -28,8 +28,7 @@
 struct watch_filter {
 	union {
 		struct rcu_head	rcu;
+		unsigned long	type_filter[2];	/* Bitmask of accepted types */
-		/* Bitmask of accepted types */
-		DECLARE_BITMAP(type_filter, WATCH_TYPE__NR);
 	};
 	u32			nr_filters;	/* Number of filters */
 	struct watch_type_filter filters[];
--- b/include/trace/events/cachefiles.h
+++ a/include/trace/events/cachefiles.h
@@ -56,7 +56,6 @@
 	cachefiles_coherency_set_ok,
 	cachefiles_coherency_vol_check_cmp,
 	cachefiles_coherency_vol_check_ok,
-	cachefiles_coherency_vol_check_resv,
 	cachefiles_coherency_vol_check_xattr,
 	cachefiles_coherency_vol_set_fail,
 	cachefiles_coherency_vol_set_ok,
@@ -140,7 +139,6 @@
 	EM(cachefiles_coherency_set_ok,		"SET ok  ")		\
 	EM(cachefiles_coherency_vol_check_cmp,	"VOL BAD cmp ")		\
 	EM(cachefiles_coherency_vol_check_ok,	"VOL OK      ")		\
-	EM(cachefiles_coherency_vol_check_resv,	"VOL BAD resv")	\
 	EM(cachefiles_coherency_vol_check_xattr,"VOL BAD xatt")		\
 	EM(cachefiles_coherency_vol_set_fail,	"VOL SET fail")		\
 	E_(cachefiles_coherency_vol_set_ok,	"VOL SET ok  ")
--- b/kernel/watch_queue.c
+++ a/kernel/watch_queue.c
@@ -54,7 +54,6 @@
 	bit += page->index;
 
 	set_bit(bit, wqueue->notes_bitmap);
-	generic_pipe_buf_release(pipe, buf);
 }
 
 // No try_steal function => no stealing
@@ -113,7 +112,7 @@
 	buf->offset = offset;
 	buf->len = len;
 	buf->flags = PIPE_BUF_FLAG_WHOLE;
+	pipe->head = head + 1;
-	smp_store_release(&pipe->head, head + 1); /* vs pipe_read() */
 
 	if (!test_and_clear_bit(note, wqueue->notes_bitmap)) {
 		spin_unlock_irq(&pipe->rd_wait.lock);
@@ -220,6 +219,7 @@
 	struct page **pages;
 	unsigned long *bitmap;
 	unsigned long user_bufs;
+	unsigned int bmsize;
 	int ret, i, nr_pages;
 
 	if (!wqueue)
@@ -243,8 +243,7 @@
 		goto error;
 	}
 
+	ret = pipe_resize_ring(pipe, nr_notes);
-	nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;
-	ret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));
 	if (ret < 0)
 		goto error;
 
@@ -259,15 +258,17 @@
 		pages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;
 	}
 
+	bmsize = (nr_notes + BITS_PER_LONG - 1) / BITS_PER_LONG;
+	bmsize *= sizeof(unsigned long);
+	bitmap = kmalloc(bmsize, GFP_KERNEL);
-	bitmap = bitmap_alloc(nr_notes, GFP_KERNEL);
 	if (!bitmap)
 		goto error_p;
 
+	memset(bitmap, 0xff, bmsize);
-	bitmap_fill(bitmap, nr_notes);
 	wqueue->notes = pages;
 	wqueue->notes_bitmap = bitmap;
 	wqueue->nr_pages = nr_pages;
+	wqueue->nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;
-	wqueue->nr_notes = nr_notes;
 	return 0;
 
 error_p:
@@ -319,7 +320,7 @@
 		    tf[i].info_mask & WATCH_INFO_LENGTH)
 			goto err_filter;
 		/* Ignore any unknown types */
+		if (tf[i].type >= sizeof(wfilter->type_filter) * 8)
-		if (tf[i].type >= WATCH_TYPE__NR)
 			continue;
 		nr_filter++;
 	}
@@ -335,7 +336,7 @@
 
 	q = wfilter->filters;
 	for (i = 0; i < filter.nr_filters; i++) {
+		if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG)
-		if (tf[i].type >= WATCH_TYPE__NR)
 			continue;
 
 		q->type			= tf[i].type;
@@ -370,7 +371,6 @@
 
 	for (i = 0; i < wqueue->nr_pages; i++)
 		__free_page(wqueue->notes[i]);
-	bitmap_free(wqueue->notes_bitmap);
 
 	wfilter = rcu_access_pointer(wqueue->filter);
 	if (wfilter)
@@ -566,7 +566,7 @@
 	rcu_read_lock();
 	spin_lock_bh(&wqueue->lock);
 
+	/* Prevent new additions and prevent notifications from happening */
-	/* Prevent new notifications from being stored. */
 	wqueue->defunct = true;
 
 	while (!hlist_empty(&wqueue->watches)) {
