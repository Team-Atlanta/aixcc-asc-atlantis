diff --git a/fs/pipe.c b/fs/pipe.c
index 11358569a777..e140ea150bbb 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -1245,32 +1245,29 @@ unsigned int round_pipe_size(unsigned long size)
 
 /*
  * Resize the pipe ring to a number of slots.
- *
- * Note the pipe can be reduced in capacity, but only if the current
- * occupancy doesn't exceed nr_slots; if it does, EBUSY will be
- * returned instead.
  */
 int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)
 {
 	struct pipe_buffer *bufs;
 	unsigned int head, tail, mask, n;
 
-	bufs = kcalloc(nr_slots, sizeof(*bufs),
-		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);
-	if (unlikely(!bufs))
-		return -ENOMEM;
-
-	spin_lock_irq(&pipe->rd_wait.lock);
+	/*
+	 * We can shrink the pipe, if arg is greater than the ring occupancy.
+	 * Since we don't expect a lot of shrink+grow operations, just free and
+	 * allocate again like we would do for growing.  If the pipe currently
+	 * contains more buffers than arg, then return busy.
+	 */
 	mask = pipe->ring_size - 1;
 	head = pipe->head;
 	tail = pipe->tail;
-
-	n = pipe_occupancy(head, tail);
-	if (nr_slots < n) {
-		spin_unlock_irq(&pipe->rd_wait.lock);
-		kfree(bufs);
+	n = pipe_occupancy(pipe->head, pipe->tail);
+	if (nr_slots < n)
 		return -EBUSY;
-	}
+
+	bufs = kcalloc(nr_slots, sizeof(*bufs),
+		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);
+	if (unlikely(!bufs))
+		return -ENOMEM;
 
 	/*
 	 * The pipe array wraps around, so just start the new one at zero
@@ -1303,8 +1300,6 @@ int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)
 	pipe->tail = tail;
 	pipe->head = head;
 
-	spin_unlock_irq(&pipe->rd_wait.lock);
-
 	/* This might have made more room for writers */
 	wake_up_interruptible(&pipe->wr_wait);
 	return 0;
