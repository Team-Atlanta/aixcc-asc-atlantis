--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -32,13 +32,12 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <crypto/aead.h>
-#include <kunit/test-bug.h>
-#include <crypto/aes.h>
-#include <crypto/rng.h>
-#include "crypto.h"
+
+ #include <crypto/aead.h>
+ #include <kunit/test-bug.h>
+ #include <crypto/aes.h>
+ #include <crypto/rng.h>
+ #include "crypto.h"
 #include "msg.h"
 #include "bcast.h"
 
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2473,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,44 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
+	return 0;
+		if (!c->wq) {
+			kfree(c);
+			return -ENOMEM;
+		}
+	}
+
+	/* Allocate statistic structure */
+	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_ATOMIC);
+	if (!c->stats) {
+		if (c->wq)
+			destroy_workqueue(c->wq);
+		kfree_sensitive(c);
+		return -ENOMEM;
+	}
+
+	c->flags = 0;
+	c->net = net;
+	c->node = node;
+	get_random_bytes(&c->key_gen, 2);
+	tipc_crypto_key_set_state(c, 0, 0, 0);
+	atomic_set(&c->key_distr, 0);
+	atomic_set(&c->peer_rx_active, 0);
+	atomic64_set(&c->sndnxt, 0);
+	c->timer1 = jiffies;
+	c->timer2 = jiffies;
+	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
+	spin_lock_init(&c->lock);
+	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
+		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+			       tipc_own_id_string(c->net));
+
+	if (is_rx(c))
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
+	else
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+	*crypto = c;
 	return 0;
 }
 
@@ -2278,31 +2315,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2363,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2511,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1493,13 +1494,14 @@
 	atomic_set(&c->peer_rx_active, 0);
 	atomic64_set(&c->sndnxt, 0);
 	c->timer1 = jiffies;
+
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
 
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
-		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
-			       tipc_own_id_string(c->net));
+	          (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+	                       tipc_own_id_string(c->net));
 
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
@@ -1507,7 +1509,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2279,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2327,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2475,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1504,13 +1504,13 @@
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
 	else
-		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+ 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
 
 	return 0;
 }
-
 void tipc_crypto_stop(struct tipc_crypto **crypto)
 {
 	struct tipc_crypto *c = *crypto;
@@ -2278,31 +2278,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2326,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2474,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2275,37 +2274,7 @@
  *
  * Return: "true" if the key has been scheduled for attaching, otherwise
  * "false".
- */
-static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
-{
-
-	struct tipc_crypto *tx  = NULL;
-	struct tipc_aead_key *skey = NULL;
-	u16 key_gen = msg_key_gen(hdr);
-	u32 size = msg_data_sz(hdr);
-	u8 *data = msg_data(hdr);
-	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
-	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
-
-	spin_lock(&rx->lock);
-	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
-		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
-		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
-	}
-
-	/* Allocate memory for the key */
-	skey = kmalloc(size, GFP_ATOMIC);
-	if (unlikely(!skey)) {
-		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
-	}
-
-	/* Copy key from msg data */
+
 	skey->keylen = keylen;
 	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
 	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
@@ -2317,13 +2286,35 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
+	/* Schedule the key attaching on this crypto */
+	if (likely(skey && tx && queue_delayed_work(tx->wq, &rx->work, 0)))
+		return true;
+
+	return false;
+
+	skey->keylen = keylen;
+	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
+	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
+	       skey->keylen);
+
+	rx->key_gen = key_gen;
+	rx->skey_mode = msg_key_mode(hdr);
+	rx->skey = skey;
+	rx->nokey = 0;
+	mb(); /* for nokey flag */
+
+exit_unlock:
 	spin_unlock(&rx->lock);
+
+exit:
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2455,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2314,19 +2322,13 @@
 	rx->key_gen = key_gen;
 	rx->skey_mode = msg_key_mode(hdr);
 	rx->skey = skey;
-	rx->nokey = 0;
-	mb(); /* for nokey flag */
-
-exit:
+
 	spin_unlock(&rx->lock);
-	/* Schedule the key attaching on this crypto */
-	if (rx->net){
-	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+
+	if (rx->net && likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
-}
-
 /**
  * tipc_crypto_work_rx - Scheduled RX works handler
  * @work: the struct RX work
@@ -2464,7 +2466,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2461,10 +2470,10 @@
 		pr_warn_ratelimited("%s: rekeying returns %d\n", tx->name, rc);
 
 resched:
+
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
-}
-
+	return;
 #ifdef CONFIG_TIPC_TEST
 #include "tipc_test.c"
 #endif
