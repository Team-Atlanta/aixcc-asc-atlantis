[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:run_once:4) Started...
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:act) Started...
Suggested diff:
--- drivers/KPRCA-00001/service.c
+++ drivers/KPRCA-00001/service.c
@@ -216,7 +216,7 @@
   memset(buf, 0, sizeof(buf));
 
   //while (readuntil(STDIN, buf, sizeof(buf), '\n') == 0)
-  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf) - 1, '\n') >= 0)
+  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf), '\n') >= 0)
   {
     char *tok, *input = buf;
     if (strlen(buf) == 0)
@@ -369,9 +369,7 @@
     return 1;
   }
 
-  if (strcmp(mode, "encode") == 0)
-  {
-    if (strlen(data) / 3 * 4 <= sizeof(buf))
+    if (strlen(data) * 4 / 3 + 4 <= sizeof(buf))
     {
       size_t n = kprca00001_root64_encode(buf, data);
       output_write(buf, n);
@@ -494,22 +492,20 @@
         printk(KERN_INFO "service_ioctl: work_with_data enter");
         memset(req.stdout, 0, MAX_STDOUT);
         req.out_len = 0;
-        if(req.buf_len > 0){
-          buf = vmalloc(req.buf_len);
-          dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
-          if (copy_from_user(buf, req.buf, req.buf_len)) {
-            printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
-          }
-          user_buf = req.buf;
-          req.buf = buf;
-          req.buf_idx = 0;
-
-          // call main
-          kpraca00001_current_req = &req;
-          r = handle_main(command, &req);
-          // free buf and roll back user buffer
-          vfree(buf);
+        buf = vmalloc(req.buf_len);
+        dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
+        if (copy_from_user(buf, req.buf, req.buf_len)) {
+          printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
         }
+        user_buf = req.buf;
+        req.buf = buf;
+        req.buf_idx = 0;
+
+        // call main
+        kpraca00001_current_req = &req;
+        r = handle_main(command, &req);
+        // free buf and roll back user buffer
+        vfree(buf);
         req.buf = user_buf;
         result = copy_to_user(&((kprca00001_req_t*)arg)->stdout, &req.stdout, req.out_len);
         result = r;

[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:act) Took 1.22 seconds
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'error: KPRCA-00001/service.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmpiw0yfdsr\n'
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:acc-evaluator:patch) Took 0.51 seconds
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:evaluate) Took 0.51 seconds
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:pick) Took 0.00 seconds
--- drivers/KPRCA-00001/service.c
+++ drivers/KPRCA-00001/service.c
@@ -216,7 +216,7 @@
   memset(buf, 0, sizeof(buf));
 
   //while (readuntil(STDIN, buf, sizeof(buf), '\n') == 0)
-  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf) - 1, '\n') >= 0)
+  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf), '\n') >= 0)
   {
     char *tok, *input = buf;
     if (strlen(buf) == 0)
@@ -369,9 +369,7 @@
     return 1;
   }
 
-  if (strcmp(mode, "encode") == 0)
-  {
-    if (strlen(data) / 3 * 4 <= sizeof(buf))
+    if (strlen(data) * 4 / 3 + 4 <= sizeof(buf))
     {
       size_t n = kprca00001_root64_encode(buf, data);
       output_write(buf, n);
@@ -494,22 +492,20 @@
         printk(KERN_INFO "service_ioctl: work_with_data enter");
         memset(req.stdout, 0, MAX_STDOUT);
         req.out_len = 0;
-        if(req.buf_len > 0){
-          buf = vmalloc(req.buf_len);
-          dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
-          if (copy_from_user(buf, req.buf, req.buf_len)) {
-            printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
-          }
-          user_buf = req.buf;
-          req.buf = buf;
-          req.buf_idx = 0;
-
-          // call main
-          kpraca00001_current_req = &req;
-          r = handle_main(command, &req);
-          // free buf and roll back user buffer
-          vfree(buf);
+        buf = vmalloc(req.buf_len);
+        dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
+        if (copy_from_user(buf, req.buf, req.buf_len)) {
+          printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
         }
+        user_buf = req.buf;
+        req.buf = buf;
+        req.buf_idx = 0;
+
+        // call main
+        kpraca00001_current_req = &req;
+        r = handle_main(command, &req);
+        // free buf and roll back user buffer
+        vfree(buf);
         req.buf = user_buf;
         result = copy_to_user(&((kprca00001_req_t*)arg)->stdout, &req.stdout, req.out_len);
         result = r;

[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:run_once:4) Took 1.94 seconds
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:run_once:2) Started...
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:act) Started...
Suggested diff:
--- drivers/KPRCA-00001/service.c
+++ drivers/KPRCA-00001/service.c
@@ -216,7 +216,7 @@
   memset(buf, 0, sizeof(buf));
 
   //while (readuntil(STDIN, buf, sizeof(buf), '\n') == 0)
-  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf) - 1, '\n') >= 0)
+  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf), '\n') >= 0)
   {
     char *tok, *input = buf;
     if (strlen(buf) == 0)
@@ -369,8 +369,6 @@
     return 1;
   }
 
-  if (strcmp(mode, "encode") == 0)
-  {
     if (strlen(data) / 3 * 4 <= sizeof(buf))
     {
       size_t n = kprca00001_root64_encode(buf, data);
@@ -494,22 +492,20 @@
         printk(KERN_INFO "service_ioctl: work_with_data enter");
         memset(req.stdout, 0, MAX_STDOUT);
         req.out_len = 0;
-        if(req.buf_len > 0){
-          buf = vmalloc(req.buf_len);
-          dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
-          if (copy_from_user(buf, req.buf, req.buf_len)) {
-            printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
-          }
-          user_buf = req.buf;
-          req.buf = buf;
-          req.buf_idx = 0;
-
-          // call main
-          kpraca00001_current_req = &req;
-          r = handle_main(command, &req);
-          // free buf and roll back user buffer
-          vfree(buf);
+        buf = vmalloc(req.buf_len);
+        dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
+        if (copy_from_user(buf, req.buf, req.buf_len)) {
+          printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
         }
+        user_buf = req.buf;
+        req.buf = buf;
+        req.buf_idx = 0;
+
+        // call main
+        kpraca00001_current_req = &req;
+        r = handle_main(command, &req);
+        // free buf and roll back user buffer
+        vfree(buf);
         req.buf = user_buf;
         result = copy_to_user(&((kprca00001_req_t*)arg)->stdout, &req.stdout, req.out_len);
         result = r;

[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:act) Took 1.62 seconds
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'error: KPRCA-00001/service.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmpywhn4paf\n'
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:acc-evaluator:patch) Took 0.25 seconds
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:evaluate) Took 0.25 seconds
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:pick) Took 0.00 seconds
--- drivers/KPRCA-00001/service.c
+++ drivers/KPRCA-00001/service.c
@@ -216,7 +216,7 @@
   memset(buf, 0, sizeof(buf));
 
   //while (readuntil(STDIN, buf, sizeof(buf), '\n') == 0)
-  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf) - 1, '\n') >= 0)
+  if (kprca00001_read_until_delim_null(kpraca00001_current_req, buf, sizeof(buf), '\n') >= 0)
   {
     char *tok, *input = buf;
     if (strlen(buf) == 0)
@@ -369,8 +369,6 @@
     return 1;
   }
 
-  if (strcmp(mode, "encode") == 0)
-  {
     if (strlen(data) / 3 * 4 <= sizeof(buf))
     {
       size_t n = kprca00001_root64_encode(buf, data);
@@ -494,22 +492,20 @@
         printk(KERN_INFO "service_ioctl: work_with_data enter");
         memset(req.stdout, 0, MAX_STDOUT);
         req.out_len = 0;
-        if(req.buf_len > 0){
-          buf = vmalloc(req.buf_len);
-          dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
-          if (copy_from_user(buf, req.buf, req.buf_len)) {
-            printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
-          }
-          user_buf = req.buf;
-          req.buf = buf;
-          req.buf_idx = 0;
-
-          // call main
-          kpraca00001_current_req = &req;
-          r = handle_main(command, &req);
-          // free buf and roll back user buffer
-          vfree(buf);
+        buf = vmalloc(req.buf_len);
+        dprintk(KERN_INFO "vmalloc() to copy user buf at %px", buf);
+        if (copy_from_user(buf, req.buf, req.buf_len)) {
+          printk(KERN_INFO "service_ioctl main: [!] copy_from_user failed!");
         }
+        user_buf = req.buf;
+        req.buf = buf;
+        req.buf_idx = 0;
+
+        // call main
+        kpraca00001_current_req = &req;
+        r = handle_main(command, &req);
+        // free buf and roll back user buffer
+        vfree(buf);
         req.buf = user_buf;
         result = copy_to_user(&((kprca00001_req_t*)arg)->stdout, &req.stdout, req.out_len);
         result = r;

[logging_performance](infilling-linux-KPRCA-00001-gpt-4o-1:wire:run_once:2) Took 2.09 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:run_once:4) Started...
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:act) Started...
Suggested diff:
--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -32,10 +32,8 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
- */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1460,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1496,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1506,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2276,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2324,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2472,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1460,12 +1459,15 @@
 {
 	struct tipc_crypto *c;
 
+```c
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
-	c = kzalloc(sizeof(*c), GFP_ATOMIC);
+	c = kzalloc(sizeof(*c), GFP_KERNEL); // Replaced GFP_ATOMIC with GFP_KERNEL for safe allocation
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1476,7 +1478,7 @@
 	}
 
 	/* Allocate statistic structure */
-	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_ATOMIC);
+	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_KERNEL); // Replaced GFP_ATOMIC with GFP_KERNEL for safe allocation
 	if (!c->stats) {
 		if (c->wq)
 			destroy_workqueue(c->wq);
@@ -1496,7 +1498,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1508,46 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
+	return 0;
+}
+```
+		if (!c->wq) {
+			kfree(c);
+			return -ENOMEM;
+		}
+	}
+
+	/* Allocate statistic structure */
+	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_ATOMIC);
+	if (!c->stats) {
+		if (c->wq)
+			destroy_workqueue(c->wq);
+		kfree_sensitive(c);
+		return -ENOMEM;
+	}
+
+	c->flags = 0;
+	c->net = net;
+	c->node = node;
+	get_random_bytes(&c->key_gen, 2);
+	tipc_crypto_key_set_state(c, 0, 0, 0);
+	atomic_set(&c->key_distr, 0);
+	atomic_set(&c->peer_rx_active, 0);
+	atomic64_set(&c->sndnxt, 0);
+	c->timer1 = jiffies;
+	c->timer2 = jiffies;
+	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
+	spin_lock_init(&c->lock);
+	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
+		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+			       tipc_own_id_string(c->net));
+
+	if (is_rx(c))
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
+	else
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+	*crypto = c;
 	return 0;
 }
 
@@ -2278,31 +2318,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2366,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2514,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1493,9 +1494,13 @@
 	atomic_set(&c->peer_rx_active, 0);
 	atomic64_set(&c->sndnxt, 0);
 	c->timer1 = jiffies;
+
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
+
+	/* Initialize key_state to avoid any undefined behavior */
+	memset(&c->key, 0, sizeof(c->key));
 
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
@@ -1507,7 +1512,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2282,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2330,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2478,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1504,12 +1504,6 @@
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
 	else
-		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
-
-	*crypto = c;
-
-	return 0;
-}
 
 void tipc_crypto_stop(struct tipc_crypto **crypto)
 {
@@ -1977,6 +1971,473 @@
 	skb_cb = TIPC_SKB_CB(*skb);
 
 	/* Mark skb decrypted */
+	skb
+void tipc_crypto_stop(struct tipc_crypto **crypto)
+{
+	struct tipc_crypto *c = *crypto;
+	u8 k;
+
+	if (!c)
+		return;
+
+	/* Flush any queued works & destroy wq */
+	if (is_tx(c)) {
+		c->rekeying_intv = 0;
+		cancel_delayed_work_sync(&c->work);
+		destroy_workqueue(c->wq);
+	}
+
+	/* Release AEAD keys */
+	rcu_read_lock();
+	for (k = KEY_MIN; k <= KEY_MAX; k++)
+		tipc_aead_put(rcu_dereference(c->aead[k]));
+	rcu_read_unlock();
+	pr_debug("%s: has been stopped\n", c->name);
+
+	/* Free this crypto statistics */
+	free_percpu(c->stats);
+
+	*crypto = NULL;
+	kfree_sensitive(c);
+}
+
+void tipc_crypto_timeout(struct tipc_crypto *rx)
+{
+	struct tipc_net *tn = tipc_net(rx->net);
+	struct tipc_crypto *tx = tn->crypto_tx;
+	struct tipc_key key;
+	int cmd;
+
+	/* TX pending: taking all users & stable -> active */
+	spin_lock(&tx->lock);
+	key = tx->key;
+	if (key.active && tipc_aead_users(tx->aead[key.active]) > 0)
+		goto s1;
+	if (!key.pending || tipc_aead_users(tx->aead[key.pending]) <= 0)
+		goto s1;
+	if (time_before(jiffies, tx->timer1 + TIPC_TX_LASTING_TIME))
+		goto s1;
+
+	tipc_crypto_key_set_state(tx, key.passive, key.pending, 0);
+	if (key.active)
+		tipc_crypto_key_detach(tx->aead[key.active], &tx->lock);
+	this_cpu_inc(tx->stats->stat[STAT_SWITCHES]);
+	pr_info("%s: key[%d] is activated\n", tx->name, key.pending);
+
+s1:
+	spin_unlock(&tx->lock);
+
+	/* RX pending: having user -> active */
+	spin_lock(&rx->lock);
+	key = rx->key;
+	if (!key.pending || tipc_aead_users(rx->aead[key.pending]) <= 0)
+		goto s2;
+
+	if (key.active)
+		key.passive = key.active;
+	key.active = key.pending;
+	rx->timer2 = jiffies;
+	tipc_crypto_key_set_state(rx, key.passive, key.active, 0);
+	this_cpu_inc(rx->stats->stat[STAT_SWITCHES]);
+	pr_info("%s: key[%d] is activated\n", rx->name, key.pending);
+	goto s5;
+
+s2:
+	/* RX pending: not working -> remove */
+	if (!key.pending || tipc_aead_users(rx->aead[key.pending]) > -10)
+		goto s3;
+
+	tipc_crypto_key_set_state(rx, key.passive, key.active, 0);
+	tipc_crypto_key_detach(rx->aead[key.pending], &rx->lock);
+	pr_debug("%s: key[%d] is removed\n", rx->name, key.pending);
+	goto s5;
+
+s3:
+	/* RX active: timed out or no user -> pending */
+	if (!key.active)
+		goto s4;
+	if (time_before(jiffies, rx->timer1 + TIPC_RX_ACTIVE_LIM) &&
+	    tipc_aead_users(rx->aead[key.active]) > 0)
+		goto s4;
+
+	if (key.pending)
+		key.passive = key.active;
+	else
+		key.pending = key.active;
+	rx->timer2 = jiffies;
+	tipc_crypto_key_set_state(rx, key.passive, 0, key.pending);
+	tipc_aead_users_set(rx->aead[key.pending], 0);
+	pr_debug("%s: key[%d] is deactivated\n", rx->name, key.active);
+	goto s5;
+
+s4:
+	/* RX passive: outdated or not working -> free */
+	if (!key.passive)
+		goto s5;
+	if (time_before(jiffies, rx->timer2 + TIPC_RX_PASSIVE_LIM) &&
+	    tipc_aead_users(rx->aead[key.passive]) > -10)
+		goto s5;
+
+	tipc_crypto_key_set_state(rx, 0, key.active, key.pending);
+	tipc_crypto_key_detach(rx->aead[key.passive], &rx->lock);
+	pr_debug("%s: key[%d] is freed\n", rx->name, key.passive);
+
+s5:
+	spin_unlock(&rx->lock);
+
+	/* Relax it here, the flag will be set again if it really is, but only
+	 * when we are not in grace period for safety!
+	 */
+	if (time_after(jiffies, tx->timer2 + TIPC_TX_GRACE_PERIOD))
+		tx->legacy_user = 0;
+
+	/* Limit max_tfms & do debug commands if needed */
+	if (likely(sysctl_tipc_max_tfms <= TIPC_MAX_TFMS_LIM))
+		return;
+
+	cmd = sysctl_tipc_max_tfms;
+	sysctl_tipc_max_tfms = TIPC_MAX_TFMS_DEF;
+	tipc_crypto_do_cmd(rx->net, cmd);
+}
+
+static inline void tipc_crypto_clone_msg(struct net *net, struct sk_buff *_skb,
+					 struct tipc_bearer *b,
+					 struct tipc_media_addr *dst,
+					 struct tipc_node *__dnode, u8 type)
+{
+	struct sk_buff *skb;
+
+	skb = skb_clone(_skb, GFP_ATOMIC);
+	if (skb) {
+		TIPC_SKB_CB(skb)->xmit_type = type;
+		tipc_crypto_xmit(net, &skb, b, dst, __dnode);
+		if (skb)
+			b->media->send_msg(net, skb, b, dst);
+	}
+}
+
+/**
+ * tipc_crypto_xmit - Build & encrypt TIPC message for xmit
+ * @net: struct net
+ * @skb: input/output message skb pointer
+ * @b: bearer used for xmit later
+ * @dst: destination media address
+ * @__dnode: destination node for reference if any
+ *
+ * First, build an encryption message header on the top of the message, then
+ * encrypt the original TIPC message by using the pending, master or active
+ * key with this preference order.
+ * If the encryption is successful, the encrypted skb is returned directly or
+ * via the callback.
+ * Otherwise, the skb is freed!
+ *
+ * Return:
+ * * 0                   : the encryption has succeeded (or no encryption)
+ * * -EINPROGRESS/-EBUSY : the encryption is ongoing, a callback will be made
+ * * -ENOKEK             : the encryption has failed due to no key
+ * * -EKEYREVOKED        : the encryption has failed due to key revoked
+ * * -ENOMEM             : the encryption has failed due to no memory
+ * * < 0                 : the encryption has failed due to other reasons
+ */
+int tipc_crypto_xmit(struct net *net, struct sk_buff **skb,
+		     struct tipc_bearer *b, struct tipc_media_addr *dst,
+		     struct tipc_node *__dnode)
+{
+	struct tipc_crypto *__rx = tipc_node_crypto_rx(__dnode);
+	struct tipc_crypto *tx = tipc_net(net)->crypto_tx;
+	struct tipc_crypto_stats __percpu *stats = tx->stats;
+	struct tipc_msg *hdr = buf_msg(*skb);
+	struct tipc_key key = tx->key;
+	struct tipc_aead *aead = NULL;
+	u32 user = msg_user(hdr);
+	u32 type = msg_type(hdr);
+	int rc = -ENOKEY;
+	u8 tx_key = 0;
+
+	/* No encryption? */
+	if (!tx->working)
+		return 0;
+
+	/* Pending key if peer has active on it or probing time */
+	if (unlikely(key.pending)) {
+		tx_key = key.pending;
+		if (!tx->key_master && !key.active)
+			goto encrypt;
+		if (__rx && atomic_read(&__rx->peer_rx_active) == tx_key)
+			goto encrypt;
+		if (TIPC_SKB_CB(*skb)->xmit_type == SKB_PROBING) {
+			pr_debug("%s: probing for key[%d]\n", tx->name,
+				 key.pending);
+			goto encrypt;
+		}
+		if (user == LINK_CONFIG || user == LINK_PROTOCOL)
+			tipc_crypto_clone_msg(net, *skb, b, dst, __dnode,
+					      SKB_PROBING);
+	}
+
+	/* Master key if this is a *vital* message or in grace period */
+	if (tx->key_master) {
+		tx_key = KEY_MASTER;
+		if (!key.active)
+			goto encrypt;
+		if (TIPC_SKB_CB(*skb)->xmit_type == SKB_GRACING) {
+			pr_debug("%s: gracing for msg (%d %d)\n", tx->name,
+				 user, type);
+			goto encrypt;
+		}
+		if (user == LINK_CONFIG ||
+		    (user == LINK_PROTOCOL && type == RESET_MSG) ||
+		    (user == MSG_CRYPTO && type == KEY_DISTR_MSG) ||
+		    time_before(jiffies, tx->timer2 + TIPC_TX_GRACE_PERIOD)) {
+			if (__rx && __rx->key_master &&
+			    !atomic_read(&__rx->peer_rx_active))
+				goto encrypt;
+			if (!__rx) {
+				if (likely(!tx->legacy_user))
+					goto encrypt;
+				tipc_crypto_clone_msg(net, *skb, b, dst,
+						      __dnode, SKB_GRACING);
+			}
+		}
+	}
+
+	/* Else, use the active key if any */
+	if (likely(key.active)) {
+		tx_key = key.active;
+		goto encrypt;
+	}
+
+	goto exit;
+
+encrypt:
+	aead = tipc_aead_get(tx->aead[tx_key]);
+	if (unlikely(!aead))
+		goto exit;
+	rc = tipc_ehdr_build(net, aead, tx_key, *skb, __rx);
+	if (likely(rc > 0))
+		rc = tipc_aead_encrypt(aead, *skb, b, dst, __dnode);
+
+exit:
+	switch (rc) {
+	case 0:
+		this_cpu_inc(stats->stat[STAT_OK]);
+		break;
+	case -EINPROGRESS:
+	case -EBUSY:
+		this_cpu_inc(stats->stat[STAT_ASYNC]);
+		*skb = NULL;
+		return rc;
+	default:
+		this_cpu_inc(stats->stat[STAT_NOK]);
+		if (rc == -ENOKEY)
+			this_cpu_inc(stats->stat[STAT_NOKEYS]);
+		else if (rc == -EKEYREVOKED)
+			this_cpu_inc(stats->stat[STAT_BADKEYS]);
+		kfree_skb(*skb);
+		*skb = NULL;
+		break;
+	}
+
+	tipc_aead_put(aead);
+	return rc;
+}
+
+/**
+ * tipc_crypto_rcv - Decrypt an encrypted TIPC message from peer
+ * @net: struct net
+ * @rx: RX crypto handle
+ * @skb: input/output message skb pointer
+ * @b: bearer where the message has been received
+ *
+ * If the decryption is successful, the decrypted skb is returned directly or
+ * as the callback, the encryption header and auth tag will be trimed out
+ * before forwarding to tipc_rcv() via the tipc_crypto_rcv_complete().
+ * Otherwise, the skb will be freed!
+ * Note: RX key(s) can be re-aligned, or in case of no key suitable, TX
+ * cluster key(s) can be taken for decryption (- recursive).
+ *
+ * Return:
+ * * 0                   : the decryption has successfully completed
+ * * -EINPROGRESS/-EBUSY : the decryption is ongoing, a callback will be made
+ * * -ENOKEY             : the decryption has failed due to no key
+ * * -EBADMSG            : the decryption has failed due to bad message
+ * * -ENOMEM             : the decryption has failed due to no memory
+ * * < 0                 : the decryption has failed due to other reasons
+ */
+int tipc_crypto_rcv(struct net *net, struct tipc_crypto *rx,
+		    struct sk_buff **skb, struct tipc_bearer *b)
+{
+	struct tipc_crypto *tx = tipc_net(net)->crypto_tx;
+	struct tipc_crypto_stats __percpu *stats;
+	struct tipc_aead *aead = NULL;
+	struct tipc_key key;
+	int rc = -ENOKEY;
+	u8 tx_key, n;
+
+	tx_key = ((struct tipc_ehdr *)(*skb)->data)->tx_key;
+
+	/* New peer?
+	 * Let's try with TX key (i.e. cluster mode) & verify the skb first!
+	 */
+	if (unlikely(!rx || tx_key == KEY_MASTER))
+		goto pick_tx;
+
+	/* Pick RX key according to TX key if any */
+	key = rx->key;
+	if (tx_key == key.active || tx_key == key.pending ||
+	    tx_key == key.passive)
+		goto decrypt;
+
+	/* Unknown key, let's try to align RX key(s) */
+	if (tipc_crypto_key_try_align(rx, tx_key))
+		goto decrypt;
+
+pick_tx:
+	/* No key suitable? Try to pick one from TX... */
+	aead = tipc_crypto_key_pick_tx(tx, rx, *skb, tx_key);
+	if (aead)
+		goto decrypt;
+	goto exit;
+
+decrypt:
+	rcu_read_lock();
+	if (!aead)
+		aead = tipc_aead_get(rx->aead[tx_key]);
+	rc = tipc_aead_decrypt(net, aead, *skb, b);
+	rcu_read_unlock();
+
+exit:
+	stats = ((rx) ?: tx)->stats;
+	switch (rc) {
+	case 0:
+		this_cpu_inc(stats->stat[STAT_OK]);
+		break;
+	case -EINPROGRESS:
+	case -EBUSY:
+		this_cpu_inc(stats->stat[STAT_ASYNC]);
+		*skb = NULL;
+		return rc;
+	default:
+		this_cpu_inc(stats->stat[STAT_NOK]);
+		if (rc == -ENOKEY) {
+			kfree_skb(*skb);
+			*skb = NULL;
+			if (rx) {
+				/* Mark rx->nokey only if we dont have a
+				 * pending received session key, nor a newer
+				 * one i.e. in the next slot.
+				 */
+				n = key_next(tx_key);
+				rx->nokey = !(rx->skey ||
+					      rcu_access_pointer(rx->aead[n]));
+				pr_debug_ratelimited("%s: nokey %d, key %d/%x\n",
+						     rx->name, rx->nokey,
+						     tx_key, rx->key.keys);
+				tipc_node_put(rx->node);
+			}
+			this_cpu_inc(stats->stat[STAT_NOKEYS]);
+			return rc;
+		} else if (rc == -EBADMSG) {
+			this_cpu_inc(stats->stat[STAT_BADMSGS]);
+		}
+		break;
+	}
+
+	tipc_crypto_rcv_complete(net, aead, b, skb, rc);
+	return rc;
+}
+
+static void tipc_crypto_rcv_complete(struct net *net, struct tipc_aead *aead,
+				     struct tipc_bearer *b,
+				     struct sk_buff **skb, int err)
+{
+	struct tipc_skb_cb *skb_cb = TIPC_SKB_CB(*skb);
+	struct tipc_crypto *rx = aead->crypto;
+	struct tipc_aead *tmp = NULL;
+	struct tipc_ehdr *ehdr;
+	struct tipc_node *n;
+
+	/* Is this completed by TX? */
+	if (unlikely(is_tx(aead->crypto))) {
+		rx = skb_cb->tx_clone_ctx.rx;
+		pr_debug("TX->RX(%s): err %d, aead %p, skb->next %p, flags %x\n",
+			 (rx) ? tipc_node_get_id_str(rx->node) : "-", err, aead,
+			 (*skb)->next, skb_cb->flags);
+		pr_debug("skb_cb [recurs %d, last %p], tx->aead [%p %p %p]\n",
+			 skb_cb->tx_clone_ctx.recurs, skb_cb->tx_clone_ctx.last,
+			 aead->crypto->aead[1], aead->crypto->aead[2],
+			 aead->crypto->aead[3]);
+		if (unlikely(err)) {
+			if (err == -EBADMSG && (*skb)->next)
+				tipc_rcv(net, (*skb)->next, b);
+			goto free_skb;
+		}
+
+		if (likely((*skb)->next)) {
+			kfree_skb((*skb)->next);
+			(*skb)->next = NULL;
+		}
+		ehdr = (struct tipc_ehdr *)(*skb)->data;
+		if (!rx) {
+			WARN_ON(ehdr->user != LINK_CONFIG);
+			n = tipc_node_create(net, 0, ehdr->id, 0xffffu, 0,
+					     true);
+			rx = tipc_node_crypto_rx(n);
+			if (unlikely(!rx))
+				goto free_skb;
+		}
+
+		/* Ignore cloning if it was TX master key */
+		if (ehdr->tx_key == KEY_MASTER)
+			goto rcv;
+		if (tipc_aead_clone(&tmp, aead) < 0)
+			goto rcv;
+		WARN_ON(!refcount_inc_not_zero(&tmp->refcnt));
+		if (tipc_crypto_key_attach(rx, tmp, ehdr->tx_key, false) < 0) {
+			tipc_aead_free(&tmp->rcu);
+			goto rcv;
+		}
+		tipc_aead_put(aead);
+		aead = tmp;
+	}
+
+	if (unlikely(err)) {
+		tipc_aead_users_dec((struct tipc_aead __force __rcu *)aead, INT_MIN);
+		goto free_skb;
+	}
+
+	/* Set the RX key's user */
+	tipc_aead_users_set((struct tipc_aead __force __rcu *)aead, 1);
+
+	/* Mark this point, RX works */
+	rx->timer1 = jiffies;
+
+rcv:
+	/* Remove ehdr & auth. tag prior to tipc_rcv() */
+	ehdr = (struct tipc_ehdr *)(*skb)->data;
+
+	/* Mark this point, RX passive still works */
+	if (rx->key.passive && ehdr->tx_key == rx->key.passive)
+		rx->timer2 = jiffies;
+
+	skb_reset_network_header(*skb);
+	skb_pull(*skb, tipc_ehdr_size(ehdr));
+	if (pskb_trim(*skb, (*skb)->len - aead->authsize))
+		goto free_skb;
+
+	/* Validate TIPCv2 message */
+	if (unlikely(!tipc_msg_validate(skb))) {
+		pr_err_ratelimited("Packet dropped after decryption!\n");
+		goto free_skb;
+	}
+
+	/* Ok, everything's fine, try to synch own keys according to peers' */
+	tipc_crypto_key_synch(rx, *skb);
+
+	/* Re-fetch skb cb as skb might be changed in tipc_msg_validate */
+	skb_cb = TIPC_SKB_CB(*skb);
+
+	/* Mark skb decrypted */
 	skb_cb->decrypted = 1;
 
 	/* Clear clone cxt if any */
@@ -2278,31 +2739,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2787,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2935,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2275,55 +2274,46 @@
  *
  * Return: "true" if the key has been scheduled for attaching, otherwise
  * "false".
- */
-static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
-{
-
-	struct tipc_crypto *tx  = NULL;
-	struct tipc_aead_key *skey = NULL;
-	u16 key_gen = msg_key_gen(hdr);
-	u32 size = msg_data_sz(hdr);
-	u8 *data = msg_data(hdr);
-	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
-	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
-
-	spin_lock(&rx->lock);
-	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
-		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
-		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
-	}
-
-	/* Allocate memory for the key */
-	skey = kmalloc(size, GFP_ATOMIC);
-	if (unlikely(!skey)) {
-		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
-	}
-
-	/* Copy key from msg data */
+
 	skey->keylen = keylen;
 	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
 	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
 	       skey->keylen);
-
+	
 	rx->key_gen = key_gen;
 	rx->skey_mode = msg_key_mode(hdr);
 	rx->skey = skey;
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+	spin_unlock(&rx->lock);
+
+	/* Schedule the key attaching on this crypto */
+	if (likely(tx && skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+		return true;
+
+	kfree(skey);
+	return false;
+
+	skey->keylen = keylen;
+	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
+	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
+	       skey->keylen);
+
+	rx->key_gen = key_gen;
+	rx->skey_mode = msg_key_mode(hdr);
+	rx->skey = skey;
+	rx->nokey = 0;
+	mb(); /* for nokey flag */
+
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2454,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2314,18 +2322,19 @@
 	rx->key_gen = key_gen;
 	rx->skey_mode = msg_key_mode(hdr);
 	rx->skey = skey;
+
+	/* Ensure memory barriers for the nokey flag */
 	rx->nokey = 0;
-	mb(); /* for nokey flag */
-
-exit:
+	mb();
+
+exit_unlock:
 	spin_unlock(&rx->lock);
+
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
-	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+	if (rx->net && skey && queue_delayed_work(tx->wq, &rx->work, 0))
 		return true;
-	}
+
 	return false;
-}
 
 /**
  * tipc_crypto_work_rx - Scheduled RX works handler
@@ -2464,7 +2473,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2461,8 +2470,15 @@
 		pr_warn_ratelimited("%s: rekeying returns %d\n", tx->name, rc);
 
 resched:
-	/* Re-schedule rekeying if any */
+
+ /* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
+
+	/* Free sensitive memory securely */
+	if (unlikely(skey)) {
+		memzero_explicit(skey, tipc_aead_key_size(skey));
+		kfree_sensitive(skey);
+	}
 }
 
 #ifdef CONFIG_TIPC_TEST

[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:act) Took 91.17 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'/tmp/tmpqyyk_m8q:1086: trailing whitespace.\n\t\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmpqyyk_m8q\n'
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:acc-evaluator:patch) Took 0.53 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:evaluate) Took 0.53 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:pick) Took 0.00 seconds
--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -32,10 +32,8 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
- */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1460,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1496,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1506,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2276,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2324,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2472,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1460,12 +1459,15 @@
 {
 	struct tipc_crypto *c;
 
+```c
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
-	c = kzalloc(sizeof(*c), GFP_ATOMIC);
+	c = kzalloc(sizeof(*c), GFP_KERNEL); // Replaced GFP_ATOMIC with GFP_KERNEL for safe allocation
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1476,7 +1478,7 @@
 	}
 
 	/* Allocate statistic structure */
-	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_ATOMIC);
+	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_KERNEL); // Replaced GFP_ATOMIC with GFP_KERNEL for safe allocation
 	if (!c->stats) {
 		if (c->wq)
 			destroy_workqueue(c->wq);
@@ -1496,7 +1498,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1508,46 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
+	return 0;
+}
+```
+		if (!c->wq) {
+			kfree(c);
+			return -ENOMEM;
+		}
+	}
+
+	/* Allocate statistic structure */
+	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_ATOMIC);
+	if (!c->stats) {
+		if (c->wq)
+			destroy_workqueue(c->wq);
+		kfree_sensitive(c);
+		return -ENOMEM;
+	}
+
+	c->flags = 0;
+	c->net = net;
+	c->node = node;
+	get_random_bytes(&c->key_gen, 2);
+	tipc_crypto_key_set_state(c, 0, 0, 0);
+	atomic_set(&c->key_distr, 0);
+	atomic_set(&c->peer_rx_active, 0);
+	atomic64_set(&c->sndnxt, 0);
+	c->timer1 = jiffies;
+	c->timer2 = jiffies;
+	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
+	spin_lock_init(&c->lock);
+	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
+		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+			       tipc_own_id_string(c->net));
+
+	if (is_rx(c))
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
+	else
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+	*crypto = c;
 	return 0;
 }
 
@@ -2278,31 +2318,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2366,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2514,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1493,9 +1494,13 @@
 	atomic_set(&c->peer_rx_active, 0);
 	atomic64_set(&c->sndnxt, 0);
 	c->timer1 = jiffies;
+
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
+
+	/* Initialize key_state to avoid any undefined behavior */
+	memset(&c->key, 0, sizeof(c->key));
 
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
@@ -1507,7 +1512,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2282,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2330,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2478,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1504,12 +1504,6 @@
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
 	else
-		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
-
-	*crypto = c;
-
-	return 0;
-}
 
 void tipc_crypto_stop(struct tipc_crypto **crypto)
 {
@@ -1977,6 +1971,473 @@
 	skb_cb = TIPC_SKB_CB(*skb);
 
 	/* Mark skb decrypted */
+	skb
+void tipc_crypto_stop(struct tipc_crypto **crypto)
+{
+	struct tipc_crypto *c = *crypto;
+	u8 k;
+
+	if (!c)
+		return;
+
+	/* Flush any queued works & destroy wq */
+	if (is_tx(c)) {
+		c->rekeying_intv = 0;
+		cancel_delayed_work_sync(&c->work);
+		destroy_workqueue(c->wq);
+	}
+
+	/* Release AEAD keys */
+	rcu_read_lock();
+	for (k = KEY_MIN; k <= KEY_MAX; k++)
+		tipc_aead_put(rcu_dereference(c->aead[k]));
+	rcu_read_unlock();
+	pr_debug("%s: has been stopped\n", c->name);
+
+	/* Free this crypto statistics */
+	free_percpu(c->stats);
+
+	*crypto = NULL;
+	kfree_sensitive(c);
+}
+
+void tipc_crypto_timeout(struct tipc_crypto *rx)
+{
+	struct tipc_net *tn = tipc_net(rx->net);
+	struct tipc_crypto *tx = tn->crypto_tx;
+	struct tipc_key key;
+	int cmd;
+
+	/* TX pending: taking all users & stable -> active */
+	spin_lock(&tx->lock);
+	key = tx->key;
+	if (key.active && tipc_aead_users(tx->aead[key.active]) > 0)
+		goto s1;
+	if (!key.pending || tipc_aead_users(tx->aead[key.pending]) <= 0)
+		goto s1;
+	if (time_before(jiffies, tx->timer1 + TIPC_TX_LASTING_TIME))
+		goto s1;
+
+	tipc_crypto_key_set_state(tx, key.passive, key.pending, 0);
+	if (key.active)
+		tipc_crypto_key_detach(tx->aead[key.active], &tx->lock);
+	this_cpu_inc(tx->stats->stat[STAT_SWITCHES]);
+	pr_info("%s: key[%d] is activated\n", tx->name, key.pending);
+
+s1:
+	spin_unlock(&tx->lock);
+
+	/* RX pending: having user -> active */
+	spin_lock(&rx->lock);
+	key = rx->key;
+	if (!key.pending || tipc_aead_users(rx->aead[key.pending]) <= 0)
+		goto s2;
+
+	if (key.active)
+		key.passive = key.active;
+	key.active = key.pending;
+	rx->timer2 = jiffies;
+	tipc_crypto_key_set_state(rx, key.passive, key.active, 0);
+	this_cpu_inc(rx->stats->stat[STAT_SWITCHES]);
+	pr_info("%s: key[%d] is activated\n", rx->name, key.pending);
+	goto s5;
+
+s2:
+	/* RX pending: not working -> remove */
+	if (!key.pending || tipc_aead_users(rx->aead[key.pending]) > -10)
+		goto s3;
+
+	tipc_crypto_key_set_state(rx, key.passive, key.active, 0);
+	tipc_crypto_key_detach(rx->aead[key.pending], &rx->lock);
+	pr_debug("%s: key[%d] is removed\n", rx->name, key.pending);
+	goto s5;
+
+s3:
+	/* RX active: timed out or no user -> pending */
+	if (!key.active)
+		goto s4;
+	if (time_before(jiffies, rx->timer1 + TIPC_RX_ACTIVE_LIM) &&
+	    tipc_aead_users(rx->aead[key.active]) > 0)
+		goto s4;
+
+	if (key.pending)
+		key.passive = key.active;
+	else
+		key.pending = key.active;
+	rx->timer2 = jiffies;
+	tipc_crypto_key_set_state(rx, key.passive, 0, key.pending);
+	tipc_aead_users_set(rx->aead[key.pending], 0);
+	pr_debug("%s: key[%d] is deactivated\n", rx->name, key.active);
+	goto s5;
+
+s4:
+	/* RX passive: outdated or not working -> free */
+	if (!key.passive)
+		goto s5;
+	if (time_before(jiffies, rx->timer2 + TIPC_RX_PASSIVE_LIM) &&
+	    tipc_aead_users(rx->aead[key.passive]) > -10)
+		goto s5;
+
+	tipc_crypto_key_set_state(rx, 0, key.active, key.pending);
+	tipc_crypto_key_detach(rx->aead[key.passive], &rx->lock);
+	pr_debug("%s: key[%d] is freed\n", rx->name, key.passive);
+
+s5:
+	spin_unlock(&rx->lock);
+
+	/* Relax it here, the flag will be set again if it really is, but only
+	 * when we are not in grace period for safety!
+	 */
+	if (time_after(jiffies, tx->timer2 + TIPC_TX_GRACE_PERIOD))
+		tx->legacy_user = 0;
+
+	/* Limit max_tfms & do debug commands if needed */
+	if (likely(sysctl_tipc_max_tfms <= TIPC_MAX_TFMS_LIM))
+		return;
+
+	cmd = sysctl_tipc_max_tfms;
+	sysctl_tipc_max_tfms = TIPC_MAX_TFMS_DEF;
+	tipc_crypto_do_cmd(rx->net, cmd);
+}
+
+static inline void tipc_crypto_clone_msg(struct net *net, struct sk_buff *_skb,
+					 struct tipc_bearer *b,
+					 struct tipc_media_addr *dst,
+					 struct tipc_node *__dnode, u8 type)
+{
+	struct sk_buff *skb;
+
+	skb = skb_clone(_skb, GFP_ATOMIC);
+	if (skb) {
+		TIPC_SKB_CB(skb)->xmit_type = type;
+		tipc_crypto_xmit(net, &skb, b, dst, __dnode);
+		if (skb)
+			b->media->send_msg(net, skb, b, dst);
+	}
+}
+
+/**
+ * tipc_crypto_xmit - Build & encrypt TIPC message for xmit
+ * @net: struct net
+ * @skb: input/output message skb pointer
+ * @b: bearer used for xmit later
+ * @dst: destination media address
+ * @__dnode: destination node for reference if any
+ *
+ * First, build an encryption message header on the top of the message, then
+ * encrypt the original TIPC message by using the pending, master or active
+ * key with this preference order.
+ * If the encryption is successful, the encrypted skb is returned directly or
+ * via the callback.
+ * Otherwise, the skb is freed!
+ *
+ * Return:
+ * * 0                   : the encryption has succeeded (or no encryption)
+ * * -EINPROGRESS/-EBUSY : the encryption is ongoing, a callback will be made
+ * * -ENOKEK             : the encryption has failed due to no key
+ * * -EKEYREVOKED        : the encryption has failed due to key revoked
+ * * -ENOMEM             : the encryption has failed due to no memory
+ * * < 0                 : the encryption has failed due to other reasons
+ */
+int tipc_crypto_xmit(struct net *net, struct sk_buff **skb,
+		     struct tipc_bearer *b, struct tipc_media_addr *dst,
+		     struct tipc_node *__dnode)
+{
+	struct tipc_crypto *__rx = tipc_node_crypto_rx(__dnode);
+	struct tipc_crypto *tx = tipc_net(net)->crypto_tx;
+	struct tipc_crypto_stats __percpu *stats = tx->stats;
+	struct tipc_msg *hdr = buf_msg(*skb);
+	struct tipc_key key = tx->key;
+	struct tipc_aead *aead = NULL;
+	u32 user = msg_user(hdr);
+	u32 type = msg_type(hdr);
+	int rc = -ENOKEY;
+	u8 tx_key = 0;
+
+	/* No encryption? */
+	if (!tx->working)
+		return 0;
+
+	/* Pending key if peer has active on it or probing time */
+	if (unlikely(key.pending)) {
+		tx_key = key.pending;
+		if (!tx->key_master && !key.active)
+			goto encrypt;
+		if (__rx && atomic_read(&__rx->peer_rx_active) == tx_key)
+			goto encrypt;
+		if (TIPC_SKB_CB(*skb)->xmit_type == SKB_PROBING) {
+			pr_debug("%s: probing for key[%d]\n", tx->name,
+				 key.pending);
+			goto encrypt;
+		}
+		if (user == LINK_CONFIG || user == LINK_PROTOCOL)
+			tipc_crypto_clone_msg(net, *skb, b, dst, __dnode,
+					      SKB_PROBING);
+	}
+
+	/* Master key if this is a *vital* message or in grace period */
+	if (tx->key_master) {
+		tx_key = KEY_MASTER;
+		if (!key.active)
+			goto encrypt;
+		if (TIPC_SKB_CB(*skb)->xmit_type == SKB_GRACING) {
+			pr_debug("%s: gracing for msg (%d %d)\n", tx->name,
+				 user, type);
+			goto encrypt;
+		}
+		if (user == LINK_CONFIG ||
+		    (user == LINK_PROTOCOL && type == RESET_MSG) ||
+		    (user == MSG_CRYPTO && type == KEY_DISTR_MSG) ||
+		    time_before(jiffies, tx->timer2 + TIPC_TX_GRACE_PERIOD)) {
+			if (__rx && __rx->key_master &&
+			    !atomic_read(&__rx->peer_rx_active))
+				goto encrypt;
+			if (!__rx) {
+				if (likely(!tx->legacy_user))
+					goto encrypt;
+				tipc_crypto_clone_msg(net, *skb, b, dst,
+						      __dnode, SKB_GRACING);
+			}
+		}
+	}
+
+	/* Else, use the active key if any */
+	if (likely(key.active)) {
+		tx_key = key.active;
+		goto encrypt;
+	}
+
+	goto exit;
+
+encrypt:
+	aead = tipc_aead_get(tx->aead[tx_key]);
+	if (unlikely(!aead))
+		goto exit;
+	rc = tipc_ehdr_build(net, aead, tx_key, *skb, __rx);
+	if (likely(rc > 0))
+		rc = tipc_aead_encrypt(aead, *skb, b, dst, __dnode);
+
+exit:
+	switch (rc) {
+	case 0:
+		this_cpu_inc(stats->stat[STAT_OK]);
+		break;
+	case -EINPROGRESS:
+	case -EBUSY:
+		this_cpu_inc(stats->stat[STAT_ASYNC]);
+		*skb = NULL;
+		return rc;
+	default:
+		this_cpu_inc(stats->stat[STAT_NOK]);
+		if (rc == -ENOKEY)
+			this_cpu_inc(stats->stat[STAT_NOKEYS]);
+		else if (rc == -EKEYREVOKED)
+			this_cpu_inc(stats->stat[STAT_BADKEYS]);
+		kfree_skb(*skb);
+		*skb = NULL;
+		break;
+	}
+
+	tipc_aead_put(aead);
+	return rc;
+}
+
+/**
+ * tipc_crypto_rcv - Decrypt an encrypted TIPC message from peer
+ * @net: struct net
+ * @rx: RX crypto handle
+ * @skb: input/output message skb pointer
+ * @b: bearer where the message has been received
+ *
+ * If the decryption is successful, the decrypted skb is returned directly or
+ * as the callback, the encryption header and auth tag will be trimed out
+ * before forwarding to tipc_rcv() via the tipc_crypto_rcv_complete().
+ * Otherwise, the skb will be freed!
+ * Note: RX key(s) can be re-aligned, or in case of no key suitable, TX
+ * cluster key(s) can be taken for decryption (- recursive).
+ *
+ * Return:
+ * * 0                   : the decryption has successfully completed
+ * * -EINPROGRESS/-EBUSY : the decryption is ongoing, a callback will be made
+ * * -ENOKEY             : the decryption has failed due to no key
+ * * -EBADMSG            : the decryption has failed due to bad message
+ * * -ENOMEM             : the decryption has failed due to no memory
+ * * < 0                 : the decryption has failed due to other reasons
+ */
+int tipc_crypto_rcv(struct net *net, struct tipc_crypto *rx,
+		    struct sk_buff **skb, struct tipc_bearer *b)
+{
+	struct tipc_crypto *tx = tipc_net(net)->crypto_tx;
+	struct tipc_crypto_stats __percpu *stats;
+	struct tipc_aead *aead = NULL;
+	struct tipc_key key;
+	int rc = -ENOKEY;
+	u8 tx_key, n;
+
+	tx_key = ((struct tipc_ehdr *)(*skb)->data)->tx_key;
+
+	/* New peer?
+	 * Let's try with TX key (i.e. cluster mode) & verify the skb first!
+	 */
+	if (unlikely(!rx || tx_key == KEY_MASTER))
+		goto pick_tx;
+
+	/* Pick RX key according to TX key if any */
+	key = rx->key;
+	if (tx_key == key.active || tx_key == key.pending ||
+	    tx_key == key.passive)
+		goto decrypt;
+
+	/* Unknown key, let's try to align RX key(s) */
+	if (tipc_crypto_key_try_align(rx, tx_key))
+		goto decrypt;
+
+pick_tx:
+	/* No key suitable? Try to pick one from TX... */
+	aead = tipc_crypto_key_pick_tx(tx, rx, *skb, tx_key);
+	if (aead)
+		goto decrypt;
+	goto exit;
+
+decrypt:
+	rcu_read_lock();
+	if (!aead)
+		aead = tipc_aead_get(rx->aead[tx_key]);
+	rc = tipc_aead_decrypt(net, aead, *skb, b);
+	rcu_read_unlock();
+
+exit:
+	stats = ((rx) ?: tx)->stats;
+	switch (rc) {
+	case 0:
+		this_cpu_inc(stats->stat[STAT_OK]);
+		break;
+	case -EINPROGRESS:
+	case -EBUSY:
+		this_cpu_inc(stats->stat[STAT_ASYNC]);
+		*skb = NULL;
+		return rc;
+	default:
+		this_cpu_inc(stats->stat[STAT_NOK]);
+		if (rc == -ENOKEY) {
+			kfree_skb(*skb);
+			*skb = NULL;
+			if (rx) {
+				/* Mark rx->nokey only if we dont have a
+				 * pending received session key, nor a newer
+				 * one i.e. in the next slot.
+				 */
+				n = key_next(tx_key);
+				rx->nokey = !(rx->skey ||
+					      rcu_access_pointer(rx->aead[n]));
+				pr_debug_ratelimited("%s: nokey %d, key %d/%x\n",
+						     rx->name, rx->nokey,
+						     tx_key, rx->key.keys);
+				tipc_node_put(rx->node);
+			}
+			this_cpu_inc(stats->stat[STAT_NOKEYS]);
+			return rc;
+		} else if (rc == -EBADMSG) {
+			this_cpu_inc(stats->stat[STAT_BADMSGS]);
+		}
+		break;
+	}
+
+	tipc_crypto_rcv_complete(net, aead, b, skb, rc);
+	return rc;
+}
+
+static void tipc_crypto_rcv_complete(struct net *net, struct tipc_aead *aead,
+				     struct tipc_bearer *b,
+				     struct sk_buff **skb, int err)
+{
+	struct tipc_skb_cb *skb_cb = TIPC_SKB_CB(*skb);
+	struct tipc_crypto *rx = aead->crypto;
+	struct tipc_aead *tmp = NULL;
+	struct tipc_ehdr *ehdr;
+	struct tipc_node *n;
+
+	/* Is this completed by TX? */
+	if (unlikely(is_tx(aead->crypto))) {
+		rx = skb_cb->tx_clone_ctx.rx;
+		pr_debug("TX->RX(%s): err %d, aead %p, skb->next %p, flags %x\n",
+			 (rx) ? tipc_node_get_id_str(rx->node) : "-", err, aead,
+			 (*skb)->next, skb_cb->flags);
+		pr_debug("skb_cb [recurs %d, last %p], tx->aead [%p %p %p]\n",
+			 skb_cb->tx_clone_ctx.recurs, skb_cb->tx_clone_ctx.last,
+			 aead->crypto->aead[1], aead->crypto->aead[2],
+			 aead->crypto->aead[3]);
+		if (unlikely(err)) {
+			if (err == -EBADMSG && (*skb)->next)
+				tipc_rcv(net, (*skb)->next, b);
+			goto free_skb;
+		}
+
+		if (likely((*skb)->next)) {
+			kfree_skb((*skb)->next);
+			(*skb)->next = NULL;
+		}
+		ehdr = (struct tipc_ehdr *)(*skb)->data;
+		if (!rx) {
+			WARN_ON(ehdr->user != LINK_CONFIG);
+			n = tipc_node_create(net, 0, ehdr->id, 0xffffu, 0,
+					     true);
+			rx = tipc_node_crypto_rx(n);
+			if (unlikely(!rx))
+				goto free_skb;
+		}
+
+		/* Ignore cloning if it was TX master key */
+		if (ehdr->tx_key == KEY_MASTER)
+			goto rcv;
+		if (tipc_aead_clone(&tmp, aead) < 0)
+			goto rcv;
+		WARN_ON(!refcount_inc_not_zero(&tmp->refcnt));
+		if (tipc_crypto_key_attach(rx, tmp, ehdr->tx_key, false) < 0) {
+			tipc_aead_free(&tmp->rcu);
+			goto rcv;
+		}
+		tipc_aead_put(aead);
+		aead = tmp;
+	}
+
+	if (unlikely(err)) {
+		tipc_aead_users_dec((struct tipc_aead __force __rcu *)aead, INT_MIN);
+		goto free_skb;
+	}
+
+	/* Set the RX key's user */
+	tipc_aead_users_set((struct tipc_aead __force __rcu *)aead, 1);
+
+	/* Mark this point, RX works */
+	rx->timer1 = jiffies;
+
+rcv:
+	/* Remove ehdr & auth. tag prior to tipc_rcv() */
+	ehdr = (struct tipc_ehdr *)(*skb)->data;
+
+	/* Mark this point, RX passive still works */
+	if (rx->key.passive && ehdr->tx_key == rx->key.passive)
+		rx->timer2 = jiffies;
+
+	skb_reset_network_header(*skb);
+	skb_pull(*skb, tipc_ehdr_size(ehdr));
+	if (pskb_trim(*skb, (*skb)->len - aead->authsize))
+		goto free_skb;
+
+	/* Validate TIPCv2 message */
+	if (unlikely(!tipc_msg_validate(skb))) {
+		pr_err_ratelimited("Packet dropped after decryption!\n");
+		goto free_skb;
+	}
+
+	/* Ok, everything's fine, try to synch own keys according to peers' */
+	tipc_crypto_key_synch(rx, *skb);
+
+	/* Re-fetch skb cb as skb might be changed in tipc_msg_validate */
+	skb_cb = TIPC_SKB_CB(*skb);
+
+	/* Mark skb decrypted */
 	skb_cb->decrypted = 1;
 
 	/* Clear clone cxt if any */
@@ -2278,31 +2739,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2787,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2935,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2275,55 +2274,46 @@
  *
  * Return: "true" if the key has been scheduled for attaching, otherwise
  * "false".
- */
-static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
-{
-
-	struct tipc_crypto *tx  = NULL;
-	struct tipc_aead_key *skey = NULL;
-	u16 key_gen = msg_key_gen(hdr);
-	u32 size = msg_data_sz(hdr);
-	u8 *data = msg_data(hdr);
-	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
-	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
-
-	spin_lock(&rx->lock);
-	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
-		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
-		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
-	}
-
-	/* Allocate memory for the key */
-	skey = kmalloc(size, GFP_ATOMIC);
-	if (unlikely(!skey)) {
-		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
-	}
-
-	/* Copy key from msg data */
+
 	skey->keylen = keylen;
 	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
 	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
 	       skey->keylen);
-
+	
 	rx->key_gen = key_gen;
 	rx->skey_mode = msg_key_mode(hdr);
 	rx->skey = skey;
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+	spin_unlock(&rx->lock);
+
+	/* Schedule the key attaching on this crypto */
+	if (likely(tx && skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+		return true;
+
+	kfree(skey);
+	return false;
+
+	skey->keylen = keylen;
+	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
+	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
+	       skey->keylen);
+
+	rx->key_gen = key_gen;
+	rx->skey_mode = msg_key_mode(hdr);
+	rx->skey = skey;
+	rx->nokey = 0;
+	mb(); /* for nokey flag */
+
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2454,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2314,18 +2322,19 @@
 	rx->key_gen = key_gen;
 	rx->skey_mode = msg_key_mode(hdr);
 	rx->skey = skey;
+
+	/* Ensure memory barriers for the nokey flag */
 	rx->nokey = 0;
-	mb(); /* for nokey flag */
-
-exit:
+	mb();
+
+exit_unlock:
 	spin_unlock(&rx->lock);
+
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
-	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+	if (rx->net && skey && queue_delayed_work(tx->wq, &rx->work, 0))
 		return true;
-	}
+
 	return false;
-}
 
 /**
  * tipc_crypto_work_rx - Scheduled RX works handler
@@ -2464,7 +2473,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2461,8 +2470,15 @@
 		pr_warn_ratelimited("%s: rekeying returns %d\n", tx->name, rc);
 
 resched:
-	/* Re-schedule rekeying if any */
+
+ /* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
+
+	/* Free sensitive memory securely */
+	if (unlikely(skey)) {
+		memzero_explicit(skey, tipc_aead_key_size(skey));
+		kfree_sensitive(skey);
+	}
 }
 
 #ifdef CONFIG_TIPC_TEST

[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:run_once:4) Took 92.13 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:run_once:2) Started...
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:act) Started...
Suggested diff:
--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -32,13 +32,12 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <crypto/aead.h>
-#include <kunit/test-bug.h>
-#include <crypto/aes.h>
-#include <crypto/rng.h>
-#include "crypto.h"
+
+ #include <crypto/aead.h>
+ #include <kunit/test-bug.h>
+ #include <crypto/aes.h>
+ #include <crypto/rng.h>
+ #include "crypto.h"
 #include "msg.h"
 #include "bcast.h"
 
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2473,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,44 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
+	return 0;
+		if (!c->wq) {
+			kfree(c);
+			return -ENOMEM;
+		}
+	}
+
+	/* Allocate statistic structure */
+	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_ATOMIC);
+	if (!c->stats) {
+		if (c->wq)
+			destroy_workqueue(c->wq);
+		kfree_sensitive(c);
+		return -ENOMEM;
+	}
+
+	c->flags = 0;
+	c->net = net;
+	c->node = node;
+	get_random_bytes(&c->key_gen, 2);
+	tipc_crypto_key_set_state(c, 0, 0, 0);
+	atomic_set(&c->key_distr, 0);
+	atomic_set(&c->peer_rx_active, 0);
+	atomic64_set(&c->sndnxt, 0);
+	c->timer1 = jiffies;
+	c->timer2 = jiffies;
+	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
+	spin_lock_init(&c->lock);
+	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
+		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+			       tipc_own_id_string(c->net));
+
+	if (is_rx(c))
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
+	else
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+	*crypto = c;
 	return 0;
 }
 
@@ -2278,31 +2315,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2363,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2511,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1493,13 +1494,14 @@
 	atomic_set(&c->peer_rx_active, 0);
 	atomic64_set(&c->sndnxt, 0);
 	c->timer1 = jiffies;
+
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
 
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
-		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
-			       tipc_own_id_string(c->net));
+	          (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+	                       tipc_own_id_string(c->net));
 
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
@@ -1507,7 +1509,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2279,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2327,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2475,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1504,13 +1504,13 @@
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
 	else
-		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+ 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
 
 	return 0;
 }
-
 void tipc_crypto_stop(struct tipc_crypto **crypto)
 {
 	struct tipc_crypto *c = *crypto;
@@ -2278,31 +2278,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2326,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2474,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2275,37 +2274,7 @@
  *
  * Return: "true" if the key has been scheduled for attaching, otherwise
  * "false".
- */
-static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
-{
-
-	struct tipc_crypto *tx  = NULL;
-	struct tipc_aead_key *skey = NULL;
-	u16 key_gen = msg_key_gen(hdr);
-	u32 size = msg_data_sz(hdr);
-	u8 *data = msg_data(hdr);
-	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
-	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
-
-	spin_lock(&rx->lock);
-	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
-		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
-		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
-	}
-
-	/* Allocate memory for the key */
-	skey = kmalloc(size, GFP_ATOMIC);
-	if (unlikely(!skey)) {
-		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
-	}
-
-	/* Copy key from msg data */
+
 	skey->keylen = keylen;
 	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
 	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
@@ -2317,13 +2286,35 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
+	/* Schedule the key attaching on this crypto */
+	if (likely(skey && tx && queue_delayed_work(tx->wq, &rx->work, 0)))
+		return true;
+
+	return false;
+
+	skey->keylen = keylen;
+	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
+	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
+	       skey->keylen);
+
+	rx->key_gen = key_gen;
+	rx->skey_mode = msg_key_mode(hdr);
+	rx->skey = skey;
+	rx->nokey = 0;
+	mb(); /* for nokey flag */
+
+exit_unlock:
 	spin_unlock(&rx->lock);
+
+exit:
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2455,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2314,19 +2322,13 @@
 	rx->key_gen = key_gen;
 	rx->skey_mode = msg_key_mode(hdr);
 	rx->skey = skey;
-	rx->nokey = 0;
-	mb(); /* for nokey flag */
-
-exit:
+
 	spin_unlock(&rx->lock);
-	/* Schedule the key attaching on this crypto */
-	if (rx->net){
-	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+
+	if (rx->net && likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
-}
-
 /**
  * tipc_crypto_work_rx - Scheduled RX works handler
  * @work: the struct RX work
@@ -2464,7 +2466,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2461,10 +2470,10 @@
 		pr_warn_ratelimited("%s: rekeying returns %d\n", tx->name, rc);
 
 resched:
+
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
-}
-
+	return;
 #ifdef CONFIG_TIPC_TEST
 #include "tipc_test.c"
 #endif

[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:act) Took 24.51 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'/tmp/tmprir3ykky:445: space before tab in indent.\n \t\tINIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nerror: tipc/crypto.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmprir3ykky\n'
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:acc-evaluator:patch) Took 0.26 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:evaluate) Took 0.27 seconds
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:pick) Took 0.00 seconds
--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -32,13 +32,12 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <crypto/aead.h>
-#include <kunit/test-bug.h>
-#include <crypto/aes.h>
-#include <crypto/rng.h>
-#include "crypto.h"
+
+ #include <crypto/aead.h>
+ #include <kunit/test-bug.h>
+ #include <crypto/aes.h>
+ #include <crypto/rng.h>
+ #include "crypto.h"
 #include "msg.h"
 #include "bcast.h"
 
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2473,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,44 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
+	return 0;
+		if (!c->wq) {
+			kfree(c);
+			return -ENOMEM;
+		}
+	}
+
+	/* Allocate statistic structure */
+	c->stats = alloc_percpu_gfp(struct tipc_crypto_stats, GFP_ATOMIC);
+	if (!c->stats) {
+		if (c->wq)
+			destroy_workqueue(c->wq);
+		kfree_sensitive(c);
+		return -ENOMEM;
+	}
+
+	c->flags = 0;
+	c->net = net;
+	c->node = node;
+	get_random_bytes(&c->key_gen, 2);
+	tipc_crypto_key_set_state(c, 0, 0, 0);
+	atomic_set(&c->key_distr, 0);
+	atomic_set(&c->peer_rx_active, 0);
+	atomic64_set(&c->sndnxt, 0);
+	c->timer1 = jiffies;
+	c->timer2 = jiffies;
+	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
+	spin_lock_init(&c->lock);
+	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
+		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+			       tipc_own_id_string(c->net));
+
+	if (is_rx(c))
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
+	else
+		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+	*crypto = c;
 	return 0;
 }
 
@@ -2278,31 +2315,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2363,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2511,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1493,13 +1494,14 @@
 	atomic_set(&c->peer_rx_active, 0);
 	atomic64_set(&c->sndnxt, 0);
 	c->timer1 = jiffies;
+
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
 
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
-		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
-			       tipc_own_id_string(c->net));
+	          (is_rx(c)) ? tipc_node_get_id_str(c->node) :
+	                       tipc_own_id_string(c->net));
 
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
@@ -1507,7 +1509,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2279,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2327,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2475,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1504,13 +1504,13 @@
 	if (is_rx(c))
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_rx);
 	else
-		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
+
+ 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
 
 	return 0;
 }
-
 void tipc_crypto_stop(struct tipc_crypto **crypto)
 {
 	struct tipc_crypto *c = *crypto;
@@ -2278,31 +2278,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2326,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2474,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2275,37 +2274,7 @@
  *
  * Return: "true" if the key has been scheduled for attaching, otherwise
  * "false".
- */
-static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
-{
-
-	struct tipc_crypto *tx  = NULL;
-	struct tipc_aead_key *skey = NULL;
-	u16 key_gen = msg_key_gen(hdr);
-	u32 size = msg_data_sz(hdr);
-	u8 *data = msg_data(hdr);
-	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
-	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
-
-	spin_lock(&rx->lock);
-	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
-		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
-		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
-	}
-
-	/* Allocate memory for the key */
-	skey = kmalloc(size, GFP_ATOMIC);
-	if (unlikely(!skey)) {
-		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
-	}
-
-	/* Copy key from msg data */
+
 	skey->keylen = keylen;
 	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
 	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
@@ -2317,13 +2286,35 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
+	/* Schedule the key attaching on this crypto */
+	if (likely(skey && tx && queue_delayed_work(tx->wq, &rx->work, 0)))
+		return true;
+
+	return false;
+
+	skey->keylen = keylen;
+	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
+	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
+	       skey->keylen);
+
+	rx->key_gen = key_gen;
+	rx->skey_mode = msg_key_mode(hdr);
+	rx->skey = skey;
+	rx->nokey = 0;
+	mb(); /* for nokey flag */
+
+exit_unlock:
 	spin_unlock(&rx->lock);
+
+exit:
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2464,7 +2455,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2314,19 +2322,13 @@
 	rx->key_gen = key_gen;
 	rx->skey_mode = msg_key_mode(hdr);
 	rx->skey = skey;
-	rx->nokey = 0;
-	mb(); /* for nokey flag */
-
-exit:
+
 	spin_unlock(&rx->lock);
-	/* Schedule the key attaching on this crypto */
-	if (rx->net){
-	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
+
+	if (rx->net && likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
-}
-
 /**
  * tipc_crypto_work_rx - Scheduled RX works handler
  * @work: the struct RX work
@@ -2464,7 +2466,3 @@
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
 }
-
-#ifdef CONFIG_TIPC_TEST
-#include "tipc_test.c"
-#endif


--- net/tipc/crypto.c
+++ net/tipc/crypto.c
@@ -35,7 +35,6 @@
  */
 
 #include <crypto/aead.h>
-#include <kunit/test-bug.h>
 #include <crypto/aes.h>
 #include <crypto/rng.h>
 #include "crypto.h"
@@ -1462,10 +1461,12 @@
 
 	if (*crypto)
 		return -EEXIST;
+
 	/* Allocate crypto */
 	c = kzalloc(sizeof(*c), GFP_ATOMIC);
 	if (!c)
 		return -ENOMEM;
+
 	/* Allocate workqueue on TX */
 	if (!node) {
 		c->wq = alloc_ordered_workqueue("tipc_crypto", 0);
@@ -1496,7 +1497,6 @@
 	c->timer2 = jiffies;
 	c->rekeying_intv = TIPC_REKEYING_INTV_DEF;
 	spin_lock_init(&c->lock);
-
 	scnprintf(c->name, 48, "%s(%s)", (is_rx(c)) ? "RX" : "TX",
 		  (is_rx(c)) ? tipc_node_get_id_str(c->node) :
 			       tipc_own_id_string(c->net));
@@ -1507,7 +1507,6 @@
 		INIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);
 
 	*crypto = c;
-
 	return 0;
 }
 
@@ -2278,31 +2277,40 @@
  */
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
-
-	struct tipc_crypto *tx  = NULL;
+	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
 	u32 size = msg_data_sz(hdr);
 	u8 *data = msg_data(hdr);
 	unsigned int keylen;
-	
-	if(rx->net){
-		tx = tipc_net(rx->net)->crypto_tx;
-	}
+
+	/* Verify whether the size can exist in the packet */
+	if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
+		pr_debug("%s: message data size is too small\n", rx->name);
+		goto exit;
+	}
+
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
+
+	/* Verify the supplied size values */
+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
+		     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
+		pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
+		goto exit;
+	}
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
-		goto exit;
+		goto exit_unlock;
 	}
 
 	/* Copy key from msg data */
@@ -2317,13 +2325,14 @@
 	rx->nokey = 0;
 	mb(); /* for nokey flag */
 
+exit_unlock:
+	spin_unlock(&rx->lock);
+
 exit:
-	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
-	if (rx->net){
 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
 		return true;
-	}
+
 	return false;
 }
 
@@ -2461,10 +2470,10 @@
 		pr_warn_ratelimited("%s: rekeying returns %d\n", tx->name, rc);
 
 resched:
+
 	/* Re-schedule rekeying if any */
 	tipc_crypto_rekeying_sched(tx, false, 0);
-}
-
+	return;
 #ifdef CONFIG_TIPC_TEST
 #include "tipc_test.c"
 #endif

[logging_performance](infilling-linux-linux_test_harness-gpt-4o-1:wire:run_once:2) Took 25.14 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:run_once:4) Started...
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:act) Started...
Suggested diff:
--- drivers/NRFIN-00001/joke.c
+++ drivers/NRFIN-00001/joke.c
@@ -83,13 +83,12 @@
 
 	// return error (-2) if the joke_str is too long.
 	} else if (strlen(joke_str) >= MAX_JOKE_STRING_LEN - 1) {
+
 		if (LOGLEVEL >= NRFIN00001_LOG_INFO) {
 			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "Joke was too long -->\n");
-
-			nrfin00001_syslog(NRFIN00001_LOG_ERROR, joke_str);
+			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "%s\n", joke_str);
 		}
 		return -2;
-
 	} else {
 		int idx = jokedb->count;
 		// copy joke_str into next slot in joke db

[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:act) Took 2.02 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'error: NRFIN-00001/joke.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmp14_sa3po\n'
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:acc-evaluator:patch) Took 0.42 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:evaluate) Took 0.42 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:pick) Took 0.00 seconds
--- drivers/NRFIN-00001/joke.c
+++ drivers/NRFIN-00001/joke.c
@@ -83,13 +83,12 @@
 
 	// return error (-2) if the joke_str is too long.
 	} else if (strlen(joke_str) >= MAX_JOKE_STRING_LEN - 1) {
+
 		if (LOGLEVEL >= NRFIN00001_LOG_INFO) {
 			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "Joke was too long -->\n");
-
-			nrfin00001_syslog(NRFIN00001_LOG_ERROR, joke_str);
+			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "%s\n", joke_str);
 		}
 		return -2;
-
 	} else {
 		int idx = jokedb->count;
 		// copy joke_str into next slot in joke db

[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:run_once:4) Took 2.64 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:run_once:2) Started...
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:act) Started...
Suggested diff:
--- drivers/NRFIN-00001/joke.c
+++ drivers/NRFIN-00001/joke.c
@@ -83,13 +83,13 @@
 
 	// return error (-2) if the joke_str is too long.
 	} else if (strlen(joke_str) >= MAX_JOKE_STRING_LEN - 1) {
+
 		if (LOGLEVEL >= NRFIN00001_LOG_INFO) {
 			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "Joke was too long -->\n");
-
-			nrfin00001_syslog(NRFIN00001_LOG_ERROR, joke_str);
+			// Prevents format string vulnerability
+			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "%s\n", joke_str);
 		}
 		return -2;
-
 	} else {
 		int idx = jokedb->count;
 		// copy joke_str into next slot in joke db

[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:act) Took 2.18 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'error: NRFIN-00001/joke.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmp1wx32sh9\n'
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:acc-evaluator:patch) Took 0.43 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:evaluate) Took 0.43 seconds
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:pick) Took 0.00 seconds
--- drivers/NRFIN-00001/joke.c
+++ drivers/NRFIN-00001/joke.c
@@ -83,13 +83,13 @@
 
 	// return error (-2) if the joke_str is too long.
 	} else if (strlen(joke_str) >= MAX_JOKE_STRING_LEN - 1) {
+
 		if (LOGLEVEL >= NRFIN00001_LOG_INFO) {
 			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "Joke was too long -->\n");
-
-			nrfin00001_syslog(NRFIN00001_LOG_ERROR, joke_str);
+			// Prevents format string vulnerability
+			nrfin00001_syslog(NRFIN00001_LOG_ERROR, "%s\n", joke_str);
 		}
 		return -2;
-
 	} else {
 		int idx = jokedb->count;
 		// copy joke_str into next slot in joke db

[logging_performance](infilling-linux-NRFIN-00001-gpt-4o-1:wire:run_once:2) Took 2.81 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:run_once:4) Started...
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:act) Started...
Suggested diff:
--- drivers/NRFIN-00003/service.c
+++ drivers/NRFIN-00003/service.c
@@ -70,13 +70,16 @@
     }
 
     // Pull out the URI
+
     memcpy(
             (unsigned char *)buf_verb,
-            (unsigned char *)buf_recv+pos_uri+1,
-            URI_BUF_SZ+1);
-
-    return ret;
-}
+            (unsigned char *)buf_recv + pos_uri + 1,
+            URI_BUF_SZ);
+
+    // Ensure buffer is null-terminated to prevent overflow
+    buf_verb[URI_BUF_SZ - 1] = '\0';
+
+    return ret;
 
 // Check whether the user has any renrfin00003_maining credits.
 int check_plebian(void) {

[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:act) Took 1.39 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'error: NRFIN-00003/service.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmptzs6yv8o\n'
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:acc-evaluator:patch) Took 0.49 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:evaluate) Took 0.50 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:pick) Took 0.00 seconds
--- drivers/NRFIN-00003/service.c
+++ drivers/NRFIN-00003/service.c
@@ -70,13 +70,16 @@
     }
 
     // Pull out the URI
+
     memcpy(
             (unsigned char *)buf_verb,
-            (unsigned char *)buf_recv+pos_uri+1,
-            URI_BUF_SZ+1);
-
-    return ret;
-}
+            (unsigned char *)buf_recv + pos_uri + 1,
+            URI_BUF_SZ);
+
+    // Ensure buffer is null-terminated to prevent overflow
+    buf_verb[URI_BUF_SZ - 1] = '\0';
+
+    return ret;
 
 // Check whether the user has any renrfin00003_maining credits.
 int check_plebian(void) {

[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:run_once:4) Took 2.06 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:run_once:2) Started...
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:act) Started...
Suggested diff:
--- drivers/NRFIN-00003/service.c
+++ drivers/NRFIN-00003/service.c
@@ -70,13 +70,14 @@
     }
 
     // Pull out the URI
+
     memcpy(
-            (unsigned char *)buf_verb,
-            (unsigned char *)buf_recv+pos_uri+1,
-            URI_BUF_SZ+1);
-
-    return ret;
-}
+        (unsigned char *)buf_verb,
+        (unsigned char *)buf_recv + pos_uri + 1,
+        URI_BUF_SZ + 1);
+
+    return ret;
+
 
 // Check whether the user has any renrfin00003_maining credits.
 int check_plebian(void) {

[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:act) Took 1.25 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:evaluate) Started...
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:acc-evaluator:patch) Started...
Failed to apply the patch:
Command failed with return code 1
Details: b'error: NRFIN-00003/service.c: \xea\xb7\xb8\xeb\x9f\xb0 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\xb4\xeb\x82\x98 \xeb\x94\x94\xeb\xa0\x89\xed\x84\xb0\xeb\xa6\xac\xea\xb0\x80 \xec\x97\x86\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4\nPatching failed using: /tmp/tmp9ud7r82k\n'
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:acc-evaluator:patch) Took 0.27 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:evaluate) Took 0.27 seconds
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:pick) Started...
[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:pick) Took 0.00 seconds
--- drivers/NRFIN-00003/service.c
+++ drivers/NRFIN-00003/service.c
@@ -70,13 +70,14 @@
     }
 
     // Pull out the URI
+
     memcpy(
-            (unsigned char *)buf_verb,
-            (unsigned char *)buf_recv+pos_uri+1,
-            URI_BUF_SZ+1);
-
-    return ret;
-}
+        (unsigned char *)buf_verb,
+        (unsigned char *)buf_recv + pos_uri + 1,
+        URI_BUF_SZ + 1);
+
+    return ret;
+
 
 // Check whether the user has any renrfin00003_maining credits.
 int check_plebian(void) {

[logging_performance](infilling-linux-NRFIN-00003-gpt-4o-1:wire:run_once:2) Took 1.71 seconds
